{
    "version": "https://jsonfeed.org/version/1",
    "title": "失心耀的博客 • All posts by \"操作系统概论\" tag",
    "description": "",
    "home_page_url": "https://xinyao_idiot.gitee.io/zxy",
    "items": [
        {
            "id": "https://xinyao_idiot.gitee.io/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/",
            "url": "https://xinyao_idiot.gitee.io/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/",
            "title": "操作系统概论",
            "date_published": "2021-08-11T10:27:00.000Z",
            "content_html": "<h1 id=\"操作系统概论\"><a class=\"markdownIt-Anchor\" href=\"#操作系统概论\">#</a> 操作系统概论</h1>\n<h2 id=\"考试题型\"><a class=\"markdownIt-Anchor\" href=\"#考试题型\">#</a> 考试题型</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">题型</th>\n<th style=\"text-align:center\">数量</th>\n<th style=\"text-align:center\">分支</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">单选</td>\n<td style=\"text-align:center\">1 分 * 20</td>\n<td style=\"text-align:center\">20 分</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">填空</td>\n<td style=\"text-align:center\">2 分 * 10</td>\n<td style=\"text-align:center\">20 分</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">简答</td>\n<td style=\"text-align:center\">4 分 * 5</td>\n<td style=\"text-align:center\">20 分</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">综合</td>\n<td style=\"text-align:center\">10 分 * 4</td>\n<td style=\"text-align:center\">40 分</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"第一章操作系统简介\"><a class=\"markdownIt-Anchor\" href=\"#第一章操作系统简介\">#</a> 第一章：操作系统简介</h2>\n<h3 id=\"11-什么是操作系统\"><a class=\"markdownIt-Anchor\" href=\"#11-什么是操作系统\">#</a> 1.1 什么是操作系统</h3>\n<ol>\n<li>\n<p>操作系统的定义</p>\n<p>操作系统（Operating System，OS）是一种复杂的<strong>系统软件</strong>，是不同于<strong>程序代码</strong>、<strong>数据结构</strong>、<strong>数据初始化文件的集合</strong>，可执行。（选择、填空、简答）</p>\n</li>\n<li>\n<p><strong>用户与硬件之间</strong>的接口</p>\n<p>操作系统与<strong>硬件部分相互作用</strong>，比并且为运行在计算机上的<strong>应用程序提供执行环境</strong>。（选择、填空）</p>\n</li>\n<li>\n<p>资源的管理者</p>\n<ul>\n<li>\n<p><strong>处理机管理</strong></p>\n<p>定义：决定把处理机先给哪个程序用，后给哪个程序用</p>\n</li>\n<li>\n<p><strong>内存管理</strong></p>\n<p>定义：给程序分配内存空间</p>\n</li>\n<li>\n<p><strong>设备管理</strong></p>\n<p>定义：完成证明分配设备，分配哪台设备，怎么和设备连接等</p>\n</li>\n<li>\n<p><strong>文件管理</strong></p>\n<p>定义：为每个文件分配空间、建立目录、对目录进行组织管理以及根据用户请求从外存（硬盘）读取数据或将数据写入外存（硬盘）</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"12-操作系统的发展\"><a class=\"markdownIt-Anchor\" href=\"#12-操作系统的发展\">#</a> 1.2 操作系统的发展</h3>\n<ol>\n<li>\n<p>发展历程</p>\n<ul>\n<li>\n<p><strong>单道 批处理系统</strong></p>\n<ul>\n<li>定义：单道批处理系统<strong>内存中只有一道作业</strong></li>\n<li>特点：<strong>自动性、顺序性、单道性</strong>（选择、填空）</li>\n<li>优点：减少了等待人工操作的时间</li>\n<li>缺点：CPU 资源不能得到充分的利用</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080901.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080901.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>多道 批处理系统</strong></p>\n<ul>\n<li>定义：由操作系统的<strong>作业调度程序按一定策略</strong>从后备作业队列中<strong>选择若干个作业调入内存</strong>，使他们共享 CPU 和系统中的各种资源</li>\n<li>特点：<strong>多道性、无序性、调度性、复杂性</strong>（选择、填空）</li>\n<li>优点：能够提高 CPU、内存和 IO 设备的利用率和系统的吞吐量（选择、简答）</li>\n<li>缺点：系统平均周转时间长（选择、简答）</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080902.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080902.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>分时 操作系统</strong></p>\n<ul>\n<li>定义：允许<strong>多个用户</strong>通过终端机<strong>同时使用</strong>计算机，每个用户通过终端与主机交互时都能得到快速响应。</li>\n<li>特点：<strong>多路性、独立性、及时性、交互性</strong>（选择、填空）</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080903.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080903.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>实时 操作系统</strong></p>\n<ul>\n<li>定义：实时系统必须<strong>及时响应</strong>外部时间的请求，在规定时间内完成对该事件的处理。主要用于<strong>实时控制</strong>和<strong>实时信息处理</strong>领域。（选择、填空）</li>\n<li>特点：<strong>多路性、独立性、及时性、交互性、可靠性</strong>（选择、填空）</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080904.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080904.png\" class=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>操作系统产品现状（可略）</p>\n<table>\n<thead>\n<tr>\n<th>操作系统</th>\n<th>运行主体</th>\n<th>实例（了解即可）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>主机</strong>操作系统</td>\n<td>大型主机</td>\n<td>IBM 的 OS / 360、OS / 390</td>\n</tr>\n<tr>\n<td><strong>服务器</strong>操作系统</td>\n<td>网络服务器</td>\n<td>Linux、Windows Server</td>\n</tr>\n<tr>\n<td><strong>微机</strong>操作系统</td>\n<td>微型计算机</td>\n<td>Windows7、Mac OS</td>\n</tr>\n<tr>\n<td><strong>嵌入式</strong>操作系统</td>\n<td>嵌入式设备</td>\n<td>Android、iOS</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ol>\n<h3 id=\"13-操作系统特征\"><a class=\"markdownIt-Anchor\" href=\"#13-操作系统特征\">#</a> 1.3 操作系统特征</h3>\n<ul>\n<li>现在操作系统都支持<strong>多任务</strong>，具有<strong>并发</strong>、<strong>共享</strong>、<strong>虚拟</strong>和<strong>异步性</strong>特征。\n<ul>\n<li>并发：两个或多个事件在<strong>同一时间间隔</strong>内发生</li>\n<li>共享：系统中的<strong>资源</strong>可供内存中多个并发执行的<strong>进程共同使用</strong>。</li>\n<li>虚拟：最常用<strong>内存虚拟化</strong>，用户感觉到的内存大于实际内存。</li>\n<li>异步性：进程以<strong>不可预知的速度</strong>向前推进。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"14-操作系统的功能\"><a class=\"markdownIt-Anchor\" href=\"#14-操作系统的功能\">#</a> 1.4 操作系统的功能</h3>\n<ol>\n<li>\n<p>管理计算机资源</p>\n<ul>\n<li>\n<p>内存管理</p>\n<ul>\n<li>\n<p>含义：</p>\n<p>内存管理的主要任务是为<strong>多道程序的运行提供良好的环境</strong>，方便用户<strong>使用内存</strong>，提高内存的利用率，以及从<strong>逻辑上扩充内存</strong>以实现<strong>虚拟存储</strong>。</p>\n</li>\n<li>\n<p>内容：</p>\n<ol>\n<li>\n<p>内存分配</p>\n<p>主要任务是<strong>为每道程序分配内存空间</strong>，可采用两种分配方式，即<strong>静态分配方式</strong>和<strong>动态分配方式</strong>。</p>\n<ul>\n<li>静态分配方式\n<ul>\n<li>先把内存划分先把内存划分定的区域</li>\n<li>大小数量不再变化</li>\n</ul>\n</li>\n<li>动态分配方式\n<ul>\n<li>根据进程实际，请求分配内存</li>\n<li>大小数量动态变化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>内存保护</p>\n<ol>\n<li>\n<p>主要任务：</p>\n<p>一是使操作系统<strong>内核的空间</strong>不会被用户随意访问，以保证系统的安全和稳定；</p>\n<p>二是确保<strong>每道用户程序</strong>都在<strong>自己的内存空间</strong>中运行，互不干扰。</p>\n</li>\n<li>\n<p>内存保护的方式：</p>\n<ol>\n<li>\n<p>采用界限寄存器存放允许程序访问的地址区间的上限和下限。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080905.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080905.png\" class=\"\"></p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>地址映射</p>\n<p><strong>含义：<strong>CPU 执行程序过程中访问内存时，需要把</strong>程序的逻辑地址转变为物理地址</strong>，这个转换过程称为<strong>地址映射</strong>。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080906.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080906.png\" class=\"\"></p>\n</li>\n<li>\n<p>内存扩充</p>\n<p><strong>含义：<strong>借助于</strong>虚拟技术</strong>，从<strong>逻辑</strong>上扩充内存容量，使系统能够向用户提供比物理内存大的存储容量。</p>\n<p>➢<strong>请求调入：</strong></p>\n<p>允许系统在<strong>装入一部分用户程序</strong>时就启动该程序运行，在程序运行过程中<strong>若发现要执行的指令或访问的数据尚未装入内存</strong>，通过<strong>请求调入将需要指令或数据装入内存。</strong></p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080907.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080907.png\" class=\"\"></p>\n<p>➢<strong>置换功能：</strong></p>\n<p>在请求调入时，<strong>若发现内存空间不足</strong>，需要<strong>先将内存中的一部分内容换到外存中</strong>，以便<strong>腾出内存空间</strong>装入当前需要的内容。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080908.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080908.png\" class=\"\"></p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>进程管理</p>\n<ul>\n<li>内容：进程的描述与组织、进程控制、进程同步、进程通信及进程调度。</li>\n</ul>\n</li>\n<li>\n<p>设备管理</p>\n<ul>\n<li>含义：设备管理主要完成用户的<strong> I/O 请求</strong>，为用户<strong>分配 I/O 设备</strong>。</li>\n<li>功能：\n<ol>\n<li><strong>缓冲管理</strong></li>\n<li><strong>设备分配</strong></li>\n<li><strong>设备处理</strong></li>\n<li><strong>设备独立性和虚拟设备</strong> (设备独立性功能使应用程序独<br>\n立于物理设备)</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>文件管理</p>\n<ul>\n<li>\n<p>功能：</p>\n<ol>\n<li>\n<p>文件存储空间的管理</p>\n<p>为每个文件分配必要的<strong>外存空间</strong>，<strong>提高外存利用率</strong>，并能有助于<strong>提高访问文件的速度</strong>。</p>\n</li>\n<li>\n<p>目录管理</p>\n<p>为每个文件建立<strong>目录项</strong>并对众多目录项进行有效组织。目录项包括文件名、文件属性及文件的地址等信息。</p>\n</li>\n<li>\n<p>文件的读、写管理和存取控制</p>\n<p>根据用户的请求，<strong>从外存中读取数据</strong>或<strong>将数据写入外存</strong>。防止未经审核的用户存取文件，防止冒名顶替存取文件，防止以不正确的方式使用文件。</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>提供用户接口</p>\n<ul>\n<li>命令接口\n<ul>\n<li>目的：为了便于用户与计算机系统的交互</li>\n<li>分类：联机用户接口和脱机用户接口</li>\n<li>联机：常命令接口由一组键盘操作命令和命令解释程序组成</li>\n<li>脱机：为批处理作业的用户提供，也称为批处理用户接口</li>\n</ul>\n</li>\n<li>图形用户接口\n<ul>\n<li>用户可以轻松地通过<strong>选择窗口、菜单、对话框、滚动条、图标等</strong>简单的操作来完成对作业和任务的提交与控制。</li>\n</ul>\n</li>\n<li>程序接口\n<ul>\n<li>用户程序接口指的是<strong>应用程序</strong>和系统的<strong>核心程序</strong>的接口，就是<strong>系统调用</strong>。</li>\n<li>系统调用是一组预先定义好的模块，它们提供<strong>一条管道</strong>让应用程序或用户能由此得到<strong>核心程</strong>序的服务。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"15-操作系统的体系结构\"><a class=\"markdownIt-Anchor\" href=\"#15-操作系统的体系结构\">#</a> 1.5 操作系统的体系结构</h3>\n<ol>\n<li>简单的监控程序模型\n<ul>\n<li>功能简陋，任意时刻系统中只能运行一个任务 ，保证了对系统信息的互斥访问，保护了系统数据的安全。</li>\n</ul>\n</li>\n<li>单体结构模型一\n<ul>\n<li>所有的软件和数据结构都放置在 - 个逻辑模块中，对外层的用户程序提供一个完整的内核界面 —— 系统调用。</li>\n</ul>\n</li>\n<li>层次结构模型\n<ul>\n<li>基本思想是将操作系统分解为多个小的，容易理解的层。系统功能被隔离在不同层中。</li>\n</ul>\n</li>\n<li>客户 / 服务器模型与微内核结构\n<ul>\n<li>核心思想是核心功能外移，即把传统操作系统内核中的一些组成部分放到内核之外作为 - 个独立的服务器进程来实现。</li>\n</ul>\n</li>\n<li>动态可扩展结构模型\n<ul>\n<li>基本思想就是在运行过程中，能够动态地实现系统行为扩展的结构，也可称之为弹性结构。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"16-指令的执行\"><a class=\"markdownIt-Anchor\" href=\"#16-指令的执行\">#</a> 1.6 指令的执行</h3>\n<ol>\n<li>\n<p><strong>指令周期</strong></p>\n<ul>\n<li><strong>程序是具有独立功能的一组指令的集合</strong>，程序的执行就是按照某种控制流执行指令的过程。</li>\n<li>一个<strong>单一指令</strong>需要的<strong>处理</strong>称为<strong>指令周期</strong>。</li>\n<li>一个指令周期可以划分为两个步骤，分别是<strong>取指周期</strong>和<strong>执行周期</strong>。</li>\n<li><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080909.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080909.png\" class=\"\"></li>\n<li>** 程序计数器 (PC)<strong> 保存有下一次要取的指令的地址。取到的指令被放置在处理器的</strong>指令寄存器 (IR)** 中。</li>\n</ul>\n</li>\n<li>\n<p><strong>取指令和执行指令</strong></p>\n<p>指令中包含确定处理器要采取动作的位，处理器解释指令并执行要求的动作。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080910.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080910.png\" class=\"\"></p>\n<p>➢动作分类：</p>\n<ul>\n<li><strong>处理器与存储器</strong>之间的<strong>指令或数据传送</strong>操作</li>\n<li><strong>处理器与 I/O 设备</strong>之间的<strong>指令或数据传送</strong>操作</li>\n<li><strong>算术运算</strong>操作或<strong>逻辑运算</strong>操作</li>\n<li><strong>控制</strong>操作，即<strong>修改指令的执行顺序</strong>的操作</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"第二章进程管理重点\"><a class=\"markdownIt-Anchor\" href=\"#第二章进程管理重点\">#</a> 第二章：进程管理（重点）</h2>\n<h3 id=\"21-进程的描述\"><a class=\"markdownIt-Anchor\" href=\"#21-进程的描述\">#</a> 2.1 进程的描述</h3>\n<h4 id=\"211程序的顺序执行与并发执行\"><a class=\"markdownIt-Anchor\" href=\"#211程序的顺序执行与并发执行\">#</a> 2.1.1 程序的顺序执行与并发执行</h4>\n<ol>\n<li>\n<p>顺序执行</p>\n<ul>\n<li>含义：先进入内存的程序先执行，在一个程序执行完毕之前，不能执行其他程序</li>\n<li>特点：<strong>顺序性、封闭性、可再现性</strong></li>\n</ul>\n</li>\n<li>\n<p>并发执行</p>\n<ul>\n<li>含义：程序并发执行是指<strong>同一时间间隔内</strong>运行多个程序。一个程序执行结束前，可以运行其他程序</li>\n<li>特点：<strong>间断性、失去封闭性、不可再现性</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>宏观并行</strong>：用户看到多个程序同时向前推进</p>\n<p><strong>微观串行</strong>：任意时刻<strong>一个 CPU</strong> 上只有<strong>一个程序</strong>在执行</p>\n</li>\n</ol>\n<h4 id=\"212进程的概念\"><a class=\"markdownIt-Anchor\" href=\"#212进程的概念\">#</a> 2.1.2 进程的概念</h4>\n<ul>\n<li>\n<p>定义：</p>\n<ul>\n<li>\n<p>进程是允许并发执行的<strong>程序</strong>在某个数据集合上的<strong>运行过程</strong></p>\n</li>\n<li>\n<p>进程是由<strong>正文段、用户数据段及进程控制块</strong>共同组成的执行环境</p>\n<table>\n<thead>\n<tr>\n<th>正文段</th>\n<th>存放被执行的机器指令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>用户数据段</strong></td>\n<td><strong>存放用户数据</strong></td>\n</tr>\n<tr>\n<td><strong>进程控制块</strong></td>\n<td><strong>存放进程的运行环境</strong></td>\n</tr>\n</tbody>\n</table>\n</li>\n</ul>\n</li>\n<li>\n<p>特征：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特征</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">并发性</td>\n<td style=\"text-align:center\">多个进程实体能在一 - 段时间间隔内同时运行<br /><strong>并发性是进程和现代操作系统的重要特征</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">动态性</td>\n<td style=\"text-align:center\">进程是实体的执行过程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">独立性</td>\n<td style=\"text-align:center\">独立运行和资源调度的基本单位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">异步性</td>\n<td style=\"text-align:center\">进程的执行时断时续 ，何时执行、何时暂停都无法预知</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">结构特征</td>\n<td style=\"text-align:center\">进程实体包括用户<strong>正文段、 用户数据段</strong>和<strong>进程控制块</strong></td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>进程与程序的比较：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">程序</th>\n<th style=\"text-align:center\">进程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">动态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">永久</td>\n<td style=\"text-align:center\">暂时</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">指令集合</td>\n<td style=\"text-align:center\">包括正文段、用户数据段、进程控制块</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>进程和程序的联系</p>\n<ol>\n<li>进程是程序的一次执行</li>\n<li>一个程序可以对应多个进程</li>\n<li>同一个程序可以在不同的数据集合上运行，构成不同的进程</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"213-进程控制块pcb\"><a class=\"markdownIt-Anchor\" href=\"#213-进程控制块pcb\">#</a> 2.1.3 进程控制块（PCB）</h4>\n<ul>\n<li>进程实体包括用户正文段、用户数据段和进程控制段</li>\n<li>含义：进程控制块是进程实体的一部分，是操作系统中最重要的数据结构。<strong>记录</strong>了操作系统所需要的、用于<strong>描述进程</strong>及<strong>控制进程</strong>运行所需的<strong>全部信息</strong></li>\n<li>包含的信息\n<ol>\n<li>进程标识符信息：用于唯一标识一个进程</li>\n<li>处理机状态信息\n<ol>\n<li>通用寄存器</li>\n<li>指令计数器</li>\n<li>程序状态字 PSW</li>\n<li>用户栈指针</li>\n</ol>\n</li>\n<li>进程调度信息：包括进程状态信息、进程优先级和进程调度所需的其他信息</li>\n<li>进程控制信息：包括程序和数据的地址、进程同步和通信机制、资源清单、以及链接指针</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"214-进程的状态\"><a class=\"markdownIt-Anchor\" href=\"#214-进程的状态\">#</a> 2.1.4 进程的状态</h4>\n<ul>\n<li>就绪态</li>\n<li>执行态</li>\n<li>阻塞态</li>\n</ul>\n<h4 id=\"215-进程的组织\"><a class=\"markdownIt-Anchor\" href=\"#215-进程的组织\">#</a> 2.1.5 进程的组织</h4>\n<ol>\n<li>\n<p>链接方式</p>\n<ul>\n<li>把系统中具有<strong>相同状态</strong>的进程控制块 PCB 用其中的<strong>链接字</strong>连成一个对联</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081101.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081101.png\" class=\"\"></p>\n</li>\n<li>\n<p>索引方式</p>\n<ul>\n<li>系统根据所有进程的状态，建立索引表，索引表的每 - 一个表项指向一个 PCB 物理块</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081102.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081102.png\" class=\"\"></p>\n</li>\n<li>\n<p>进程队列</p>\n<ul>\n<li>把具有相同状态的进程控制块用队列组织起来</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081103.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081103.png\" class=\"\"></p>\n</li>\n</ol>\n<h3 id=\"22-进程的控制\"><a class=\"markdownIt-Anchor\" href=\"#22-进程的控制\">#</a> 2.2 进程的控制</h3>\n<h4 id=\"221-创建\"><a class=\"markdownIt-Anchor\" href=\"#221-创建\">#</a> 2.2.1 <strong>创建</strong></h4>\n<ul>\n<li>\n<p>什么情况下需要创建新进程呢？</p>\n<p>用户登录\t作业调度\t提供服务\t应用请求</p>\n</li>\n<li>\n<p>如何创建新进程？ /  创建新进程的步骤？</p>\n<ol>\n<li><strong>申请空白 PCB</strong></li>\n<li><strong>为新进程分配资源</strong></li>\n<li><strong>初始化进程控制块</strong></li>\n<li><strong>将新进程插入到就绪队列</strong></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"222-阻塞\"><a class=\"markdownIt-Anchor\" href=\"#222-阻塞\">#</a> 2.2.2 <strong>阻塞</strong></h4>\n<ul>\n<li>\n<p>什么情况下会进行进程的阻塞？</p>\n<p>请求系统服务\t启动某种操作\t新数据尚未达到\t无心工作可做</p>\n</li>\n<li>\n<p>完整进程阻塞的过程？</p>\n<ol>\n<li><strong>将进程的状态改为阻塞态</strong></li>\n<li><strong>将进程插入响应的阻塞队列</strong></li>\n<li><strong>转到进程调度程序，从就绪队列中选择进程为分配 CPU</strong></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"223-唤醒\"><a class=\"markdownIt-Anchor\" href=\"#223-唤醒\">#</a> 2.2.3 <strong>唤醒</strong></h4>\n<ul>\n<li>进程唤醒的过程？\n<ol>\n<li><strong>将进程从阻塞队列中移出</strong></li>\n<li><strong>将进程状态由阻塞状态改为就绪态</strong></li>\n<li><strong>将进程插入就绪队列</strong></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"224-终止\"><a class=\"markdownIt-Anchor\" href=\"#224-终止\">#</a> 2.2.4 <strong>终止</strong></h4>\n<ul>\n<li>完成进程终止的过程\n<ol>\n<li><strong>从进程 PCB 中读取进程状态</strong></li>\n<li><strong>若进程正在执行，则终止进程的执行</strong></li>\n<li><strong>释放资源</strong></li>\n<li><strong>将终止进程的 PCB 移出</strong></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"23-操作系统内核\"><a class=\"markdownIt-Anchor\" href=\"#23-操作系统内核\">#</a> 2.3 操作系统内核</h3>\n<p>​\t操作系统内核是计算机<strong>硬件的第一次扩充</strong>，与硬件关系密切</p>\n<h4 id=\"231-操作系统内核\"><a class=\"markdownIt-Anchor\" href=\"#231-操作系统内核\">#</a> 2.3.1 操作系统内核</h4>\n<ol>\n<li><strong>支撑功能</strong>：中断处理、始终管理、原语操作（原语操作也称原子操作，是一组在执行过程中不能被中断的操作。）</li>\n<li><strong>资源管理功能</strong>：进程管理、存储管理、设备管理</li>\n</ol>\n<h4 id=\"232-中断\"><a class=\"markdownIt-Anchor\" href=\"#232-中断\">#</a> 2.3.2 中断</h4>\n<ul>\n<li>\n<p>什么是中断 ？</p>\n<p>中断是<strong>改变</strong>处理器执行指令顺序的一种<strong>事件</strong>。出现中断时，计算机停止现在程序的运行，转向<strong>对这些中断事件的处理</strong>，处理结束后再<strong>返回到现行程序的间断处</strong></p>\n</li>\n<li>\n<p>为什么需要中断 ？</p>\n<p>引入中断机制后， <strong>CPU 可以与其他设备并行工作</strong>，能有效<strong>提高 CPU 的利用率</strong></p>\n</li>\n<li>\n<p>单重中断处理</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081104.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081104.png\" class=\"\"></p>\n</li>\n</ul>\n<h4 id=\"233-时钟管理\"><a class=\"markdownIt-Anchor\" href=\"#233-时钟管理\">#</a> 2.3.3 时钟管理</h4>\n<p>时钟是计算机系统的脉搏，计算机的很多活动都是由定时测量来驱动的</p>\n<ul>\n<li>\n<p>计算机系统中的时钟</p>\n<ol>\n<li>实时时钟 RTC（CMOS）</li>\n<li>OS 时钟</li>\n</ol>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081105.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081105.png\" class=\"\"></p>\n</li>\n<li>\n<p>时钟机制</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081106.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081106.png\" class=\"\"></p>\n</li>\n<li>\n<p>时钟程序功能</p>\n<ol>\n<li>维护日期和时间</li>\n<li>递减当前进程在一个时间片内的剩余执行时间，防止运行超时</li>\n<li>对 CPU 的使用情况记账</li>\n<li>递减报警计数器</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"234-系统调用\"><a class=\"markdownIt-Anchor\" href=\"#234-系统调用\">#</a> 2.3.4 系统调用</h4>\n<ul>\n<li>\n<p>什么是系统调用？</p>\n<p>系统调用是（一群）<strong>预先定义好的模块</strong>，提供<strong>一条管道</strong>让应用程序能由此到<strong>核心程序</strong>的服务。系统调用是<strong>系统程序</strong>与<strong>用户程序</strong>之间的<strong>接口</strong></p>\n</li>\n<li>\n<p>系统调用和一般函数调用的区别？</p>\n<p>区别 1: 系统调用运行在<strong>系统态</strong>，一般函数运行在<strong>用户态</strong></p>\n<p>区别 2:<strong> 执行过程不同</strong> (系统调用执行时，当前进程被中断)</p>\n<p>区别 3: 系统调用进行中断处理，多了<strong>系统开销</strong></p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081107.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081107.png\" class=\"\"></p>\n</li>\n<li>\n<p>系统调用的类型</p>\n<ol>\n<li><strong>进程控制类</strong>系统调用。创建、撤销进程；获得、改变进程属性。</li>\n<li><strong>文件操作类</strong>系统调用。创建、删除、打开、关闭和读 / 写文件。</li>\n<li><strong>设备管理类</strong>系统调用。请求、释放设备。</li>\n<li><strong>通信类</strong>系统调用。打开、关闭链接，交换信息。</li>\n<li><strong>信息维护类</strong>系统调用。返回系统当前日期、时间、版本号、用户数、空闲内存和磁盘空间大小等信息。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"24-进程同步\"><a class=\"markdownIt-Anchor\" href=\"#24-进程同步\">#</a> 2.4 进程同步</h3>\n<p>操作系统同步机制的<strong>主要任务</strong>就是要<strong>保证</strong>在多任务共享系统资源的情况下，<strong>程序执行能得到正确的结果</strong>。</p>\n<h4 id=\"241-进程同步的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#241-进程同步的基本概念\">#</a> 2.4.1 进程同步的基本概念</h4>\n<ol>\n<li>\n<p>两个任务</p>\n<ul>\n<li>一是<strong>对具有资源共享关系的进程</strong>，保证诸进程以<strong>互斥</strong>的方式<strong>访问临界资源</strong>。<strong>临界资源是必须以互斥方式访问的共享资源</strong>。</li>\n<li>二是对具有相互合作关系的进程，保证相互合作的诸进程协调执行。相互合作的进程可能同时存在资源共享的关系。</li>\n</ul>\n</li>\n<li>\n<p><strong>并发问题的解决</strong></p>\n<ul>\n<li>\n<p>如果 PIN 和 POUT<strong> 互斥</strong>地访问 count ，<strong>即 PIN 访问 count 时， POUT 就必须等待 PIN 对 count 的访问完全结束，再开始对 count 的访问</strong>，反之亦然。这样就不会出现计算结果的错误了。</p>\n<p>像 count 这样必须以<strong>互斥方式访问</strong>的<strong>共享资源</strong>称为<strong>临界资源</strong>。</p>\n</li>\n<li>\n<p>这里采用临界区<strong>加锁</strong>的方法，在临界区前加入<strong>进入区代码</strong>，在临界区之后加<strong>退出区代码</strong>来实现</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"242-同步机制应遵循的准则\"><a class=\"markdownIt-Anchor\" href=\"#242-同步机制应遵循的准则\">#</a> 2.4.2 同步机制应遵循的准则</h4>\n<p>同步机制应遵循的准则可以提供判断、选择和评价同步技术的参考依据。</p>\n<ol>\n<li>\n<p><strong>空闲让进</strong></p>\n<p><strong>当没有进程处于临界区时</strong>，表明临界资源处于空闲状态，应<strong>允许一个</strong>请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。</p>\n</li>\n<li>\n<p><strong>忙则等待</strong></p>\n<p>当己有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。</p>\n</li>\n<li>\n<p><strong>有限等待</strong></p>\n<p>对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免进程陷入无限等待的状态。</p>\n</li>\n<li>\n<p><strong>让权等待</strong></p>\n<p><strong>当进程申请不到共享资源的访问权时，应立即释放处理机</strong>，以兔进程陷入 “忙等” 状态，浪费 CPU 资源</p>\n</li>\n</ol>\n<h4 id=\"243-信号量机制\"><a class=\"markdownIt-Anchor\" href=\"#243-信号量机制\">#</a> 2.4.3 信号量机制</h4>\n<p>​\t在信号量机制中，用<strong>信号量的取值</strong>来表示资源的使用状况，或某种事件是否发生，以此为基础实现进程的同步。</p>\n<p>​\t对不同的共享资源设置被称为信号量的变量，<strong>用信号量的取值来表示资源的使用状况</strong>，或某种事件是否发生。</p>\n<p>​\t通过信号量的取值来判断进程是否能访问与信号量对应的共享资源。</p>\n<ol>\n<li>\n<p><strong>整形信号量机制</strong></p>\n<p><strong>如果整型量 &gt; 0，说明有可用资源；如果整型量≤0，说明资源忙，进程必须等待。</strong></p>\n<p>对于<strong>一次只允许一个进程访问</strong>的临界资源，可定义一个用于<strong>互斥</strong>的整型信号量，并将其<strong>初始化为 1</strong>。</p>\n<ol>\n<li>\n<p>具体操作</p>\n<p>整型信号量的值只能通过两个特定的原子操作 wait 和 signal 来改变</p>\n<p>wait 和 signal 操作</p>\n<pre><code class=\"language-伪代码\">wait(s) //用于申请资源\n&#123;\n    while s&lt;=0 do no-op;// s &lt;= 0时循环执行空操作\n    s=s-1;\n&#125;\n\nsignal(s) //用于释放资源\n&#123;\n    s=s+1;\n&#125;\n</code></pre>\n</li>\n<li>\n<p>总结</p>\n<ol>\n<li>整型信号量的值只能由 wait 和 siqnal 操作改变。</li>\n<li>wait 和 signal 操作都是<strong>原子操作</strong>，即这两个操作中对信号量的访问<strong>不能被中断</strong>。</li>\n<li>原子操作可以通过关中断来实现。</li>\n<li><strong>不同的资源对应不同的信号量，并不是系统中所有的资源都用同一个信号量表示</strong>。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>记录型信号量</strong></p>\n<ul>\n<li>优点：是不存在 “忙等” 采取了” 让权等待” 的策略</li>\n</ul>\n</li>\n<li>\n<p><strong>AND 型信号量机制</strong></p>\n<ol>\n<li>基本思想是将进程在整个运行过程中所需要的所有资源一次性地全部分配给进程，待该进程使用完后再一起释放。只要还有一个资源不能分配给该进程，其他所有可能为之分配的资源也不分配给它。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"244-经典的进程同步问题\"><a class=\"markdownIt-Anchor\" href=\"#244-经典的进程同步问题\">#</a> 2.4.4 经典的进程同步问题</h4>\n<ol>\n<li>\n<p>生产者一 消费者问题描述</p>\n<ul>\n<li>\n<p>问题描述</p>\n<ul>\n<li>生产者进程生产消息，并将消息提供给消费者进程消费。在生产者进程和消费者进程之间设置了一个具有 n 个缓冲区的缓冲池，生产者进程可以将它所产生的消息放入缓冲池的一个缓冲区中，消费者进程可以从一个缓冲区中取得一个消息消费。</li>\n<li>任意两个进程必须以互斥的方式访问公共缓冲池。当缓冲池空，没有可供消费的消息时，消费者进程必须阻塞等待。当缓冲池装满消息，没有空闲缓冲区时，生产者进程必须阻塞等待。</li>\n</ul>\n</li>\n<li>\n<p>需要解决的问题</p>\n<ul>\n<li>实现任意两个进程对缓冲池的互斥访问。</li>\n<li>实现对生产者进程和消费者进程的 “协调”</li>\n<li>即缓冲池中有消息时消费者进程才能执行取消息的操作。无消息时，阻塞消费者进程。缓冲池中有空闲缓冲区时，生产者进程才能执行放消息的操作。无空闲缓冲区时，阻塞生产者进程。</li>\n</ul>\n</li>\n<li>\n<p>信号量的设置</p>\n<ul>\n<li>设置一个互斥信号量 mulex ，用于实现对公共缓冲池的互斥访问，初值为 1。</li>\n<li>设置两个资源信号量，分别表示可用资源数。empty : 表示缓冲池中的空缓冲区数，初值为 n。full : 表示装有消息的缓冲区数，初值为 0 (一个缓冲区中放一个消息)。</li>\n</ul>\n</li>\n<li>\n<p>同步程序</p>\n<ul>\n<li>利用记录型信号量机制实现生产者 —— 消费者问题的同步代码如下:</li>\n</ul>\n</li>\n<li>\n<p>生产者进程同步代码</p>\n<pre><code class=\"language-伪代码\">Producer:\nbegin\nrepeat\n...\nproduce an item in nextp;\nwait(empty);//申请空缓冲区\nwait(mutex);//申请公共缓冲池的互斥访问权\nbuffer(in)=nextp; //将消息放入in指针指向的缓冲区\nin=(in+ 1) mod n; //in指针指向下一个空缓冲区\nsignal(mutex); //释放对公共缓冲池的互斥访问权\nsignal(full); //释放消息资源\nuntil false\nend\n</code></pre>\n</li>\n<li>\n<p>消费者进程同步代码</p>\n<pre><code class=\"language-伪代码\">Consumer:\nbegin \nrepeat\n...\nwait(ull); //申请消息\nwait(mutex); //申请公共缓冲池的互斥访问权\nnextc= buffer(out); //从out指针指向的缓冲区中取消息\nout=(out+ 1) mod h; //out指针指向下一个装有消息的缓冲区\nsignal(mutex); //释放对公共缓冲池的互斥访问权\nsignal(empty); //释放空缓冲区\nconsume item in nextc ;\nuntil false\nend\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"245-管程\"><a class=\"markdownIt-Anchor\" href=\"#245-管程\">#</a> 2.4.5 管程</h4>\n<ol>\n<li>\n<p>管程的定义</p>\n<p>管程是描述共享资源的数据结构和在数据结构上的共享资源管理程序的集合。其中包括变量的定义、变量的初始化代码，以及管理共享资源的过程。</p>\n</li>\n<li>\n<p>对管程的说明</p>\n<ul>\n<li><strong>管程是可供程序员调用的软件包</strong>，是一个由过程、变量及数据结构等组成的集合，它们组成一个特殊的模块或软件包。<strong>进程可以在任何需要的时候调用管程中的过程</strong>，但不能在管程外的过程中直接访问管程内的数据结构。</li>\n<li>每次只有一个进程调用管程执行，任意时刻管程中只能有一个活跃进程。</li>\n<li>管程是一种编程语言的构件</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"25-进程通信\"><a class=\"markdownIt-Anchor\" href=\"#25-进程通信\">#</a> 2.5 进程通信</h3>\n<p>​\t操作系统提供进程通信功能，以支持进程之间的信息交换。</p>\n<h4 id=\"251-共享存储器系统\"><a class=\"markdownIt-Anchor\" href=\"#251-共享存储器系统\">#</a> 2.5.1 共享存储器系统</h4>\n<p>​\t在共享存储器系统中，<strong>相互通信的进程共享某些数据结构或共享存储区</strong>，进程之间能够通过这些空间进行通信。共享存储器系统可分为两种类型。</p>\n<ol>\n<li>基于<strong>共享数据结构</strong>的通信方式。要求诸进程公用某些数据结构，以实现进程间的信息交换。</li>\n<li>基于<strong>共享存储区</strong>的通信方式。进程通过对共享存储区中的数据的读或写来实现通信。</li>\n</ol>\n<h4 id=\"252-消息传递系统\"><a class=\"markdownIt-Anchor\" href=\"#252-消息传递系统\">#</a> 2.5.2 消息传递系统</h4>\n<p>​\t进程间通过<strong>操作系统提供的一组通信程序</strong>传递格式化的信息。这种方式对应用程序隐藏了通信实现的细节使通信过程对用户是透明的。根据传递消息方式的不同，分为直接通信方式和间接通信方式。</p>\n<ol>\n<li><strong>直接通信方式</strong>。操作系统利用发送程序<strong>直接</strong>把消息发送给目标程序。</li>\n<li><strong>间接通信方式</strong>。进程之间的通信需要通过用于<strong>暂存</strong>消息的共享数据结构来实现，如信箱。该方式可以实现实时通信，又可以实现非实时通信。</li>\n</ol>\n<h4 id=\"253-管道\"><a class=\"markdownIt-Anchor\" href=\"#253-管道\">#</a> 2.5.3 管道</h4>\n<p>​\t<strong>管道</strong>是连接读写进程的<strong>一个特殊文件</strong>，也被称为管道文件。管道文件存在于<strong>外存</strong>中，其中的消息没有固定长度，能用于进程间大量的信息通信。向管道提供输入的发送进程以<strong>字符流</strong>的形式将大量的数据送入管道。接受管道输出的接收进程，从管道中接收数据。</p>\n<h4 id=\"254-消息缓冲队列\"><a class=\"markdownIt-Anchor\" href=\"#254-消息缓冲队列\">#</a> 2.5.4 消息缓冲队列</h4>\n<p>​\t用于本地进程之间的通信，包括<strong>数据结构、发送原语和接收原语</strong>。</p>\n<p>​\t发送进程<strong>发送消息</strong>时，先<strong>申请一个消息缓冲区</strong>，将要发送的消息<strong>从发送进程的发送区放入消息</strong></p>\n<p><strong>缓冲区</strong>。然后，<strong>调用发送原语</strong>将消息<strong>发送给接收进程</strong>，发送原语将发送缓冲区插入接收进程的消</p>\n<p>息缓冲队列。</p>\n<p>​\t接收消息的进程<strong>通过调用接收原语</strong>将该进程消息缓冲队列中的消息复制到自己的消息接收区。</p>\n<p>​\t消息缓冲区是一个结构型数据结构。</p>\n<p>​\t消息缓冲队列需要被当作<strong>临界资源</strong>，在发送原语和接收原语中<strong>对消息缓冲队列的访问</strong>需要<strong>进行互斥与同步</strong></p>\n<h3 id=\"26-线程\"><a class=\"markdownIt-Anchor\" href=\"#26-线程\">#</a> 2.6 线程</h3>\n<h4 id=\"261-线程的描述\"><a class=\"markdownIt-Anchor\" href=\"#261-线程的描述\">#</a> 2.6.1 线程的描述</h4>\n<p>​\t<strong>为了进一步提高程序的并发性 ，减少系统开销，在操作系统中引入了线程的概念</strong>。</p>\n<p>​\t引入线程作为独立调度和分派的单位，<strong>不独立拥有资源，而与其他线程共享同一进程的资源</strong>，减少了系统的时空开销。</p>\n<p>​\t<strong>线程的实质是把进程的任务划分成更小，具有独立功能的单位</strong>，以线程的形式来并发执行，以提高程序并发执行的程度。</p>\n<ol>\n<li>\n<p>线程的概念</p>\n<p><strong>线程是进程中的一个实体</strong>，是被系统独立调度和分派的基本单位。<strong>一个线程可以创建和撤销另一个线程。同一进程中的多个线程可以并发执行。</strong></p>\n</li>\n<li>\n<p>线程的分类</p>\n<p>用户级线程和内核级线程。</p>\n</li>\n<li>\n<p>线程的三种基本状态</p>\n<p>就绪、运行和阻塞。</p>\n<p>就绪态是线程一 - 旦获得 CPU 就可以投入运行的状态。</p>\n<p>运行态是线程获得 CPU 正在运行的状态。</p>\n<p>阻塞态是线程由于等待某个事件的发生而暂停执行的状态。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081108.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081108.png\" class=\"\"></p>\n</li>\n<li>\n<p>线程控制块（TCB）</p>\n<p>每个线程都由一个数据结构表示，包括它的<strong>基本状态、标识及记账信息</strong>，这个数据结构就是<strong>线程控制块</strong>。</p>\n<p>线程控制块记录了操作系统所需的，用于描述线程情况及控制线程运行所需的全部信息。</p>\n<p>线程控制块采用<strong>链接</strong>方式来组织，把<strong>同一进程中具有相同状态的 TCB 用指针链接成列</strong>。</p>\n</li>\n<li>\n<p>线程与进程的关系</p>\n<ol>\n<li><strong>资源和调度</strong>。<strong>线程是程序执行的基本单位，进程是拥有资源的基本单位。</strong></li>\n<li><strong>地址空间资源</strong>。<strong>不同进程的地址空间是相互独立的，而同一进程中的各线程共享同一地址空间。</strong></li>\n<li><strong>通信关系</strong>。进程之间的通信必须使用操作系统提供的进程间通信机制，而同一进程中的各线程间可以<strong>通过直接读或写全局变量</strong>来进行通信，甚至无需操作系统的参与。</li>\n<li><strong>并发性</strong>。多进程之间可以并发执行，多线程之间也可以并发执行，同 - 进程中的多个线程之间也可以并发执行。</li>\n<li><strong>系统开销</strong>。创建或撤销进程时，系统都要为之分配或回收资源，系统开销大。</li>\n<li><strong>本人说明：可以理解为线程是 java 的线程，进程是 windows 的一个软件</strong></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"262-线程的控制\"><a class=\"markdownIt-Anchor\" href=\"#262-线程的控制\">#</a> 2.6.2 线程的控制</h4>\n<p>​\t线程控制包括创建新线程、终止线程、线程调度和线程切换，以及线程由于等待某个事件的发生而被阻塞与该事件发生后线程被唤醒。</p>\n<p>​\t<strong>用户线程的创建通过调用线程库中的实用程序完成。</strong></p>\n<p>​\t<strong>内核线程的创建由内核完成。</strong></p>\n<p>​\t如果进程中一个用户线程被阻塞，则整个进程必须等待。</p>\n<p>​\t当被阻塞的线程所等待的事件发生时，则由有关进程唤醒原语<strong>将该线程所属的进程唤醒，然后由有关线程唤醒原语将该线程唤醒</strong></p>\n<p>​\t如果进程中的一个内核线程被阻塞，内核可以调度同一个进程中的另一个内核线程运行。</p>\n<p>​\t<strong>一个进程中的所有线程共享同一个地址空间</strong>和诸如打开的文件之类的其他资源。</p>\n<p>​\t<strong>一个线程对资源的任何修改都会影响同一个进程中其他线程的环境。</strong></p>\n<p>​\t<strong>同一进程中线程间共享内存和文件资源</strong>，各线程间可通过<strong>直接读写全局变量</strong>进行通信。</p>\n<p>​\t对于<strong>不同进程的线程间</strong>通信，则必须<strong>使用操作系统提供的线程间</strong>通信机制。</p>\n<hr>\n<h2 id=\"第三章进程调度与死锁重点\"><a class=\"markdownIt-Anchor\" href=\"#第三章进程调度与死锁重点\">#</a> 第三章：进程调度与死锁（重点）</h2>\n<h3 id=\"本章考试重点\"><a class=\"markdownIt-Anchor\" href=\"#本章考试重点\">#</a> 本章考试重点</h3>\n<ul>\n<li>进程调度\n<ul>\n<li>进程调度算法（选择、填空、简答、综合)</li>\n<li>实时系统中的调度概念及算法 (选择、填空、简答、综合)</li>\n<li>进程切换 (选择、填空、简答)</li>\n<li>多处理器调度 (选择、填空、简答)</li>\n</ul>\n</li>\n<li>死锁\n<ul>\n<li>死锁产生的原因、必要条件 (选择、填空、简答</li>\n<li>死锁的预防和避免 (选择、填空、简答)</li>\n<li>银行家算法 (选择、填空、简答、综合)</li>\n<li>死锁的检测和解除 (选择、填空、简答)</li>\n</ul>\n</li>\n<li>近三年分值分布: 21~ 26 分</li>\n</ul>\n<h3 id=\"31-进程调度的功能与时机\"><a class=\"markdownIt-Anchor\" href=\"#31-进程调度的功能与时机\">#</a> 3.1 进程调度的功能与时机</h3>\n<ol>\n<li>\n<p>功能</p>\n<p><strong>进程调度功能</strong>由操作系统内核的<strong>进程调度程序完成</strong>。</p>\n<p>进程调度的功能是<strong>按照某种策略和算法</strong>从<strong>就绪态</strong>进程中为<strong>当前空闲的 CPU</strong> 选择在其上运行的新进程。</p>\n</li>\n<li>\n<p>时机</p>\n<p>当一个进程运行结束、进程阻塞、中断返回、在支持抢占式调度的系统中<strong>有比当前运行进程优先级更高的进程到来</strong>、当前运行进程的<strong>时间片用完</strong>，系统都会通过<strong>执行进程调度程序</strong>重新进行进程调度。（优先级高、当前时间片用完）</p>\n</li>\n</ol>\n<h3 id=\"32-进程调度算法综合题\"><a class=\"markdownIt-Anchor\" href=\"#32-进程调度算法综合题\">#</a> 3.2 进程调度算法（综合题）</h3>\n<p>进程调度算法是指从<strong>就绪态</strong>进程中选择一个进程为其分配 CPU ，<strong>使其进入执行态</strong>的算法。也就是说进程调度算法要 **“决定” 把 CPU 分配给就绪队列中的哪个进程 **。</p>\n<p>进程调度由操作系统内核中的进程调度程序完成。</p>\n<h4 id=\"321-选择调度方式和算法的若干准则\"><a class=\"markdownIt-Anchor\" href=\"#321-选择调度方式和算法的若干准则\">#</a> 3.2.1 选择调度方式和算法的<strong>若干准则</strong></h4>\n<ol>\n<li>\n<p><strong>周转时间短</strong></p>\n<p><strong>周转时间</strong>是指从<strong>作业被提交给系统开始，到作业完成为止</strong>的这段时间间隔。</p>\n<p>包括<strong> 4 部分</strong>时间：</p>\n<p>➢作业在<strong>外存后备队列上等待调度的时间</strong>，</p>\n<p>➢进程在<strong>就绪队列上等待进程调度的时间</strong>，</p>\n<p>➢进程在<strong> CPU 上执行的时间</strong>，</p>\n<p>➢进程等待<strong> I/O 操作完成的时间</strong>。</p>\n<ul>\n<li>\n<p>如果系统中<strong>有 n 个作业</strong>，系统的<strong>平均周转时间</strong>等于 n 个作业的周转时间<strong>之和除以 n</strong>。</p>\n<p>作业的周转时间 T 与系统为它提供的服务时间 Ts 之比为 W， W 称为<strong>带权周转时间</strong>。</p>\n<p>服务时间<strong> Ts 是一个作业在 CPU 上执行的总时间</strong>。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>响应时间快</strong></p>\n<p>响应时间是指<strong>用户提交一个请求开始</strong>至<strong>系统首次产生响应</strong>的时间为止的一段时间。</p>\n<p>它包括<strong> 3 部分</strong>时间：从<strong>输入设备信息传送到处理机</strong>的时间、<strong>处理机对请求信息进行处理</strong>的时间，以及<strong>将所形成的响应信息回送到终端显示器</strong>的时间。</p>\n<p><strong>对于交互式系统，响应时间是衡量系统时间性能的重要指标。</strong></p>\n</li>\n<li>\n<p><strong>截止时间的保证</strong></p>\n<p>截止时间是指某个任务<strong>必须开始的最迟时间或必须完成的最迟时间</strong>。是评价实时系统性能的重要指标。</p>\n</li>\n<li>\n<p><strong>系统吞吐量高</strong></p>\n<p><strong>吞吐量</strong>是指<strong>单位时间内完成的作业数</strong>。是评价系统性能的重要指标之一。</p>\n</li>\n<li>\n<p>处理机利用率好</p>\n<p>CPU 是计算机系统中影响时间性能的最重要的硬件资源，在多任务系统中，进程调度算法对 CPU 的利用率有很大影响。因此，在<strong>选择和设计进程调度算法时应该考虑使 CPU 的利用率尽可能高</strong>。</p>\n</li>\n</ol>\n<h4 id=\"322-先来先服务调度算法fcfs\"><a class=\"markdownIt-Anchor\" href=\"#322-先来先服务调度算法fcfs\">#</a> 3.2.2 先来先服务调度算法 (<strong>FCFS</strong> )</h4>\n<ol>\n<li>\n<p>调度算法</p>\n<p>在进程调度中，FCFS 就是从就绪队列的队首选择最先到达就绪队列的进程，为该进程分配 CPU。（First-Come ， First- Served）</p>\n</li>\n<li>\n<p>性能分析</p>\n<p>FCFS<strong> 适合长进程</strong>，有利于 CPU 繁忙的进程。</p>\n</li>\n<li>\n<p>综合题</p>\n<pre><code>有3个进程p1、p2和p3 ，分别在0、1、 2时刻进入系统，需要的运行(服务)时间长度分别为24、3、3 .，按照FCFS调度算法， 3个进程的等待时间和周转时间分别是?\n\n[答案]\n等待时间=开始时间-进入时间，周转时间=运行时间+等待时间。\n注意：开始运行时间从0开始计算\n</code></pre>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">进程名</th>\n<th style=\"text-align:center\">进入系统时间</th>\n<th style=\"text-align:center\">开始运行</th>\n<th style=\"text-align:center\">运行时间</th>\n<th style=\"text-align:center\">等待时间</th>\n<th style=\"text-align:center\">周转时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">p1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">24</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">p2</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">26</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">p3</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">28</td>\n</tr>\n</tbody>\n</table>\n<pre><code>此种情况下平均周转时间T和平均带权周转时间W为多少?\n\n[答案] T=(24+26+ 28)/3=26\n\t  W=(24/24+ 26/3+ 28/3)/3-6.33\n\n[解析]\n\t等待时间=开始时间-进入时间\n\t周转时间=运行时间+等待时间\n\t系统的平均周转时间:各个进程的周转时间总和/进程数\n\t带权周转时间:周转时间/运行时间\n\t平均带权周转时间:各个进程的带权周转时间总和/进程数\n</code></pre>\n</li>\n</ol>\n<h4 id=\"323-短进程优先调度算法-shortest-process-firstspf\"><a class=\"markdownIt-Anchor\" href=\"#323-短进程优先调度算法-shortest-process-firstspf\">#</a> 3.2.3 短进程优先调度算法 (Shortest-Process-First，SPF)</h4>\n<ul>\n<li>算法的缺陷\n<ol>\n<li><strong>对长进程不利</strong>。如果系统中不断有短进程到来长进程<strong>可能长时间得不到调度</strong>。</li>\n<li><strong>不能保证紧迫进程的及时处理</strong>，因<strong>本算法不考虑进程的紧迫程度</strong>。</li>\n<li><strong>进程的长度由用户估计而定，可能有偏差</strong>。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"324-优先权调度算法\"><a class=\"markdownIt-Anchor\" href=\"#324-优先权调度算法\">#</a> 3.2.4 优先权调度算法</h4>\n<ol>\n<li>\n<p>调度算法</p>\n<p>​\t在使用优先权调度的系统中， 每个进程都有一个与之关联的优先权。</p>\n<p>​\t当使用优先权调度算法进行进程调度时，系统将 CPU 分配给就绪队列中<strong>优先权值最高</strong>的进程。</p>\n</li>\n<li>\n<p>优先权调度算法的分类</p>\n<p>① 非抢占式优先权调度算法高优先权进程一旦得到处理机， 便一直运行下去直到完成或由于某事件使该进程主动放弃处理机。</p>\n<p>​\t即使更高优先权进程到来，也不能剥夺当前进程的 CPU 使用权，只能在就绪队列中等待。</p>\n<p>② 抢占式优先权调度算法</p>\n<p>​\t新到达的就绪进程与正在运行进程的优先权相比较，若<strong>新到达进程的优先权高于当前正在运行进程的优先权</strong>，则<strong>系统会抢占 CPU</strong> ，分配给新到达的进程，正在执行的进程暂停执行。</p>\n</li>\n<li>\n<p>优先权的类型</p>\n<p>根据优先权的变化特点将优先权的类型分为<strong>静态和动态</strong>。</p>\n<p>① <strong>静态优先权</strong>。在创建时确定，在进程的整个运行期间不变。</p>\n<p>② <strong>动态优先权</strong>。进程创建时被赋予的优先权，随进程的推进或随其等待时间的增加而改变。<strong>动态优先权调度算法可以使系统获得更好的调度性能</strong>。</p>\n</li>\n<li>\n<p>优先权调度算法存在的问题和解决方案</p>\n<p>① 问题。无穷阻塞或称饥饿问题。指就绪态进程因得不到 CPU 而等待的状态。优先权调度算法可能使某个低优先权进程无穷等待。</p>\n<p>② 解决方案。<strong>老化 (Aging) 技术。逐渐增加在系统中等待时间很长进程的优先权。</strong></p>\n</li>\n</ol>\n<h4 id=\"325时间片轮转调度算法\"><a class=\"markdownIt-Anchor\" href=\"#325时间片轮转调度算法\">#</a> 3.2.5 时间片轮转调度算法</h4>\n<p>​\t时间片轮转调度算法在现代分时系统中广泛使用， UNIX、Linux、 Windows 操作 系统都采用基于时间片轮转、支持优先权和抢占式调度的混合式进程调度算法。</p>\n<ol>\n<li>\n<p>时间片轮转调度算法</p>\n<p>时间片是一个较小的时间单位，通常为 10~ 100ms。每当进程在 CPU_上连续运行的时间等于一一个时间片长度时，操作系统在时钟中断处理过程中会抢占 CPU，进行进程切换，用新的就绪进程替代当前进程，<strong>被替换的当前进程重新回到就绪队列中</strong>。</p>\n</li>\n<li>\n<p>时间片大小的确定</p>\n<p><strong>时间片太长</strong>，可降低进程的周转时间，但可能造成交互用户的响应时间过长。</p>\n<p><strong>时间片太短</strong>，会增加进程切换和调度的开销，系统的平均周转时间也较长。</p>\n<p>① <strong>系统对响应时间的要求</strong>。响应时间越短，时间片取值应该越小。</p>\n<p>设系统响应时间为 T ，进程数目为 N，时间片为 q ，则有 T=Nq ，即在 N - 定的情况下， T 的大小取决于 q。</p>\n<p>② <strong>就绪队列中进程的数目</strong>。进程越多，响应时间越长。当设定了系统的最长响应时间值后，时间片的大小就与系统允许的最大进程数成反比。</p>\n<p>③ <strong>系统的处理能力</strong>。必须保证系统支持的基本命令能在一个时间片内执行完。</p>\n</li>\n<li>\n<p>时间片轮转调度算法的性能评价</p>\n<p>时间片轮转调度算法的性能<strong>依赖于时间片的大小</strong>。</p>\n<p>时间片很大，与先来先服务算法一样。</p>\n<p>时间片很小，会增加 CPU 用于进程切换和进程调度的开销。</p>\n</li>\n</ol>\n<h4 id=\"326-多级队列调度\"><a class=\"markdownIt-Anchor\" href=\"#326-多级队列调度\">#</a> 3.2.6 多级队列调度</h4>\n<p>​\t通常根据<strong>不同进程对响应时间要求的不同</strong>，采用<strong>多级队列调度算法</strong></p>\n<p>​\t多级队列调度算法，根据<strong>进程占用内存的大小、优先权或进程类型</strong>，将就绪队列分成多个独立队列，<strong>进程被永久地分配到一个队列，每个队列有自己的调度算法</strong>。<strong>降低了进程调度的开销</strong></p>\n<h4 id=\"327多级反馈队列调度\"><a class=\"markdownIt-Anchor\" href=\"#327多级反馈队列调度\">#</a> 3.2.7 多级反馈队列调度</h4>\n<p>​\t采用多级队列调度，对低优先权进程会存在无穷阻塞 (饥饿) 的问题。</p>\n<p>​\t多级反馈队列调度算法可以弥补这些不足。在采用多级反馈队列调度的系统中建立多个优先权不同的就绪队列，为每个队列赋予大小不同的时间片。</p>\n<p>​\t有一种<strong>反馈策略规定</strong>：队列优先权越高，时间片越短。新进程被创建后，先插入预先权最高的队列。仅当高优先权队列空时，才调度优先权次之的队列。同一队列中， 采用时间片轮转调度算法。使用 CPU 时间过多的进程会被移到优先权较低的队列中，在较低优先权队列中等待时间过长的进程会被移到较高优先权队列中。</p>\n<p>​\t多级反馈队列调度算法的设计要考虑以下几个方面的问题。</p>\n<ol>\n<li>就绪队列的数量。</li>\n<li>根据进程优先权确定进程应该进入哪个就绪队列的算法。</li>\n<li>用以确定进程何时转移到较高优先权队列的算法。</li>\n<li>用以确定进程何时转移到较低优先权队列的算法。</li>\n<li>用以确定进程在需要服务时应该进入哪个队列的算法。</li>\n</ol>\n<h3 id=\"33-实时系统中的调度\"><a class=\"markdownIt-Anchor\" href=\"#33-实时系统中的调度\">#</a> 3.3 实时系统中的调度</h3>\n<h4 id=\"331-实现实时调度的基本条件\"><a class=\"markdownIt-Anchor\" href=\"#331-实现实时调度的基本条件\">#</a> 3.3.1 实现实时调度的基本条件</h4>\n<p>​\t为了满足实时系统对截止时间的要求，实现实时调度应具备下列几个条件:</p>\n<ol>\n<li>\n<p><strong>提供必要的调度信息</strong><br>\n① 就绪时间<br>\n② 开始截止时间和完成截止时间<br>\n③ 处理时间<br>\n④ 资源要求<br>\n⑤优先级</p>\n</li>\n<li>\n<p><strong>系统处理能力强</strong></p>\n<p>（具体没啥用，随便看看）</p>\n<p>​\t在实时系统中，通常有多个实时进程，若处理机的处理能力不够强，处理速度不够快，若使某些实时进程不能得到及时处理，可能发生难以预料的后果。</p>\n<p>​\t可通过提高处理机的处理能力或增加处理机的数量以提高系统的处理能力。</p>\n</li>\n<li>\n<p><strong>采用抢占式调度机制</strong></p>\n<ol>\n<li><strong>基于时钟中断的抢占式优先权调度算法</strong><br>\n若高优先权大于正在执行的进程，就等当前进程到时钟中断的时候抢占</li>\n<li><strong>立即抢占的优先权调度算法</strong><br>\n一旦接收到就给当前执行的进程一个中断信号，然后抢占</li>\n</ol>\n</li>\n<li>\n<p>具有快速切换机制<br>\n就是需要进程<strong>对外部中断做出快速响应</strong>和<strong>快速的进程切换</strong></p>\n</li>\n</ol>\n<h4 id=\"332-常用的实时调度算法\"><a class=\"markdownIt-Anchor\" href=\"#332-常用的实时调度算法\">#</a> 3.3.2 常用的实时调度算法</h4>\n<ol>\n<li>\n<p>最早截止时间优先 EDF 算法</p>\n<p>根据进程的开始截止时间确定进程的优先级，<strong>截止时间越早，进程的优先级越高</strong>，越优先获得处理机。</p>\n</li>\n<li>\n<p>最低松弛度优先 LLF 算法</p>\n<p>​\t<strong>松弛度用来表示个实时进程的紧迫程度</strong>。</p>\n<p>​\t如果一个进程的完成截止时间为 T ，当前时间为 Tc 处理完该任务还需要的时间为 Ts，则松弛度 L 的计算式表示为: L=T-Tc-Ts</p>\n<p>​\t<strong>调度时，每次选择松弛度最小的进程</strong>。该算法按松弛度排序，<strong>让松弛度最小的进程排在就绪队列队首</strong>。</p>\n</li>\n</ol>\n<h3 id=\"34-进程切换\"><a class=\"markdownIt-Anchor\" href=\"#34-进程切换\">#</a> 3.4 进程切换</h3>\n<p>​\t含义：<strong>用新选择的进程替换原来的进行进程</strong></p>\n<ul>\n<li>进程切换包括的步骤如下:\n<ol>\n<li><strong>保存 CPU 上下文环境。</strong></li>\n<li><strong>更新进程控制块。</strong></li>\n<li><strong>修改进程状态，把执行态改为就绪态或者阻塞态。</strong></li>\n<li><strong>将被替换进程的进程控制块移到就绪队列或阻塞队列。</strong></li>\n<li><strong>执行新进程，并更新改进程的进程控制块。</strong></li>\n<li><strong>更新内存管理的数据结构。</strong></li>\n<li><strong>恢复上下文。</strong></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"35-多处理器调度\"><a class=\"markdownIt-Anchor\" href=\"#35-多处理器调度\">#</a> 3.5 多处理器调度</h3>\n<h4 id=\"351-多处理器系统的类型\"><a class=\"markdownIt-Anchor\" href=\"#351-多处理器系统的类型\">#</a> 3.5.1 多处理器系统的类型</h4>\n<p>根据处理器的耦合程度，分为紧密耦合和松弛耦合；根据处理器的结构，分为对称和非对称。</p>\n<ol>\n<li>\n<p>紧密耦合和松弛耦合</p>\n<ol>\n<li>紧密耦合</li>\n<li>松弛耦合</li>\n</ol>\n</li>\n<li>\n<p>对称和非对称</p>\n<p>对称属于同构，非对称在功能和结构上各不相同。</p>\n</li>\n</ol>\n<h4 id=\"352-多处理器系统中的进程分配方式\"><a class=\"markdownIt-Anchor\" href=\"#352-多处理器系统中的进程分配方式\">#</a> 3.5.2 多处理器系统中的进程分配方式</h4>\n<ol>\n<li>\n<p>对称多处理器系统中的进程分配方式</p>\n<ol>\n<li>\n<p>静态分配</p>\n<p>操作系统为每个处理器建立 - 个专门的就绪队列</p>\n</li>\n<li>\n<p>动态分配</p>\n<p>每个进程经过多次调度，每次获得的不一定是同一个处理器。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>非对称多处理器系统 (MPS) 中的进程分配方式</p>\n<p>采<strong>用主一从式</strong>操作系统，操作系统的核心部分驻留在一台主机上，而从机上只运行用户程序，只有主机 执行调度程序，所有从机的进程都是由主机分配的。</p>\n</li>\n</ol>\n<h4 id=\"353-进程线程调度方式\"><a class=\"markdownIt-Anchor\" href=\"#353-进程线程调度方式\">#</a> 3.5.3 进程（线程）调度方式</h4>\n<ol>\n<li>\n<p>自调度</p>\n<p>采用自调度的系统中设置<strong>有个公共的就绪队列，任何一个空闲的处理器都可以自行从该就绪队列中选取一个进程或者一个线程运行</strong>。</p>\n<ul>\n<li>\n<p>优点</p>\n<p>➢ 易移植</p>\n<p>➢ 有利于提高 CPU 的利用率</p>\n</li>\n<li>\n<p>缺点</p>\n<p>➢ 瓶颈问题，容易产生并发问题</p>\n<p>➢ 低效性，高速缓冲的命中率较低</p>\n<p>➢ 线程切换频繁</p>\n</li>\n</ul>\n</li>\n<li>\n<p>成组调度</p>\n<p>系统<strong>将一组相互合作的进程或线程同时分配到一组处理器上运行，进程或线程与处理器对应</strong>。</p>\n<ul>\n<li>优点:<br>\n➢ 减少线程切换，改善系统性能。<br>\n➢ 减少调度开销。一次调度一组，减少调度频率。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"36-死锁\"><a class=\"markdownIt-Anchor\" href=\"#36-死锁\">#</a> 3.6 死锁</h3>\n<h4 id=\"361-产生死锁的原因和必要条件\"><a class=\"markdownIt-Anchor\" href=\"#361-产生死锁的原因和必要条件\">#</a> 3.6.1 产生死锁的原因和必要条件</h4>\n<p>​\t<strong>当多个进程可能竞争数量有限的资源。若一个进程所申请的资源被其他处于阻塞状态的进程占有，该进程就会因为不能获得所申请的资源而被阻塞。</strong></p>\n<p>​\t这种由于多个进程竞争共享资源而引起的<strong>进程不能向前推进的僵持状态</strong>称为<strong>死锁</strong>。</p>\n<p><strong>产生死锁的原因</strong>：竞争共享资源且分配资源的顺序不当。</p>\n<p>产生死锁的必要条件：</p>\n<ol>\n<li>\n<p><strong>互斥条件</strong></p>\n<p>指一个进程在访问资源的过程中，其他进程不能访问该资源</p>\n</li>\n<li>\n<p><strong>请求和保持条件</strong></p>\n<p>进程已经保持了至少一个资源，又提出了新的资源要求且已经被其他进程占有，此时进程阻塞，但又对已经获得的资源保持不放，使得其他进程无法使用被保持的资源。</p>\n</li>\n<li>\n<p><strong>不剥夺条件</strong></p>\n<p>进程已经获得的资源不能被剥夺，只能由进程自己释放。</p>\n</li>\n<li>\n<p><strong>环路等待条件</strong></p>\n<p>在发生死锁时，必然存在一个进程申请资源的环形链。</p>\n<p>注意：只有上述 4 个条件同时满足时才会发生死锁。</p>\n</li>\n</ol>\n<h4 id=\"362-处理死锁的基本方法\"><a class=\"markdownIt-Anchor\" href=\"#362-处理死锁的基本方法\">#</a> 3.6.2 处理死锁的基本方法</h4>\n<p>处理死锁的基本方法有<strong>预防死锁、避免死锁、检测并解除死锁和忽略死锁</strong>问题。</p>\n<ol>\n<li>\n<p>死锁的预防</p>\n<p>通过保证至少其中一个条件不成立来达到预防发生死锁的目的。</p>\n<ol>\n<li>\n<p><strong>摒弃请求和保持条件</strong><br>\n所有进程执行前要一次性地申请在整个运行过程中所需要的全部资源</p>\n</li>\n<li>\n<p><strong>摒弃不剥夺条件</strong></p>\n<p>一个已保持了某些资源的进程，当它再提出新的资源要求而不能立即得到满足时，必须释放它已经保持的所有资源。</p>\n</li>\n<li>\n<p><strong>摒弃环路等待条件</strong></p>\n<p>进程必须按规定的顺序申请资源</p>\n</li>\n</ol>\n</li>\n<li>\n<p>死锁的避免</p>\n<p>​\t<strong>避免死锁的方法是把系统的资源分配状态分为安全状态和不安全状态</strong>，只要资源分配使系统资源分配状态处于安全状态，死锁就不会发生。</p>\n<p>​\t在避免死锁的方法中，允许进程动态地电请资源。</p>\n</li>\n</ol>\n<h4 id=\"363-银行家算法\"><a class=\"markdownIt-Anchor\" href=\"#363-银行家算法\">#</a> 3.6.3 银行家算法</h4>\n<p>​\t1965 年 Dijkstra (迪杰斯特拉) 提出了种能够避免死锁的资源分配算法。</p>\n<p>​\t其基本思想是<strong>一个进程提出资源请求后，系统先进行资源的试分配。然后检测本次的试分配是否使系统处于安全状态，若安全则按试分配方案分配资源，否则不分配资源</strong>。</p>\n<pre><code>\t银行家算法的由来是银行家贷款给客户这一问题。银行家(操作系统)把一定数量的资金(资源)供多个用户(进程)周转使用。当顾客对资金的最大申请量不超过银行家现金时就可接纳一个新顾客。银行可以对顾客的借款推迟支付，但一定使顾客总能在有限的时间内得到借款;当顾客得到全部资金后，他一定能在有限的时间里归还(回收)所有资金(资源)。\n</code></pre>\n<p>银行家算法分为两个过程:<br>\n 一是进行资源试分配的过程；<br>\n 二是对试分配后系统的状态做安全性检测的过程。</p>\n<h4 id=\"364-死锁的检测和解除\"><a class=\"markdownIt-Anchor\" href=\"#364-死锁的检测和解除\">#</a> 3.6.4 死锁的检测和解除</h4>\n<p>何时调用检测算法？</p>\n<p>​\t➢ 死锁可能发生的频率</p>\n<p>​\t➢ 当死锁发生时受影响的进程数量</p>\n<p>死锁定理</p>\n<p>​\t➢ 死锁状态的充分条件是当且仅当资源分配状态是不可完全简化的。</p>\n<p>死锁的解除</p>\n<p>​\t➢ 终止处于死锁状态的进程</p>\n<p>​\t➢ 抢占死锁进程占有的资源</p>\n<p>单选题</p>\n<pre><code>某系统中有n (n为大于1的整数)个并发进程，每个进程需要同类资源m个(m为大于0的整数), 请问该系统不会发生死锁的最少资源数是( C )。\n\nA. n+m\nB.n*m\nC.n*(m-1)+1\nD.以上都对\n\n[解析]\n例如,若某系统中有4个并发进程,每个进程需要同类资源3个,则只要分配4*(3-1)+ 1共9个资源,该系统就不会发生死锁。每个进程都申请到两个资源后,还有1个资源,无论哪个进程获得这个资源都可以继续向前推进,当获得这个资源的进程执行完后,可以释放3个资源再分配给其他3个进程,因此不会发生死锁。\n</code></pre>\n<hr>\n<h2 id=\"第四章内存管理重点\"><a class=\"markdownIt-Anchor\" href=\"#第四章内存管理重点\">#</a> 第四章：内存管理（重点）</h2>\n<h3 id=\"考试重点\"><a class=\"markdownIt-Anchor\" href=\"#考试重点\">#</a> 考试重点</h3>\n<p>​\t➢ 存储器的层次结构 (选择、填空、简答)</p>\n<p>​\t➢ 程序的链接和装入 (选择、填空、简答)</p>\n<p>​\t➢ 连续分配存储管理、动态分区分配算法 (选择、填空、简答、综合)</p>\n<p>​\t➢ 分页、快表、两级页表 (选择、填空、简答、综合)</p>\n<p>​\t➢ 虚拟存储、缺页、页分配策略 (选择、填空、简答)</p>\n<p>​\t➢ 页置换算法 (选择、填空、简答、综合)</p>\n<p>​\t➢ 分段系统、段表、段页式存储管理 (选择、填空、简答)</p>\n<p><strong>本章近 3 年分值: 19~22 分</strong></p>\n<h3 id=\"41-存储器的层次结构\"><a class=\"markdownIt-Anchor\" href=\"#41-存储器的层次结构\">#</a> 4.1 存储器的层次结构</h3>\n<p>​\t内存是计算机存储系统的一部分，为了更好地理解后续章节内容，先了解存储器系统的层次结构。存储器系统是一个具有不同容量、成本和访问时间的存储设备的层次结构。</p>\n<p>在这个层次系统中，从高层到底层 (L0~L5)，较低层的存储设备速度更慢、容量更大、价格更便宜。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081201.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081201.png\" class=\"\"></p>\n<p>如果存储在高速缓存中，需要 1~ 10 个周期。</p>\n<p>如果存放在主存中，访问它们需要 50~ 100 个周期。</p>\n<p>如果存放在磁盘中，访问它们需要大约 2000 万个周期。</p>\n<p>​\t➢ 程序的执行遵循<strong>局部性</strong>原理。</p>\n<p>​\t程序在执行时呈现出局部性规律，即在一段较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域。</p>\n<ol>\n<li>程序执行时，除了少部分的转移和过程调用指令，<strong> 大多数情况下是顺序执行</strong></li>\n<li><strong>过程调用</strong>将会使程序的执行轨迹由一部分内存区域转移到另一部分内存区域</li>\n<li>程序中存在很多<strong>循环</strong>结构，它们虽然由少数指令构成但<strong>多次执行</strong></li>\n<li>程序中往往包括许多对数据结构的处理，如对数组操作，它们往往<strong>局限在很小的范围内</strong></li>\n</ol>\n<p>➢ 总的来说，<strong> 局部性</strong>原理<strong>表现为时间和空间的局部性</strong><br>\n➢ 时间局部性。如果程序中的某条指令一旦执行则不久后该指令可能再次执行。<br>\n➢ 空间局部性。一旦程序访问了某个单元，不久后其附近的存储单元也将被访问</p>\n<h3 id=\"42-程序的链接和装入\"><a class=\"markdownIt-Anchor\" href=\"#42-程序的链接和装入\">#</a> 4.2 程序的链接和装入</h3>\n<p>高级语言程序必须经过编译、链接才能成为可执行程序。操作系统需要为程序的执行分配内存空间。下面介绍链接程序的功能和程序被装入内存的几种方式。</p>\n<h4 id=\"421-程序的链接\"><a class=\"markdownIt-Anchor\" href=\"#421-程序的链接\">#</a> 4.2.1 程序的链接</h4>\n<p><strong>链接程序</strong>要解决的问题是<strong>将编译后的目标模块装配成一个可执行的程序</strong>。根据链接进行的时间和实现方式的不同，可以把链接分为静态链接和动态链接。<br>\n➢ <strong>静态链接</strong></p>\n<p>​\t在程序运行前，用链接程序将目标模块链接成一个完整的装入模块。运行速度快，占用大</p>\n<p>➢ <strong>动态链接</strong></p>\n<p>​\t将部分目标模块链接推迟到其中函数被调用执行。采用动态链接节省空间，方便开发，速度慢</p>\n<h4 id=\"422-程序的装入\"><a class=\"markdownIt-Anchor\" href=\"#422-程序的装入\">#</a> 4.2.2 程序的装入</h4>\n<p>​\t将源程序变为可执行程序须经过<strong>编译、链接和装入</strong> 3 个阶段。</p>\n<p>​\t可执行程序以<strong>二进制可执行文件</strong>的形式存储在磁盘上，为执行程序，操作系统需要把程序调入内存。程序装入内存的方式分为<strong>绝对装入、可重定位装入 (静态重定位) 和动态运行时装入</strong></p>\n<ol>\n<li>\n<p><strong>绝对装入方式</strong></p>\n<p>编译程序事先已知程序在内存中的驻留位置，编译时产生物理地址的目标代码。因此装入模块被装入内存后，无需对程序和数据的地址进行修改。</p>\n</li>\n<li>\n<p><strong>可重定位装入方式</strong> (静态重定位)</p>\n<p>​\t如果<strong>编译时不知道</strong>目标程序将驻留在内存的什么位置，则编译时就必须生成可重定位的代码，其中的地址都是<strong>逻辑地址</strong>（相对地址）, 在程序被装入内存时，再把这些逻辑地址映射为物理地址</p>\n<p>​\t在程序装入时对目标程序中的指令和数据地址的修改过程称为<strong>重定位</strong>。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081202.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081202.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>动态运行时装入</strong> (动态重定位)</p>\n<p>​\t一个进程在被换出之前所在的内存位置与后来被从外存重新调入时内存位置不同，这种装入方式称为<strong>动态运行时装入</strong>。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081203.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081203.png\" class=\"\"></p>\n</li>\n</ol>\n<h3 id=\"43-连续分配存储管理方式\"><a class=\"markdownIt-Anchor\" href=\"#43-连续分配存储管理方式\">#</a> 4.3 连续分配存储管理方式</h3>\n<p>连续分配是指操作系统分配内存时，为每个进程分配块物理地址连续的内存空间，连续分配方式有 3 种类型。</p>\n<p>➢ 单一连续区分配方式<br>\n➢ 固定分区分配方式<br>\n➢ 动态分区分配方式</p>\n<h4 id=\"431-单一连续区分配方式\"><a class=\"markdownIt-Anchor\" href=\"#431-单一连续区分配方式\">#</a> 4.3.1 单一连续区分配方式</h4>\n<p>​\t适用于单用户、单任务的操作系统，把内存分为<strong>系统区和用户区</strong>。系统区用于驻留操作系统，用户区用于分配给用户进程使用。</p>\n<p>​\t在单用户、单任务操作系统中较常用的方法是设置<strong>一个基址寄存器和一个界限寄存器</strong>。</p>\n<p>​\t<strong>基址寄存器</strong>中<strong>存放程序在物理内存中的最小地址</strong></p>\n<p>​\t<strong>界限寄存器</strong>中<strong>存放装入用户区程序的地址范围</strong></p>\n<p>​\t在 CPU 访问内存时，检查 CPU 要访问的内存单元的地址是否大于界限寄存器的值，如果大于，则是非法地址，表示用户进程访存越界，程序执行会被中断。</p>\n<h4 id=\"432-固定分区分配方式\"><a class=\"markdownIt-Anchor\" href=\"#432-固定分区分配方式\">#</a> 4.3.2 固定分区分配方式</h4>\n<p>​\t将内存用户区划分成若干个固定大小的区域，每个用户区中驻留一道程序。当有一个空闲分区时，可从外存的后备队列中选择一个大小适当的作业装 入该分区</p>\n<ul>\n<li>\n<p>划分分区的方法</p>\n<ul>\n<li>\n<p>分区大小相等</p>\n<p>把用户区划分成大小相等的若干个分区。</p>\n<p>缺点是内存利用率比较低。程序太小浪费空间，程序太大装不下</p>\n</li>\n<li>\n<p>分区大小不相等</p>\n<p>先划分多个大小不同、数量固定的若干个分区。分配的时候看哪个更接近就分配哪个。减少了浪费。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081204.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081204.png\" class=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"433-动态分区分配方式\"><a class=\"markdownIt-Anchor\" href=\"#433-动态分区分配方式\">#</a> 4.3.3 动态分区分配方式</h4>\n<p>​\t系统初始只有一个大空闲区，根据进程需要的空间大小分配内存。内存中<strong>分区的大小和数量是变化的</strong>。动态分区方式比固定分区方式<strong>显著地提高了内存利用率</strong>。系统维护一个记录当前空闲分区情况的数据结构，<strong>当进程请求内存时，系统从所有空闲区中找到大小合适的空闲分区进行分配</strong>。</p>\n<p>​\t常用的数据结构有<strong>空闲分区表</strong>和<strong>空闲分区链</strong></p>\n<p>➢ <strong>空闲分区表</strong></p>\n<p>​\t<img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081205.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081205.png\" class=\"\"></p>\n<p>​\t缺点：设置太多表项会浪费内存空间；设置太少无法记录所有空闲分区情况</p>\n<p>➢ <strong>空闲分区链</strong></p>\n<p>​\t可以<strong>动态地为每一个空闲分区建立一 个结点</strong>，每个结点包括分区大小、分区起始地址、指向前一个空闲分区结点的指针，以及指向后一个空闲分区结点的指针。空闲分区链中的<strong>每个结点占用的内存可以动态分配动态回收</strong>。</p>\n<p>➢ <strong>动态分区分配算法</strong></p>\n<p>​\t当进程需要内存空间时，操作系统通过执行动态分区分配算法从多个空闲分区中选定一个合适的分区分配给进程。</p>\n<p>​\t内存分配功能由内存分配程序完成。内存不再需要时，由系统调用内存回收程序回收原来被占的内存。</p>\n<ol>\n<li>\n<p>首次适应算法 FF (First Fit)</p>\n<p>​\t要求空闲分区链以<strong>地址递增</strong>的顺序链接。在内存分配时，从链首开始顺序查找，直至找到一个能满足进程大小要求的空闲分区为止。余下的空闲分区仍留在空闲链中。</p>\n<p>​\t该算法先分配低地址部分的内存空间，容易使低地址部分留下小分区，而高地址部分大空闲区较多。当进程请求大空间时，要找到合适的空闲分区，<strong> 时间开销大</strong>。</p>\n</li>\n<li>\n<p>循环首次适应算法 NF (Next Fit)</p>\n<p>​\t为进程分配内存空间时，<strong> 从上次找到的空闲分区的下一个空闲分区开始查找直到找到第个能满足要求的空闲分区</strong>，并从中划出一块与请求的大小相等的内存空间分配给进程。</p>\n<p>​\t为实现该算法，应设置一个起始查找指针，以指示下一次起始查找的空闲分区，并采用<strong>循环查找方式</strong>。循环首次适应算法的优点是:<strong> 空闲区分布均匀，查找开销较小。缺点是容易使系统缺乏大空闲区</strong>。</p>\n</li>\n<li>\n<p>最佳适应算法 BF (Best Fit)</p>\n<p>​\t该算法每次分配内存，把大小与进程所请求的<strong>内存大小最接近分配给进程</strong>。该算法要求将所有的空闲区按分区大小递增顺序形成一个空闲区链。</p>\n<p>​\t优点：避免大材小用，提高内存利用率，但容易留下难以利用的小空闲区</p>\n</li>\n</ol>\n<p>外部碎片 / 外碎片：低地址部分的空闲分区反复被划分，可能留下许多很小的空闲分区<br>\n内部碎片 / 内碎片：分配给进程的分区若大于进程请求的分区，分区内会有部分未利用的空间</p>\n<h3 id=\"44-基本本页存储管理方式\"><a class=\"markdownIt-Anchor\" href=\"#44-基本本页存储管理方式\">#</a> 4.4 基本本页存储管理方式</h3>\n<p>➢ <strong>离散内存管理方式</strong></p>\n<p>​\t\t把进程<strong>离散地</strong>存储在内存中物理地址不连续的区域中</p>\n<p>​\t根据离散内存管理分配内存空间的基本单位不同，分为 3 种管理方式:<strong> 分页存储管理、分段存储管理和段页式存储管理</strong>。</p>\n<h4 id=\"441-分页存储管理的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#441-分页存储管理的基本概念\">#</a> 4.4.1 分页存储管理的基本概念</h4>\n<ol>\n<li>\n<p>基础概念</p>\n<ol>\n<li>\n<p>页（Page）：将一个进程的<strong>逻辑地址空间</strong>分成多个大小相同的片</p>\n</li>\n<li>\n<p>页框 / 页帧：将<strong>物理内存空间</strong>分成与页大小相同的多个存储块</p>\n</li>\n<li>\n<p>分页存储：为进程分配内存时，<strong>以页框为单位</strong>将进程的若干个页<strong>装入多个不相邻的页框中</strong></p>\n</li>\n<li>\n<p>页内碎片：进程的最后一页装不满一个页框时，剩下的碎片</p>\n</li>\n<li>\n<p>页表：<strong>系统为进程建立的数据结构，实现从页号到页框号的映射</strong></p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081206.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081206.png\" class=\"\"></p>\n<h3 id=\"45-基于分页的虚拟存储系统\"><a class=\"markdownIt-Anchor\" href=\"#45-基于分页的虚拟存储系统\">#</a> 4.5 基于分页的虚拟存储系统</h3>\n<p>​\t<strong>虚拟存储器</strong>是指具有<strong>请求调入功能和置换功能</strong>，能从逻辑上对内存容量进行扩充的一种存储器系统。在虚拟存储器系统中，<strong> 进程无需全部装入</strong>，只要装入一部分即可运行。</p>\n<p>​\t虚拟存储技术实现的思想：先将进程一部分装入内存，其余部分需要时再请求系统装入，这就是请求调入。</p>\n<p>​\t置换：如果请求调入时，没有足够的内存，则由操作系统选择一部分内存中的内容换到外存。</p>\n<p>优点：</p>\n<ol>\n<li>提高内存利用率；</li>\n<li>提高多道程序度；</li>\n<li>把逻辑地址空间和物理地址空间分开，程序员不再关心物理内存的容量对编程的限制。</li>\n</ol>\n<p>虚拟存储系统具有以下几个主要特征：</p>\n<ol>\n<li>\n<p>离散性</p>\n<p>指进程可以分散地存储在物理内存中。分页、分段和段页式存储都属于离散的内存管理方式。离散性是实现虚拟存储管理的基础。</p>\n</li>\n<li>\n<p>多次性</p>\n<p>指不必把进程一 - 次性全部装入内存，可分多次装入。</p>\n</li>\n<li>\n<p>对换性</p>\n<p>指在内存中的进程可以换出，以腾出内存空间换入外存中的进程。</p>\n</li>\n<li>\n<p>虚拟性</p>\n<p>把逻辑地址空间和物理地址空间分开，程序员不再关心物理内存的容量对编程的限制。虚拟性是实现虚拟存储系统的最重要目标。</p>\n</li>\n</ol>\n<p>​\t<strong>请求分页系统</strong>是<strong>最基本、最常用的虚拟存储系统</strong>的实现方式。其基本原理是，把进程的逻辑地址空间分成大小相同的页，操作系统创建进程时只把进程的一部分页调入内存。进程运行过程中访问内存、若访问页不在内存中，则<strong>产生一个缺页异常信号</strong>，系统响应缺页异常，<strong> 请求调入缺页</strong>。</p>\n<p>​\t若调入缺页时内存已满，则需要先从内存中选择一个或若千个页换出到外存空间，以腾出内存空间容纳请求调入的缺页。</p>\n<h4 id=\"451-请求分页中的硬件支持\"><a class=\"markdownIt-Anchor\" href=\"#451-请求分页中的硬件支持\">#</a> 4.5.1 请求分页中的硬件支持</h4>\n<p>​\t为了实现请求分页，需要特殊的页表 (相对基本分页而言)、缺页异常机构和支持请求分页的地址变换机构。</p>\n<ol>\n<li>\n<p>页表</p>\n<p>是支持请求分页系统最重要的数据结构，其作用是记录描述页的各种数据，包括在实现逻辑地址到物理地址映射时需要的页号与页框号的对应关系。</p>\n<p>​\t除了页号和页框号之外，页表中增加了请求换入和页置换时需要的数据。</p>\n<p>​\t在支持请求分页的系统中一般包含以下基本字段:</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081601.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081601.png\" class=\"\"></p>\n<p>​\t页框号：存放页所在的页框号。</p>\n<p>​\t状态位 P : 标识页是否在内存中。可规定 0 不在，1 在。</p>\n<p>​\t访问字段 A : 用于记录页最近被访问的情况。系统总是希望根据 A 的值把最近、最久未访问的页换出到外存。</p>\n<p>​\t修改位 M : 标识页最近是否被修改过。</p>\n<p>​\t保护位：标识页的访问权限，如 1 表示可读可写 0 表示只读。</p>\n</li>\n<li>\n<p>缺页异常机构</p>\n<p>​\t主要作用是在访问内存过程中发现缺页时产生缺页异常信息，使 CPU 中断当前控制流的执行，转去执行操作系统的缺页异常处理程序，完成请求调页。</p>\n</li>\n<li>\n<p>地址变换</p>\n<p>请求分页系统中的地址变化过程如下:</p>\n<ol>\n<li>\n<p>由分页地址变换机构从逻辑地址中分离出页号和页内偏移地址</p>\n</li>\n<li>\n<p>以页号为索引查找快表，若快表中有该页的页表项，则读出页框号，计算物理地址</p>\n</li>\n<li>\n<p>若快表中无该页信息，转到内存页表中查找。若页表中的状态位 P 显示该页调入内存，则从相应的页表项读出页所在的页框号，并计算物理地址，然后把该页表项写入快表</p>\n</li>\n<li>\n<p>若该页尚末调入内存，则产生缺页异常请求操作系统从外存中把该页调入内存，然后修改页表，重新执行被中断的指令。</p>\n<p>​\t\t\t\t\t\t\t\t请求分页中的地址变换过程，如下图</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081602.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081602.png\" class=\"\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"452-页分配策略\"><a class=\"markdownIt-Anchor\" href=\"#452-页分配策略\">#</a> 4.5.2 页分配策略</h4>\n<ol>\n<li>\n<p>最少页框数</p>\n<p>指能保证进程正常运行所需要的最少的页框数。为了保证进程顺利执行，操作系统为进程分配的初始页数应该大于或等于最少页框数。</p>\n</li>\n</ol>\n<h4 id=\"453-页调入策略\"><a class=\"markdownIt-Anchor\" href=\"#453-页调入策略\">#</a> 4.5.3 页调入策略</h4>\n<ol>\n<li>\n<p>何时调入页<br>\n大多数系统都采用<strong>预先凋入页</strong>的策略，将预计不久之后会被访问的页预先调入内存，而不是缺哪一页时再调入该页。</p>\n<p>​\t在实际系统中，通常是在<strong>调入缺页时，把与所缺页相邻的若千页也调入内存</strong>。</p>\n</li>\n<li>\n<p>从何处调入页</p>\n<p>当系统拥有足够的对换空间时，若发生缺页请求则从对换区调入页。从对换区调入页比从文件区调入页的速度快。对换区中的页是进程运行前从文件区复制到对换区的。</p>\n</li>\n</ol>\n<h4 id=\"454-页置换算法\"><a class=\"markdownIt-Anchor\" href=\"#454-页置换算法\">#</a> 4.5.4 页置换算法</h4>\n<p>​\t页置换算法是从内存中选择换出页的算法。</p>\n<ol>\n<li>\n<p>最佳置换算法和先进先出置换算法</p>\n<p>( 1 )<strong> 最佳置换算法</strong></p>\n<p>​\t选择以后永远不会被访问的页或者在未来最长时间内不再被访问的页作为换出页。该算法主要用于<strong>理论研究</strong>。</p>\n<p>( 2 )<strong> 先进先出页置换算法</strong></p>\n<p>​\t为每个页记录该项调入内存的时间，当选择换出页时，选择进入内存时间最早的页。</p>\n<p>​\t实现简单，但<strong>效率低</strong>，会导致较高的缺页率，有的页刚被换出，可能又要立即被访问。</p>\n</li>\n<li>\n<p>最近最久未使用 LRU 置换算法</p>\n<p>​\t<strong>选择最近最久末使用的页换出</strong>。同样的页引用序列，LRU 算法<strong>置换次数</strong>较先进先出算法少，性能较好。</p>\n</li>\n<li>\n<p>其他置换算法</p>\n<p>​\t附加引用位算法、简单 Clock 置换算法、 改进型 Clock 算法、最少使用置换算法。</p>\n</li>\n</ol>\n<h4 id=\"综合题\"><a class=\"markdownIt-Anchor\" href=\"#综合题\">#</a> 综合题</h4>\n<p>[答案] 先进先出页置换算法</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081603.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081603.png\" class=\"\"></p>\n<h4 id=\"455-请求分页系统的性能分析\"><a class=\"markdownIt-Anchor\" href=\"#455-请求分页系统的性能分析\">#</a> 4.5.5 请求分页系统的性能分析</h4>\n<p>请求调入和置换技术都是以时间换空间的技术。</p>\n<ol>\n<li>\n<p>缺页率对有效访问时间的影响</p>\n<p>​\t进程执行中访存发生缺页时，需要请求从外存调入缺页。如果内存中没有空闲页框，还需要进行页置换，调入缺页后，指令需要重新执行。因此，一旦发生缺页，进程会存在因为访存而带来的时间延迟。</p>\n<p>​\t有效访问时间正比于缺页率。</p>\n</li>\n<li>\n<p>工作集</p>\n<p>​\t引入<strong>工作集机制</strong>是为了<strong>能有效降低缺页率</strong>，从而提高访存的时间效率。程序运行时<strong>对页的访问是不均匀的</strong>，往往在<strong>某段时间内集中于访问某些页</strong>。若能将<strong>某段时间间隔内要访问的页提前调入内存</strong>，将会大大降低缺页率，从而减少置换次数，提高 CPU 的利用率。<strong>工作集</strong>就是<strong>在某段时间间隔内，进程实际要访问的页的集合</strong>。</p>\n</li>\n<li>\n<p>抖动产生的原因和预防方法</p>\n<p>​\t多道程序度太高，使运行进程的大部分时间都用于进行页的换入、换出，而几乎不能完成任何有效工作的状态称为抖动。<br>\n​\t引起<strong>抖动的原因</strong>是<strong>系统中的进程数量太多，每个进程能分配到的页框态少</strong>，以至于进程运行过程中频繁请求调页。</p>\n<p>抖动的预防:<br>\n( 1 )<strong> 采取局部置换策略</strong>。仅在进程自己的内存空间范围内置换页。<br>\n(2) 在 CPU 调度程序中<strong>引入工作集</strong>算法。<br>\n( 3 )<strong> 挂起若干进程</strong>。腾出进程占用的空间。</p>\n</li>\n</ol>\n<h3 id=\"46-分段存储管理\"><a class=\"markdownIt-Anchor\" href=\"#46-分段存储管理\">#</a> 4.6 分段存储管理</h3>\n<h4 id=\"461-分段机制的引入\"><a class=\"markdownIt-Anchor\" href=\"#461-分段机制的引入\">#</a> 4.6.1 分段机制的引入</h4>\n<p>​\t在分页存储管理方式中，逻辑地址是维的，一个进程的逻辑地址形成个地址空间。 这种逻辑空间的使用方式对于程序员来说很不方便，分段能为进程提供多个地址空间，把逻辑上关联的部分放在一个地址空间中逻辑上没有关联也没有共同特征的部分放在不同的地址空间中。这样不仅方便用户编程，而且能很好地解决部分存储空间动态增长、信息共享和信息保护问题。</p>\n<p>​\t把分别存放逻辑上相关的信息、相互独立的逻辑地址空间称为一个段，每个段由一个从 0 到最大线性地址的逻辑地址空间构成。</p>\n<p>​\t各个段的长度可以是 0 到最大值之间的任何一个值不同段的长度可以不相同，段的长度在进程运行期间可以改变。</p>\n<p>​\t在使用分段存储管理的系统中，程序员使用二维的逻辑地址，一个数用来表示段，另一个数用来表示段内偏移。段是一个逻辑实体，程序员可以通过使用二维地址来访问不同的逻辑段。</p>\n<p>​\t一个段可能包括一个过程，或者一个数组、一个堆栈、一些数值变量，但是一般不会同时包含多种不同的内容。</p>\n<h4 id=\"462-分段系统的基本原理\"><a class=\"markdownIt-Anchor\" href=\"#462-分段系统的基本原理\">#</a> 4.6.2 分段系统的基本原理</h4>\n<ol>\n<li>\n<p>分段</p>\n<p>​\t在分段的存储管理方式中，进程的地址空间被划分成若千个段。每个段定义了一组逻辑信息，每个段的大小由相应的逻辑信息组的长度确定，段的大小不一样 **, 每个段的逻辑地址从 0 开始，采用一段连续的地址空间 **。系统为每个段分配一个连续的物理内存区域，各个不同的段<strong>可以离散地放入物理内存不同的区域</strong>。</p>\n</li>\n<li>\n<p>分段的逻辑地址结构<br>\n分段机制的逻辑地址是二维的，由段号和段内地址组成。</p>\n<p>32 位系统中分段的地址形式为:</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081604.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081604.png\" class=\"\"></p>\n</li>\n<li>\n<p>段表</p>\n<p>​\t段表是<strong>由操作系统维护</strong>的用于支持分段存储管理地址映射的<strong>数据结构</strong>。通常，<strong> 每个进程有一个段表</strong>，段表由段表项构成。每个段表项包含<strong>段号、段基址</strong> (段的起始地址) 和<strong>段长</strong> (段大小) 3 个部分。一个进程可能包含若干个段，每一个段在段表中有一个段表项与之对应。根据段表可以知道一个段在物理内存中的位置。</p>\n</li>\n<li>\n<p>分段系统的地址变换</p>\n<p>​\t逻辑地址由段号 s 和段内偏移 d 构成。<br>\n​\t已知逻辑单元的地址为 s:d， 求物理地址的步骤为:<br>\n​\t(1) 以 s 为索引，从段表中找到段号为 s 的段表项。<br>\n​\t(2) 从找到的段表项中读出 s 段的基地址和段大小。<br>\n​\t(3) 如果<strong> d &lt; = 段大小</strong>，则将<strong>段基址与段内偏移 d 相加，得到与逻辑单元 s:d 对应的物理单元地址</strong>。</p>\n</li>\n<li>\n<p>分页和分段的主要区别</p>\n<ol>\n<li>页是按物理单位划分的，分页的引入是为了提高内存的利用率和支持虚拟存储。而段是按逻辑单位划分的，一个段含有一 - 组意义相对完整的信息。引入分段的目的是为了方便程序员编程。</li>\n<li>页的大小是固定的，而段的大小不固定，取决于用户编写的程序和编译器。</li>\n<li>分页的地址空间是一维的，程序员给出的地址只是一个助记符，已知的逻辑地址是一个整数。分段的地址空间是二维的，程序员在标识一个逻辑地址时需要给出两个数：一个是段号，一个是段内偏移。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"463-段页式存储管理\"><a class=\"markdownIt-Anchor\" href=\"#463-段页式存储管理\">#</a> 4.6.3 段页式存储管理</h4>\n<ol>\n<li>\n<p>段页式存储管理的基本原理</p>\n<p>​\t在段页式存储管理系统中，将用户进程的逻辑空间先划分成若干个段，每个段再划分成若千个页。进程以页为单位在物理内存中离散存放，每个段中被离散存放的页具有逻辑相关性。</p>\n</li>\n<li>\n<p>地址变换过程</p>\n<p>​\t在段页式存储管理系统中，逻辑地址与分段系统的逻辑地址相同，由段号 s 和段内地址 d 构成，地址变换过程如下<br>\n (1) 以段号 s 作索引，找到段 s 的段表项，得到该段页表的起始地址。<br>\n(2) 通过分页机制从<strong>段内偏移 d 中分离出页号 P 和页内偏移 W</strong>。<br>\n(3) 以段内页号<strong> P 作索引</strong>，从段 s 的页表中<strong>搜索</strong>页号<strong> P</strong> 对应的<strong>页表项</strong>。<br>\n(4) 从页表项中<strong>得到</strong>页所在的<strong>页框号</strong>。<br>\n(5) 由<strong>页框号</strong>与<strong>页内偏移 W</strong> 得到某逻辑地址对应的物理地址。</p>\n<p>物理地址 = 页框号 * 页框大小 + 页内偏移 W<br>\n 采用段页式存储管理的好处是，程序员可以使用分段的逻辑地址，而实际上进程却以页为单位存放于物理内存中。段页式系统的地址变换如下图。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081607.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081607.png\" class=\"\"></p>\n</li>\n</ol>\n<h4 id=\"464-综合题\"><a class=\"markdownIt-Anchor\" href=\"#464-综合题\">#</a> 4.6.4 综合题</h4>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081605.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081605.png\" class=\"\"><br>\n<img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081606.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081606.png\" class=\"\"></p>\n<h3 id=\"47-linux的伙伴系统\"><a class=\"markdownIt-Anchor\" href=\"#47-linux的伙伴系统\">#</a> 4.7 Linux 的伙伴系统</h3>\n<p>略</p>\n<hr>\n<h2 id=\"第五章文件管理\"><a class=\"markdownIt-Anchor\" href=\"#第五章文件管理\">#</a> 第五章：文件管理</h2>\n<h3 id=\"考试重点-2\"><a class=\"markdownIt-Anchor\" href=\"#考试重点-2\">#</a> 考试重点</h3>\n<p>文件结构、类型、存取、属性 (选择、填空、简答）<br>\n目录结构、路径名 (选择、填空、简答)<br>\n 实现文件、实现目录 (选择、填空、简答、综合)</p>\n<p>本章近 3 年分值: 14~19 分</p>\n<p><strong>操作系统中处理文件的部分称为文件系统</strong>，文件系统包括了文件及管理文件的软件集合。</p>\n<h3 id=\"51-文件\"><a class=\"markdownIt-Anchor\" href=\"#51-文件\">#</a> 5.1 文件</h3>\n<h4 id=\"511-文件命名\"><a class=\"markdownIt-Anchor\" href=\"#511-文件命名\">#</a> 5.1.1 文件命名</h4>\n<p>​\t<strong>文件名</strong>向用户提供了简单、直观的文件<strong>访问方式</strong>。<strong>按名存取</strong>。</p>\n<p>​\t所有操作系统都支持<strong> 1 ~8 个字母组成的字符串</strong>作为文件名。许多操作系统支持<strong>长达 255 个字符</strong>的文件名。</p>\n<p>​\tUNIX 文件系统区分大小写，MS-DOS 系统不区分。</p>\n<h4 id=\"512-文件结构\"><a class=\"markdownIt-Anchor\" href=\"#512-文件结构\">#</a> 5.1.2 文件结构</h4>\n<ol>\n<li>\n<p>无结构字节序列</p>\n<p>也称为流式文件，如程序。</p>\n</li>\n<li>\n<p>固定长度记录序列</p>\n<p>构成文件的基本单位是具有固定长度的记录。</p>\n</li>\n<li>\n<p>树形结构</p>\n<p>文件由一棵记录树构成，记录长度不固定，在记录的固定位置包含一个关键字域，记录树按该域排序。</p>\n</li>\n</ol>\n<h4 id=\"513-文件类型\"><a class=\"markdownIt-Anchor\" href=\"#513-文件类型\">#</a> 5.1.3 文件类型</h4>\n<p>​\t一般分为 ASCII 文件和 2 进制文件。ASCI 文件。由多行正文组成，各行的长度不必相同。可以显示和打印，也可以用通常的文本编辑器进行编辑。</p>\n<p>​\t二进制文件。具有一定的内部结构，如可执行的.exe 文件。用通常的文本编辑器不能直接显示或打印。</p>\n<h4 id=\"514-文件存取\"><a class=\"markdownIt-Anchor\" href=\"#514-文件存取\">#</a> 5.1.4 文件存取</h4>\n<p>​\t文件存取方式有两种：顺序存取和随机存取。</p>\n<p>​\t顺序存取：进程从文件开始处读取文件中的所有字节或记录，不能掉过某些内容（磁带）</p>\n<p>​\t随机存取：又称直接存取，可以任意顺序读取文件中的字节或记录（磁盘）</p>\n<h4 id=\"515-文件属性\"><a class=\"markdownIt-Anchor\" href=\"#515-文件属性\">#</a> 5.1.5 文件属性</h4>\n<p>​\t文件的创建日期、文件大小和修改时间等，这些附加信息称为文件属性。一些常用的文件属性有：口令、创建者、所有者，只读标志、隐藏标志、大小、类型等。</p>\n<h4 id=\"516-文件操作\"><a class=\"markdownIt-Anchor\" href=\"#516-文件操作\">#</a> 5.1.6 文件操作</h4>\n<p>CREATE：创建文件，并设置文件的一些属性。</p>\n<p>DELETE：删除文件并释放磁盘空间。</p>\n<p>OPEN：使用文件之前，必须先打开文件。</p>\n<p>CLOSE：存取结束后，关闭文件以释放内存空间。</p>\n<p>READ：从文件中读取数据。</p>\n<p>WRITE：往文件中写数据。</p>\n<p>APPEND：在文件末尾添加数据。</p>\n<p>SEEK：对于随机存取文件，要指定从何处开始取数据。</p>\n<p>GETAT TRIBUTES：用于获取文件的属性。</p>\n<p>SETAT TRIBUTES：用于修改文件的属性。</p>\n<p>RENAME：修改已有文件的文件名。</p>\n<h3 id=\"52-目录\"><a class=\"markdownIt-Anchor\" href=\"#52-目录\">#</a> 5.2 目录</h3>\n<p>​\t文件系统通常提供目录或文件夹用于记录文件很多系统中目录本身也是文件，目录是文件系统中实现按名访问文件的重要数据结构。</p>\n<h4 id=\"521-层次目录系统\"><a class=\"markdownIt-Anchor\" href=\"#521-层次目录系统\">#</a> 5.2.1 层次目录系统</h4>\n<ol>\n<li>\n<p>目录文件的结构</p>\n</li>\n<li>\n<p>目录结构</p>\n<ol>\n<li>\n<p>单层目录</p>\n<p>​\t也被称为根目录，在整个系统中设置一张线性目录表，表中包括了所有文件的描述信息。</p>\n</li>\n<li>\n<p>两级目录</p>\n<p>​\t第一级为<strong>主目录</strong>。第二级为<strong>用户目录</strong>。两级目录解决了文件重名和共享问题。</p>\n</li>\n<li>\n<p>树形目录</p>\n<p>​\t也称多级目录，最高层为根目录，最底层为文件。用户可以创建任意数量的<strong>子目录</strong>。优点：便于文件的分类，层次结构清晰，便于管理和保护，解决了重名问题，查找速度快。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"522-路径名\"><a class=\"markdownIt-Anchor\" href=\"#522-路径名\">#</a> 5.2.2 路径名</h4>\n<p>​\t常用的方法有两种：绝对路径名和相对路径名。</p>\n<p>​\t绝对路径名由从根目录到文件的路径组成。绝对路径名总是从根目录开始，并且是唯一的。在 Windows 系统中，路径各部分之间用 &quot;&quot; 分隔，如：C:\\program\\practice\\test</p>\n<p>​\t相对路径名。当一个文件系统的目录包含很多级时，可以允许用户指定一个目录作为当前的工作目录。所有的不从根目录开始的路径名都是相对于工作目录的。</p>\n<h3 id=\"53-文件系统的实现\"><a class=\"markdownIt-Anchor\" href=\"#53-文件系统的实现\">#</a> 5.3 文件系统的实现</h3>\n<h4 id=\"531-实现文件\"><a class=\"markdownIt-Anchor\" href=\"#531-实现文件\">#</a> 5.3.1 实现文件</h4>\n<p>​\t将分配给文件的<strong>连续扇区构成的磁盘块称为簇</strong>。</p>\n<ol>\n<li>\n<p>连续分配</p>\n<p>​\t把每个文件作为一连串连续数据块存储在磁盘上。每个文件都从新的簇开始存放。</p>\n<p>​\t优点：实现简单，读操作性能好。</p>\n<p>​\t缺点：随着时间的推移，碎片太多，难以利用</p>\n</li>\n<li>\n<p>使用磁盘链接表的分配</p>\n<p>​\t该方法为每个文件构造簇的链接表，每个簇前几个字节用于存放下一个簇的簇号。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081701.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081701.png\" class=\"\"></p>\n<p>​</p>\n<p>​\t优点：充分利用每个簇，不会浪费存储空间，管理简单</p>\n<p>​\t缺点：随机存取相当缓慢，要获取文件的第 n 块都要从头开始读取前面的 n- 1 块。</p>\n</li>\n<li>\n<p>使用内存的链接表分配</p>\n<p>​\t该方法是<strong>将</strong>文件所在的磁盘的<strong>簇号存放在内存的表中</strong>。</p>\n<p>​\t缺点：必须把整个表都存放在内存中，不适合大容量磁盘。</p>\n</li>\n<li>\n<p>i - 结点</p>\n<p>​\t该方法为每个文件赋予一个被称为 i 结点的数据结构，其中列出了文件属性和文件块的磁盘地址。给定一个文件的结点，就有可能找到文件的所有块。</p>\n<p>​\t当访问文件时，系统先根据文件名搜索文件所在的目录文件，从该文件对应的目录项中找到文件的结点号，根据 i 结点号从磁盘中将结点信息读入内存，文件在磁盘中的地址信息都存放在 i 结点中。</p>\n</li>\n</ol>\n<h4 id=\"532-实现目录\"><a class=\"markdownIt-Anchor\" href=\"#532-实现目录\">#</a> 5.3.2 实现目录</h4>\n<p>​\t打开文件时，操作系统利用用户给出的路径名找到相应的目录项，目录项中提供了查找文件簇所需要的信息。（略）</p>\n<h4 id=\"533-磁盘空间管理\"><a class=\"markdownIt-Anchor\" href=\"#533-磁盘空间管理\">#</a> 5.3.3 磁盘空间管理</h4>\n<p>​\t磁盘空间管理是文件系统的重要功能，包括记录空闲磁盘信息、设计文件的存储方式，以及规定文件系统的簇大小等内容。</p>\n<ol>\n<li>\n<p>簇大小</p>\n<p>​\t文件系统为文件分配磁盘空间是以簇为单位。簇的大小是<strong> 2 的整数次幂</strong>个连续的扇区。</p>\n</li>\n<li>\n<p>记录空闲块</p>\n<ol>\n<li>\n<p>空闲簇链接表</p>\n<p>​\t用一些空闲簇存放空闲簇的簇号。一个簇存放尽可能多的空闲簇的簇号，并专留出最后几个字节存放指向下一个存放空闲簇的指针。</p>\n</li>\n<li>\n<p>位图</p>\n<p>​\t用 n 位位图对应磁盘的 n 个簇，在位图中，空闲簇用 1 表示，已分配簇用 0 表示。每个簇只用一个二级制位标识，所需空间少。</p>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"第六章设备管理\"><a class=\"markdownIt-Anchor\" href=\"#第六章设备管理\">#</a> 第六章：设备管理</h2>\n<h3 id=\"考试重点-3\"><a class=\"markdownIt-Anchor\" href=\"#考试重点-3\">#</a> 考试重点</h3>\n<p>I/O 系统的结构、I/O 设备分类、设备控制器 (选择、填空、简答)<br>\n 轮询、中断、DMA 控制方式 (选择、填空、简答)<br>\n 缓冲管理 (选择、填空、简答)<br>\n 设备分配、独立性、SPOOLing 技术 (选择、 填空、简答)<br>\n I/O 软件管理 (选择、填空、简答)<br>\n 磁盘结构 (选择、填空、简答)<br>\n 磁盘调度 (选择、填空、简答、综合)</p>\n<p>本章近 3 年分值: 12~20 分</p>\n<h3 id=\"61-io系统的组成\"><a class=\"markdownIt-Anchor\" href=\"#61-io系统的组成\">#</a> 6.1 I/O 系统的组成</h3>\n<h4 id=\"611-io系统的组成的概述\"><a class=\"markdownIt-Anchor\" href=\"#611-io系统的组成的概述\">#</a> 6.1.1 I/O 系统的组成的概述</h4>\n<p>I/O 设备包括：I/O 设备、设备控制器、通道。</p>\n<h4 id=\"612-io系统的结构\"><a class=\"markdownIt-Anchor\" href=\"#612-io系统的结构\">#</a> 6.1.2 I/O 系统的结构</h4>\n<ol>\n<li>\n<p>微机 I/O 系统</p>\n<p>CPU 不能直接跟 I/O 设备交换，需要设备控制器</p>\n</li>\n<li>\n<p>主机 I/O 系统</p>\n<p>I/O 系统采用四级结构：主机、通道、控制器、设备。一个通道可控制多个控制器，一个控制器可控制多个设备</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081801.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081801.png\" class=\"\"></p>\n</li>\n</ol>\n<h4 id=\"613-io设备的分类\"><a class=\"markdownIt-Anchor\" href=\"#613-io设备的分类\">#</a> 6.1.3 I/O 设备的分类</h4>\n<ol>\n<li>\n<p>按传输速率</p>\n<ol>\n<li>低速设备：键盘、鼠标</li>\n<li>中速设备：打印机</li>\n<li>高速设备：磁带机、磁盘机、光盘机</li>\n</ol>\n</li>\n<li>\n<p>按信息交换的单位</p>\n<ol>\n<li>\n<p>块设备</p>\n<p>数据存储以数据块为单位，块大小固定，一次只传输一块，通过块号访问数据</p>\n</li>\n<li>\n<p>字符设备</p>\n<p>传输字节流；打印机、鼠标都是</p>\n</li>\n</ol>\n</li>\n<li>\n<p>按设备的共享属性</p>\n<ol>\n<li>\n<p>独占设备</p>\n<p>必须作为临界资源以互斥方式访问，在当前进程未使用完，其他进程不可使用</p>\n</li>\n<li>\n<p>共享设备</p>\n<p>允许多个进程同时访问，但同一时刻只能单个进程对磁盘读写</p>\n</li>\n<li>\n<p>虚拟设备</p>\n<p>将物理设备虚拟成若干个逻辑设备</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"614-设备控制器\"><a class=\"markdownIt-Anchor\" href=\"#614-设备控制器\">#</a> 6.1.4 设备控制器</h4>\n<p>CPU 与 I/O 设备的<strong>接口</strong>。</p>\n<ol>\n<li>功能\n<ul>\n<li>接收和识别</li>\n<li>数据交换\n<ol>\n<li>将驱动器的比特流汇聚在控制器的缓冲区，形成字节块</li>\n<li>在 CPU 和控制器双向传输</li>\n<li>将控制器的命令传给设备控制器</li>\n</ol>\n</li>\n<li>设备状态的了解和报告</li>\n<li>地址识别</li>\n<li>数据缓存</li>\n<li>差错控制</li>\n</ul>\n</li>\n<li>组成\n<ol>\n<li>与处理机的接口：数据线、控制线、地址线</li>\n<li>与设备的接口：存在三类信号，分别是数据、状态、控制信号</li>\n<li>I/O 逻辑：指令译码器、地址译码器</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081802.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081802.png\" class=\"\"></p>\n<h4 id=\"614-io通道\"><a class=\"markdownIt-Anchor\" href=\"#614-io通道\">#</a> 6.1.4 I/O 通道</h4>\n<p>​\t用于大型主机系统控制 I/O 设别，替代主机的设备控制器，提高 CPU 利用率和系统吞吐量</p>\n<h3 id=\"62-io控制方式\"><a class=\"markdownIt-Anchor\" href=\"#62-io控制方式\">#</a> 6.2 I/O 控制方式</h3>\n<h4 id=\"621-轮询\"><a class=\"markdownIt-Anchor\" href=\"#621-轮询\">#</a> 6.2.1 轮询</h4>\n<p>​\t在对设别发出 I/O 指令前，反复确认设备控制器状态寄存器的忙 / 闲标志。若空闲则发指令</p>\n<p>​\t缺点：极大浪费 CPU，影响系统的吞吐量</p>\n<h4 id=\"622-中断\"><a class=\"markdownIt-Anchor\" href=\"#622-中断\">#</a> 6.2.2 中断</h4>\n<p>​\t当 I/O 设备忙，进程阻塞；工作完毕之后发出中断请求信号，CPU 响应</p>\n<p>​\t优点：使 CPU 与 I/O 设备在某些时间段上并行时间，提高 CPU 利用率和系统吞吐量</p>\n<h4 id=\"623-dma控制方式\"><a class=\"markdownIt-Anchor\" href=\"#623-dma控制方式\">#</a> 6.2.3 DMA 控制方式</h4>\n<p>​\t为提高 I/O 的速度和 CPU 与 I/O 的并行速度。</p>\n<p>​\t逻辑组成包括三部分：主机与 DMA 接口、DMA 与设备的接口、I/O 控制逻辑。</p>\n<p>​\t为了主机与设备管理器成块数据传送，设计了四类寄存器：</p>\n<ol>\n<li>命令 / 状态寄存器 CR：接受 CPU 的 I/O 命令和有关控制信息、设别状态</li>\n<li>内存地址寄存器 MAR：存放内存地址</li>\n<li>数据计数器 DC：指示 DMA，本次向 CPU 发中断信号要读或写数据的次数</li>\n<li>数据寄存器 DR：暂存 DMA 传输中输入输出的数据</li>\n</ol>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081803.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081803.png\" class=\"\"></p>\n<h3 id=\"63-缓冲管理\"><a class=\"markdownIt-Anchor\" href=\"#63-缓冲管理\">#</a> 6.3 缓冲管理</h3>\n<h4 id=\"缓冲管理的概述\"><a class=\"markdownIt-Anchor\" href=\"#缓冲管理的概述\">#</a> 缓冲管理的概述</h4>\n<p>​\t用于保存程序与程序、程序与设备之间传输数据的内存区域</p>\n<p>​\t为了尽可能使 CPU 与设备并行工作，提高系统的性能，需要操作系统在设备管理软件中提供缓冲区管理功能。</p>\n<h4 id=\"631-缓冲的引入\"><a class=\"markdownIt-Anchor\" href=\"#631-缓冲的引入\">#</a> 6.3.1 缓冲的引入</h4>\n<p>引入缓冲区的原因主要有一下两点:</p>\n<ol>\n<li>处理数据流的生产者与消费者之间的速度差异。</li>\n<li>协调传输数据大小不一致的设备</li>\n</ol>\n<h4 id=\"632-单缓冲\"><a class=\"markdownIt-Anchor\" href=\"#632-单缓冲\">#</a> 6.3.2 单缓冲</h4>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082501.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082501.png\" class=\"\"></p>\n<h4 id=\"633-双缓冲\"><a class=\"markdownIt-Anchor\" href=\"#633-双缓冲\">#</a> 6.3.3 双缓冲</h4>\n<p>​\t对单缓冲进行了改进，性能提高，增加了复杂性</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082502.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082502.png\" class=\"\"></p>\n<h4 id=\"634-循环缓冲\"><a class=\"markdownIt-Anchor\" href=\"#634-循环缓冲\">#</a> 6.3.4 循环缓冲</h4>\n<p>​\t当数据的输入和输出差别很大时，需要增大缓冲区数量，也就采用了循环缓冲</p>\n<p>➢ 循环缓冲的组成：</p>\n<ol>\n<li>多个缓冲区\n<ul>\n<li>空缓冲区 R</li>\n<li>已满数据的缓冲区 G</li>\n<li>现行工作缓冲区 C</li>\n</ul>\n</li>\n<li>多个指针\n<ul>\n<li>Nextg（消费者，装满数据的缓冲区）</li>\n<li>Nexti（生产者，空缓冲区）</li>\n<li>Current（进程正在使用）</li>\n</ul>\n</li>\n</ol>\n<p>➢ 循环缓冲的概念</p>\n<p>​\t生产者和消费者并行执行。循环缓冲的缓冲区构成一个环。Nextg 和 Nexti 指针不断沿顺时针方向移动。当一方追上另一方时，便会阻塞该进程。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082503.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082503.png\" class=\"\"></p>\n<h4 id=\"635-缓冲池\"><a class=\"markdownIt-Anchor\" href=\"#635-缓冲池\">#</a> 6.3.5 缓冲池</h4>\n<p>一种广泛应用的缓冲管理技术，存在多个可供多个进程共享的缓冲区，提高了效率</p>\n<p>➢ 循环缓冲的组成：</p>\n<p>​\t可输入也可输出，至少包含 3 种类型的缓冲区、3 种缓冲队列、四种工作缓冲区</p>\n<ol>\n<li>缓冲区\n<ul>\n<li>空缓冲区</li>\n<li>装满输入数据的缓冲区</li>\n<li>装满输出数据的缓冲区</li>\n</ul>\n</li>\n<li>缓冲队列\n<ul>\n<li>空缓冲队列</li>\n<li>输入队列</li>\n<li>输出队列</li>\n</ul>\n</li>\n<li>工作缓冲区\n<ul>\n<li>收容输入</li>\n<li>提取输入</li>\n<li>收容输出</li>\n<li>提取输出</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"64-设备分配\"><a class=\"markdownIt-Anchor\" href=\"#64-设备分配\">#</a> 6.4 设备分配</h3>\n<p>​\t不允许用户自行使用，需要系统分配，且需要记录设备情况的数据结构和设备分配算法</p>\n<h4 id=\"641-设备分配中的数据结构\"><a class=\"markdownIt-Anchor\" href=\"#641-设备分配中的数据结构\">#</a> 6.4.1 设备分配中的数据结构</h4>\n<p>​\t支持设备分配的数据结构：<strong>记录设备的状态 (忙或空闲)</strong>、<strong>设备类型</strong><br>\n​\t设备分配方案：<strong>设备控制表</strong>、<strong>控制器控制表</strong>、<strong>通道控制表和系统设备表</strong></p>\n<ol>\n<li>\n<p>设备控制表 DCT (Device Control Table)</p>\n<p>系统为每个设备建立一张设备控制表，多台设备的设备控制表构成设备控制表集合。</p>\n<p>设备控制表包含下列信息：</p>\n<ul>\n<li>设备类型</li>\n<li>设备标志符</li>\n<li>设备状态：忙 / 闲</li>\n<li>指向控制器表的指针</li>\n<li>重复执行的次数或时间</li>\n<li>设备 (请求) 队列的队首指针</li>\n</ul>\n</li>\n<li>\n<p>控制器控制表 COCT (Controller Control Table)</p>\n<p>系统为每个控制器设置一 - 张用于记录该控制器信息的控制器控制表，控制器控制表中包含以下几个字段:</p>\n<ul>\n<li>控制器标识符</li>\n<li>控制器状态</li>\n<li>与控制器相连接的通道表指针</li>\n<li>控制器队列的队首指针</li>\n<li>控制器队列的队尾指针</li>\n</ul>\n</li>\n<li>\n<p>通道控制表 CHCT (Channel Control Table)</p>\n<p>在一些主机系统中还有通道设备，系统会为每个通道设备设置一 - 张通道控制表，通道控制表包括以下几个字段。</p>\n<ul>\n<li>控制器标识符</li>\n<li>控制器状态</li>\n<li>与通道连接的控制器表首址</li>\n<li>通道队列的队首指针</li>\n<li>通道队列的队尾指针</li>\n</ul>\n</li>\n<li>\n<p>系统设备表 SDT (System Device Table)</p>\n<p>​\t记录了系统中全部设备的情况。每个设备占一个表目，其中包括设备类型、设备标识符、设备控制表及设备驱动程序的入地址。</p>\n</li>\n</ol>\n<h4 id=\"642-设备分配\"><a class=\"markdownIt-Anchor\" href=\"#642-设备分配\">#</a> 6.4.2 设备分配</h4>\n<p>系统分配时需要考虑 3 个因素：<strong>设备的固有属性</strong>、<strong>设备分配算法</strong>、<strong>设备分配时的安全性</strong></p>\n<ol>\n<li><strong>设备的固有属性</strong>\n<ul>\n<li>独占性（利用不充分、容易死锁）</li>\n<li>共享性（需要对先后顺序进行合理调度）</li>\n<li>可虚拟性</li>\n</ul>\n</li>\n<li><strong>设备分配算法</strong></li>\n<li><strong>设备分配时的安全性</strong></li>\n</ol>\n<h4 id=\"643-设备独立性\"><a class=\"markdownIt-Anchor\" href=\"#643-设备独立性\">#</a> 6.4.3 设备独立性</h4>\n<ol>\n<li>\n<p>概念</p>\n<p>应用程序独立于具体使用的物理设备</p>\n</li>\n<li>\n<p>好处</p>\n<ul>\n<li>应用程序与物理设备无关</li>\n<li>易于处理 I/O 设备的故障</li>\n<li>提高系统可靠性</li>\n</ul>\n</li>\n<li>\n<p>设备独立软件</p>\n<ol>\n<li>执行所有设备的公有操作</li>\n<li>向用户层软件提供统一的接口</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"644-独占设备的分配程序\"><a class=\"markdownIt-Anchor\" href=\"#644-独占设备的分配程序\">#</a> 6.4.4 独占设备的分配程序</h4>\n<p>​\t对于具有 / O 通道的系统，在进程提出 I/O 请求后，系统的设备分配程序可按下列步骤进行设备分配</p>\n<ol>\n<li>\n<p>分配设备</p>\n<p>根据用户请求的设备的物理名，查找系统设备表，从中找出该设备的设备控制表，检查设备控制表中的设备状态字。</p>\n</li>\n<li>\n<p>分配控制器</p>\n<p>若系统为进程分配了其请求的设备，就到该设备的控制表中找出与该设备连接的控制器的 COCT , 即设备控制器控制表，检查其中的状态字段。</p>\n</li>\n<li>\n<p>分配通道</p>\n<p>在有通道的系统中，还需要从相应的设备控制器控制表中找到与该控制器连接的通道控制表，检查表中的通道状态字段。</p>\n</li>\n</ol>\n<h4 id=\"645-spooling技术\"><a class=\"markdownIt-Anchor\" href=\"#645-spooling技术\">#</a> 6.4.5 SPOOLing 技术</h4>\n<p>​\t在联机情况下实现的同时外围操作成为 SPOOLing</p>\n<ol>\n<li>\n<p>SPOOLing 的组成</p>\n<ul>\n<li>\n<p>输入井和输出井（大量输入输出的缓存）</p>\n</li>\n<li>\n<p>输入缓冲区和输出换红曲（把井的数据存放缓冲区，再传给输出设备）</p>\n</li>\n<li>\n<p>输入进程和输出进程</p>\n</li>\n<li>\n<p>请求 I/O 队列</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082504.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082504.png\" class=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>利用 SPOOLing 技术实现共享打印机</p>\n<ol>\n<li>当用户进程提出打印请求时，SPOOLing 系统先为用户做下列两件事。\n<ol>\n<li>由输出<strong>进程</strong>在输出<strong>井</strong>中<strong>申请空闲盘块区</strong>，并将要打印的数据送入其中</li>\n<li>输出<strong>进程</strong>再<strong>为用户申请</strong>并填写一张<strong>用户请求打印表</strong>，将该表<strong>挂到请求打印队列</strong></li>\n</ol>\n</li>\n<li>打印机开始打印时\n<ol>\n<li>从队首取一张请求打印表</li>\n<li>将打印数据从井送到缓冲区</li>\n<li>打印</li>\n<li>完成</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>特点</p>\n<ol>\n<li>提高速度</li>\n<li>将独占设备改造成逻辑的共享设备</li>\n<li>实现了虚拟设备功能</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"65-io软件原理\"><a class=\"markdownIt-Anchor\" href=\"#65-io软件原理\">#</a> 6.5 I/O 软件原理</h3>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082505.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082505.png\" class=\"\"></p>\n<h4 id=\"651-设备管理软件的功能\"><a class=\"markdownIt-Anchor\" href=\"#651-设备管理软件的功能\">#</a> 6.5.1 设备管理软件的功能</h4>\n<ol>\n<li>实现 I/O 设备的独立性</li>\n<li>错误处理（先低层，解决不了就往上抛）</li>\n<li>异步传输</li>\n<li>缓冲管理</li>\n<li>设备的分配和释放</li>\n<li>实现 I/O 控制方式</li>\n</ol>\n<h4 id=\"652-中断处理程序\"><a class=\"markdownIt-Anchor\" href=\"#652-中断处理程序\">#</a> 6.5.2 中断处理程序</h4>\n<p>​\t作用：将发出 I/O 请求而被阻塞的进程唤醒</p>\n<h4 id=\"653-设备驱动程序\"><a class=\"markdownIt-Anchor\" href=\"#653-设备驱动程序\">#</a> 6.5.3 设备驱动程序</h4>\n<p>​\t是 VO 进程与设备控制器之间的通信程序。主要任务是<strong>接受上层软件发来的抽象的 I/O 请求</strong>。</p>\n<p>当有读第 n 块磁盘的请求时，磁盘驱动程序工作如下:</p>\n<ol>\n<li>计算出所请求块的物理地址。</li>\n<li>检查驱动器电机是否正在运转。</li>\n<li>检查磁头臂是否定位在正确的柱面。</li>\n<li>确定需要哪些控制器命令及命令的执行顺序。</li>\n<li>向设备控制器的设备寄存器中写入命令。</li>\n<li>I/O 完成后，向上层软件传送数据。</li>\n</ol>\n<h4 id=\"654-与硬件无关的io软件\"><a class=\"markdownIt-Anchor\" href=\"#654-与硬件无关的io软件\">#</a> 6.5.4 与硬件无关的 I/O 软件</h4>\n<ul>\n<li>设备无关 I/O 软件的功能如下:\n<ul>\n<li>设备命名：将设备名映射到相应的驱动程序</li>\n<li>设备保护：为设备设置合理的访问权限</li>\n<li>提供独立于设备的块大小</li>\n<li>为块设备和字符设备提供必要的缓冲技术</li>\n<li>块设备的存储分配</li>\n<li>分配和释放独立设备</li>\n<li>错误处理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"66-磁盘管理\"><a class=\"markdownIt-Anchor\" href=\"#66-磁盘管理\">#</a> 6.6 磁盘管理</h3>\n<p>重要目标：提高磁盘吕勇率和磁盘访问速度</p>\n<h4 id=\"661-磁盘结构\"><a class=\"markdownIt-Anchor\" href=\"#661-磁盘结构\">#</a> 6.6.1 磁盘结构</h4>\n<ol>\n<li>数据的组织和格式\n<ol>\n<li>磁盘设备包括一个或多个<strong>盘片</strong>，盘片又分一个或两个<strong>存储面</strong>，每个盘面被组织成若干个<strong>同心环</strong>，又称<strong>磁道</strong>每条磁盘存储相同数目的二进制位，磁盘密度是内层磁道大于外层。每条磁道又被划分成若干个<strong>扇区</strong>\n<ul>\n<li>一个扇区上存储一个物理记录。磁盘上存储的物理记录数目是由扇区数、磁道数及磁盘面数决定的</li>\n<li>每个扇区包括两个字段：标识符字段、数据字段</li>\n</ul>\n</li>\n<li>磁盘的类型\n<ol>\n<li>固定头磁盘\n<ul>\n<li>每条磁道上都有磁头，提高磁盘读写速度。用于大容量磁盘</li>\n</ul>\n</li>\n<li>移动头磁盘\n<ul>\n<li>每个盘面一个磁头，磁头可移动并寻道，速度较慢，结构简单，用于中小磁盘设备</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>磁盘的访问时间\n<ol>\n<li>寻道时间</li>\n<li>旋转延迟时间</li>\n<li>访问时间</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"662-磁盘调度\"><a class=\"markdownIt-Anchor\" href=\"#662-磁盘调度\">#</a> 6.6.2 磁盘调度</h4>\n<p>磁盘为多个进程共享，需采用一种最佳调度算法，<strong>使各进程对磁盘的平均访问时间最短</strong></p>\n<ol>\n<li>\n<p>先来先服务（FCFS）</p>\n<ul>\n<li>\n<p>最简单的磁盘调度算法，平均寻道时间较长，适用于进程数较少的场合</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082601.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082601.png\" class=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>最短寻道时间优先（SSTF）</p>\n<ul>\n<li>\n<p>要求访问的磁道与当前磁头所在的磁道距离最近。能使每次的寻道时间最短，单不能保证平均寻道时间</p>\n</li>\n<li>\n<p>缺点：可能导致某个进程发生 “饥饿” 现象（进来的进程总是离磁头较近）</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082602.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082602.png\" class=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>扫描算法（SCAN）算法</p>\n<ul>\n<li>\n<p>优先考虑磁头当前的移动方向（先往一边走，这边走完了再返回去走反方向）</p>\n</li>\n<li>\n<p>缺点：当磁头刚越过磁道 A，又来一个进程需要访问磁道 A，则需要等待很长时间</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082603.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082603.png\" class=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>循环扫描算法（CSCAN）</p>\n<ul>\n<li>\n<p>规定磁头只能单向移动，不能变更方向</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082604.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21082604.png\" class=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>NStepSCAN 和 FSCAN 算法</p>\n<p>​\t在前面几种算法中，可能会出现磁盘臂停留在某处、不动的情况。如有一个或多个进程对某一磁道有较高的访问频率，从而垄断了整个磁盘设备。把这一现象称为 “磁臂粘着”, 在高密度磁盘上容易出现此情况。</p>\n<ul>\n<li>\n<p>NStepSCAN 算法：</p>\n<p>将磁盘请求队列分成若干个子队列，依次去调度，新来的放到后面的队列，防止一直请求同一个磁道，避免磁臂粘着</p>\n</li>\n<li>\n<p>FSCAN 算法：</p>\n<p>是 NStepSCAN 的简化，之分成两个队列。一个当前处理，一个是扫描期间新出现的</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"663-提高磁盘io速度的方法\"><a class=\"markdownIt-Anchor\" href=\"#663-提高磁盘io速度的方法\">#</a> 6.6.3 提高磁盘 I/O 速度的方法</h4>\n<ol>\n<li>提前读</li>\n<li>延迟写\n<ul>\n<li>内存的东西不立刻丢，除非要使用才丢</li>\n</ul>\n</li>\n<li>优化物理块的分布\n<ul>\n<li>适当地集中数据在磁盘存放的位置，可以减少磁臂移动距离，提高效率。需采用优化文件物理块分布的方法</li>\n</ul>\n</li>\n<li>虚拟盘\n<ul>\n<li>用内存空间去仿真磁盘，又称 RAM 盘</li>\n</ul>\n</li>\n<li>磁盘高速缓冲\n<ul>\n<li>拿内存的一块存储空间暂存磁盘中的信息</li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "操作系统概论"
            ]
        }
    ]
}