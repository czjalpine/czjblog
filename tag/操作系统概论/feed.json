{
    "version": "https://jsonfeed.org/version/1",
    "title": "失心耀的博客 • All posts by \"操作系统概论\" tag",
    "description": "",
    "home_page_url": "https://xinyao_idiot.gitee.io/zxy",
    "items": [
        {
            "id": "https://xinyao_idiot.gitee.io/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/",
            "url": "https://xinyao_idiot.gitee.io/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/",
            "title": "操作系统概论",
            "date_published": "2021-08-11T10:27:00.000Z",
            "content_html": "<h1 id=\"操作系统概论\"><a class=\"markdownIt-Anchor\" href=\"#操作系统概论\">#</a> 操作系统概论</h1>\n<h2 id=\"考试题型\"><a class=\"markdownIt-Anchor\" href=\"#考试题型\">#</a> 考试题型</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">题型</th>\n<th style=\"text-align:center\">数量</th>\n<th style=\"text-align:center\">分支</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">单选</td>\n<td style=\"text-align:center\">1 分 * 20</td>\n<td style=\"text-align:center\">20 分</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">填空</td>\n<td style=\"text-align:center\">2 分 * 10</td>\n<td style=\"text-align:center\">20 分</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">简答</td>\n<td style=\"text-align:center\">4 分 * 5</td>\n<td style=\"text-align:center\">20 分</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">综合</td>\n<td style=\"text-align:center\">10 分 * 4</td>\n<td style=\"text-align:center\">40 分</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"第一章操作系统简介\"><a class=\"markdownIt-Anchor\" href=\"#第一章操作系统简介\">#</a> 第一章：操作系统简介</h2>\n<h3 id=\"11-什么是操作系统\"><a class=\"markdownIt-Anchor\" href=\"#11-什么是操作系统\">#</a> 1.1 什么是操作系统</h3>\n<ol>\n<li>\n<p>操作系统的定义</p>\n<p>操作系统（Operating System，OS）是一种复杂的<strong>系统软件</strong>，是不同于<strong>程序代码</strong>、<strong>数据结构</strong>、<strong>数据初始化文件的集合</strong>，可执行。（选择、填空、简答）</p>\n</li>\n<li>\n<p><strong>用户与硬件之间</strong>的接口</p>\n<p>操作系统与<strong>硬件部分相互作用</strong>，比并且为运行在计算机上的<strong>应用程序提供执行环境</strong>。（选择、填空）</p>\n</li>\n<li>\n<p>资源的管理者</p>\n<ul>\n<li>\n<p><strong>处理机管理</strong></p>\n<p>定义：决定把处理机先给哪个程序用，后给哪个程序用</p>\n</li>\n<li>\n<p><strong>内存管理</strong></p>\n<p>定义：给程序分配内存空间</p>\n</li>\n<li>\n<p><strong>设备管理</strong></p>\n<p>定义：完成证明分配设备，分配哪台设备，怎么和设备连接等</p>\n</li>\n<li>\n<p><strong>文件管理</strong></p>\n<p>定义：为每个文件分配空间、建立目录、对目录进行组织管理以及根据用户请求从外存（硬盘）读取数据或将数据写入外存（硬盘）</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"12-操作系统的发展\"><a class=\"markdownIt-Anchor\" href=\"#12-操作系统的发展\">#</a> 1.2 操作系统的发展</h3>\n<ol>\n<li>\n<p>发展历程</p>\n<ul>\n<li>\n<p><strong>单道 批处理系统</strong></p>\n<ul>\n<li>定义：单道批处理系统<strong>内存中只有一道作业</strong></li>\n<li>特点：<strong>自动性、顺序性、单道性</strong>（选择、填空）</li>\n<li>优点：减少了等待人工操作的时间</li>\n<li>缺点：CPU 资源不能得到充分的利用</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080901.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080901.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>多道 批处理系统</strong></p>\n<ul>\n<li>定义：由操作系统的<strong>作业调度程序按一定策略</strong>从后备作业队列中<strong>选择若干个作业调入内存</strong>，使他们共享 CPU 和系统中的各种资源</li>\n<li>特点：<strong>多道性、无序性、调度性、复杂性</strong>（选择、填空）</li>\n<li>优点：能够提高 CPU、内存和 IO 设备的利用率和系统的吞吐量（选择、简答）</li>\n<li>缺点：系统平均周转时间长（选择、简答）</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080902.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080902.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>分时 操作系统</strong></p>\n<ul>\n<li>定义：允许<strong>多个用户</strong>通过终端机<strong>同时使用</strong>计算机，每个用户通过终端与主机交互时都能得到快速响应。</li>\n<li>特点：<strong>多路性、独立性、及时性、交互性</strong>（选择、填空）</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080903.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080903.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>实时 操作系统</strong></p>\n<ul>\n<li>定义：实时系统必须<strong>及时响应</strong>外部时间的请求，在规定时间内完成对该事件的处理。主要用于<strong>实时控制</strong>和<strong>实时信息处理</strong>领域。（选择、填空）</li>\n<li>特点：<strong>多路性、独立性、及时性、交互性、可靠性</strong>（选择、填空）</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080904.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080904.png\" class=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>操作系统产品现状（可略）</p>\n<table>\n<thead>\n<tr>\n<th>操作系统</th>\n<th>运行主体</th>\n<th>实例（了解即可）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>主机</strong>操作系统</td>\n<td>大型主机</td>\n<td>IBM 的 OS / 360、OS / 390</td>\n</tr>\n<tr>\n<td><strong>服务器</strong>操作系统</td>\n<td>网络服务器</td>\n<td>Linux、Windows Server</td>\n</tr>\n<tr>\n<td><strong>微机</strong>操作系统</td>\n<td>微型计算机</td>\n<td>Windows7、Mac OS</td>\n</tr>\n<tr>\n<td><strong>嵌入式</strong>操作系统</td>\n<td>嵌入式设备</td>\n<td>Android、iOS</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ol>\n<h3 id=\"13-操作系统特征\"><a class=\"markdownIt-Anchor\" href=\"#13-操作系统特征\">#</a> 1.3 操作系统特征</h3>\n<ul>\n<li>现在操作系统都支持<strong>多任务</strong>，具有<strong>并发</strong>、<strong>共享</strong>、<strong>虚拟</strong>和<strong>异步性</strong>特征。\n<ul>\n<li>并发：两个或多个事件在<strong>同一时间间隔</strong>内发生</li>\n<li>共享：系统中的<strong>资源</strong>可供内存中多个并发执行的<strong>进程共同使用</strong>。</li>\n<li>虚拟：最常用<strong>内存虚拟化</strong>，用户感觉到的内存大于实际内存。</li>\n<li>异步性：进程以<strong>不可预知的速度</strong>向前推进。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"14-操作系统的功能\"><a class=\"markdownIt-Anchor\" href=\"#14-操作系统的功能\">#</a> 1.4 操作系统的功能</h3>\n<ol>\n<li>\n<p>管理计算机资源</p>\n<ul>\n<li>\n<p>内存管理</p>\n<ul>\n<li>\n<p>含义：</p>\n<p>内存管理的主要任务是为<strong>多道程序的运行提供良好的环境</strong>，方便用户<strong>使用内存</strong>，提高内存的利用率，以及从<strong>逻辑上扩充内存</strong>以实现<strong>虚拟存储</strong>。</p>\n</li>\n<li>\n<p>内容：</p>\n<ol>\n<li>\n<p>内存分配</p>\n<p>主要任务是<strong>为每道程序分配内存空间</strong>，可采用两种分配方式，即<strong>静态分配方式</strong>和<strong>动态分配方式</strong>。</p>\n<ul>\n<li>静态分配方式\n<ul>\n<li>先把内存划分先把内存划分定的区域</li>\n<li>大小数量不再变化</li>\n</ul>\n</li>\n<li>动态分配方式\n<ul>\n<li>根据进程实际，请求分配内存</li>\n<li>大小数量动态变化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>内存保护</p>\n<ol>\n<li>\n<p>主要任务：</p>\n<p>一是使操作系统<strong>内核的空间</strong>不会被用户随意访问，以保证系统的安全和稳定；</p>\n<p>二是确保<strong>每道用户程序</strong>都在<strong>自己的内存空间</strong>中运行，互不干扰。</p>\n</li>\n<li>\n<p>内存保护的方式：</p>\n<ol>\n<li>\n<p>采用界限寄存器存放允许程序访问的地址区间的上限和下限。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080905.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080905.png\" class=\"\"></p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>地址映射</p>\n<p><strong>含义：<strong>CPU 执行程序过程中访问内存时，需要把</strong>程序的逻辑地址转变为物理地址</strong>，这个转换过程称为<strong>地址映射</strong>。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080906.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080906.png\" class=\"\"></p>\n</li>\n<li>\n<p>内存扩充</p>\n<p><strong>含义：<strong>借助于</strong>虚拟技术</strong>，从<strong>逻辑</strong>上扩充内存容量，使系统能够向用户提供比物理内存大的存储容量。</p>\n<p>👉<strong>请求调入：</strong></p>\n<p>允许系统在<strong>装入一部分用户程序</strong>时就启动该程序运行，在程序运行过程中<strong>若发现要执行的指令或访问的数据尚未装入内存</strong>，通过<strong>请求调入将需要指令或数据装入内存。</strong></p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080907.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080907.png\" class=\"\"></p>\n<p>👉<strong>置换功能：</strong></p>\n<p>在请求调入时，<strong>若发现内存空间不足</strong>，需要<strong>先将内存中的一部分内容换到外存中</strong>，以便<strong>腾出内存空间</strong>装入当前需要的内容。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080908.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080908.png\" class=\"\"></p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>进程管理</p>\n<ul>\n<li>内容：进程的描述与组织、进程控制、进程同步、进程通信及进程调度。</li>\n</ul>\n</li>\n<li>\n<p>设备管理</p>\n<ul>\n<li>含义：设备管理主要完成用户的<strong> I/O 请求</strong>，为用户<strong>分配 I/O 设备</strong>。</li>\n<li>功能：\n<ol>\n<li><strong>缓冲管理</strong></li>\n<li><strong>设备分配</strong></li>\n<li><strong>设备处理</strong></li>\n<li><strong>设备独立性和虚拟设备</strong> (设备独立性功能使应用程序独<br>\n立于物理设备)</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>文件管理</p>\n<ul>\n<li>\n<p>功能：</p>\n<ol>\n<li>\n<p>文件存储空间的管理</p>\n<p>为每个文件分配必要的<strong>外存空间</strong>，<strong>提高外存利用率</strong>，并能有助于<strong>提高访问文件的速度</strong>。</p>\n</li>\n<li>\n<p>目录管理</p>\n<p>为每个文件建立<strong>目录项</strong>并对众多目录项进行有效组织。目录项包括文件名、文件属性及文件的地址等信息。</p>\n</li>\n<li>\n<p>文件的读、写管理和存取控制</p>\n<p>根据用户的请求，<strong>从外存中读取数据</strong>或<strong>将数据写入外存</strong>。防止未经审核的用户存取文件，防止冒名顶替存取文件，防止以不正确的方式使用文件。</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>提供用户接口</p>\n<ul>\n<li>命令接口\n<ul>\n<li>目的：为了便于用户与计算机系统的交互</li>\n<li>分类：联机用户接口和脱机用户接口</li>\n<li>联机：常命令接口由一组键盘操作命令和命令解释程序组成</li>\n<li>脱机：为批处理作业的用户提供，也称为批处理用户接口</li>\n</ul>\n</li>\n<li>图形用户接口\n<ul>\n<li>用户可以轻松地通过<strong>选择窗口、菜单、对话框、滚动条、图标等</strong>简单的操作来完成对作业和任务的提交与控制。</li>\n</ul>\n</li>\n<li>程序接口\n<ul>\n<li>用户程序接口指的是<strong>应用程序</strong>和系统的<strong>核心程序</strong>的接口，就是<strong>系统调用</strong>。</li>\n<li>系统调用是一组预先定义好的模块，它们提供<strong>一条管道</strong>让应用程序或用户能由此得到<strong>核心程</strong>序的服务。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"15-操作系统的体系结构\"><a class=\"markdownIt-Anchor\" href=\"#15-操作系统的体系结构\">#</a> 1.5 操作系统的体系结构</h3>\n<ol>\n<li>简单的监控程序模型\n<ul>\n<li>功能简陋，任意时刻系统中只能运行一个任务 ，保证了对系统信息的互斥访问，保护了系统数据的安全。</li>\n</ul>\n</li>\n<li>单体结构模型一\n<ul>\n<li>所有的软件和数据结构都放置在 - 个逻辑模块中，对外层的用户程序提供一个完整的内核界面 —— 系统调用。</li>\n</ul>\n</li>\n<li>层次结构模型\n<ul>\n<li>基本思想是将操作系统分解为多个小的，容易理解的层。系统功能被隔离在不同层中。</li>\n</ul>\n</li>\n<li>客户 / 服务器模型与微内核结构\n<ul>\n<li>核心思想是核心功能外移，即把传统操作系统内核中的一些组成部分放到内核之外作为 - 个独立的服务器进程来实现。</li>\n</ul>\n</li>\n<li>动态可扩展结构模型\n<ul>\n<li>基本思想就是在运行过程中，能够动态地实现系统行为扩展的结构，也可称之为弹性结构。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"16-指令的执行\"><a class=\"markdownIt-Anchor\" href=\"#16-指令的执行\">#</a> 1.6 指令的执行</h3>\n<ol>\n<li>\n<p><strong>指令周期</strong></p>\n<ul>\n<li><strong>程序是具有独立功能的一组指令的集合</strong>，程序的执行就是按照某种控制流执行指令的过程。</li>\n<li>一个<strong>单一指令</strong>需要的<strong>处理</strong>称为<strong>指令周期</strong>。</li>\n<li>一个指令周期可以划分为两个步骤，分别是<strong>取指周期</strong>和<strong>执行周期</strong>。</li>\n<li><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080909.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080909.png\" class=\"\"></li>\n<li>** 程序计数器 (PC)<strong> 保存有下一次要取的指令的地址。取到的指令被放置在处理器的</strong>指令寄存器 (IR)** 中。</li>\n</ul>\n</li>\n<li>\n<p><strong>取指令和执行指令</strong></p>\n<p>指令中包含确定处理器要采取动作的位，处理器解释指令并执行要求的动作。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080910.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080910.png\" class=\"\"></p>\n<p>👉动作分类：</p>\n<ul>\n<li><strong>处理器与存储器</strong>之间的<strong>指令或数据传送</strong>操作</li>\n<li><strong>处理器与 I/O 设备</strong>之间的<strong>指令或数据传送</strong>操作</li>\n<li><strong>算术运算</strong>操作或<strong>逻辑运算</strong>操作</li>\n<li><strong>控制</strong>操作，即<strong>修改指令的执行顺序</strong>的操作</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"第二章进程管理重点\"><a class=\"markdownIt-Anchor\" href=\"#第二章进程管理重点\">#</a> 第二章：进程管理（重点）</h2>\n<h3 id=\"21-进程的描述\"><a class=\"markdownIt-Anchor\" href=\"#21-进程的描述\">#</a> 2.1 进程的描述</h3>\n<h4 id=\"211程序的顺序执行与并发执行\"><a class=\"markdownIt-Anchor\" href=\"#211程序的顺序执行与并发执行\">#</a> 2.1.1 程序的顺序执行与并发执行</h4>\n<ol>\n<li>\n<p>顺序执行</p>\n<ul>\n<li>含义：先进入内存的程序先执行，在一个程序执行完毕之前，不能执行其他程序</li>\n<li>特点：<strong>顺序性、封闭性、可再现性</strong></li>\n</ul>\n</li>\n<li>\n<p>并发执行</p>\n<ul>\n<li>含义：程序并发执行是指<strong>同一时间间隔内</strong>运行多个程序。一个程序执行结束前，可以运行其他程序</li>\n<li>特点：<strong>间断性、失去封闭性、不可再现性</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>宏观并行</strong>：用户看到多个程序同时向前推进</p>\n<p><strong>微观串行</strong>：任意时刻<strong>一个 CPU</strong> 上只有<strong>一个程序</strong>在执行</p>\n</li>\n</ol>\n<h4 id=\"212进程的概念\"><a class=\"markdownIt-Anchor\" href=\"#212进程的概念\">#</a> 2.1.2 进程的概念</h4>\n<ul>\n<li>\n<p>定义：</p>\n<ul>\n<li>\n<p>进程是允许并发执行的<strong>程序</strong>在某个数据集合上的<strong>运行过程</strong></p>\n</li>\n<li>\n<p>进程是由<strong>正文段、用户数据段及进程控制块</strong>共同组成的执行环境</p>\n<table>\n<thead>\n<tr>\n<th>正文段</th>\n<th>存放被执行的机器指令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>用户数据段</strong></td>\n<td><strong>存放用户数据</strong></td>\n</tr>\n<tr>\n<td><strong>进程控制块</strong></td>\n<td><strong>存放进程的运行环境</strong></td>\n</tr>\n</tbody>\n</table>\n</li>\n</ul>\n</li>\n<li>\n<p>特征：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特征</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">并发性</td>\n<td style=\"text-align:center\">多个进程实体能在一 - 段时间间隔内同时运行<br /><strong>并发性是进程和现代操作系统的重要特征</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">动态性</td>\n<td style=\"text-align:center\">进程是实体的执行过程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">独立性</td>\n<td style=\"text-align:center\">独立运行和资源调度的基本单位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">异步性</td>\n<td style=\"text-align:center\">进程的执行时断时续 ，何时执行、何时暂停都无法预知</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">结构特征</td>\n<td style=\"text-align:center\">进程实体包括用户<strong>正文段、 用户数据段</strong>和<strong>进程控制块</strong></td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>进程与程序的比较：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">程序</th>\n<th style=\"text-align:center\">进程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">动态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">永久</td>\n<td style=\"text-align:center\">暂时</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">指令集合</td>\n<td style=\"text-align:center\">包括正文段、用户数据段、进程控制块</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>进程和程序的联系</p>\n<ol>\n<li>进程是程序的一次执行</li>\n<li>一个程序可以对应多个进程</li>\n<li>同一个程序可以在不同的数据集合上运行，构成不同的进程</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"213-进程控制块pcb\"><a class=\"markdownIt-Anchor\" href=\"#213-进程控制块pcb\">#</a> 2.1.3 进程控制块（PCB）</h4>\n<ul>\n<li>进程实体包括用户正文段、用户数据段和进程控制段</li>\n<li>含义：进程控制块是进程实体的一部分，是操作系统中最重要的数据结构。<strong>记录</strong>了操作系统所需要的、用于<strong>描述进程</strong>及<strong>控制进程</strong>运行所需的<strong>全部信息</strong></li>\n<li>包含的信息\n<ol>\n<li>进程标识符信息：用于唯一标识一个进程</li>\n<li>处理机状态信息\n<ol>\n<li>通用寄存器</li>\n<li>指令计数器</li>\n<li>程序状态字 PSW</li>\n<li>用户栈指针</li>\n</ol>\n</li>\n<li>进程调度信息：包括进程状态信息、进程优先级和进程调度所需的其他信息</li>\n<li>进程控制信息：包括程序和数据的地址、进程同步和通信机制、资源清单、以及链接指针</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"214-进程的状态\"><a class=\"markdownIt-Anchor\" href=\"#214-进程的状态\">#</a> 2.1.4 进程的状态</h4>\n<ul>\n<li>就绪态</li>\n<li>执行态</li>\n<li>阻塞态</li>\n</ul>\n<h4 id=\"215-进程的组织\"><a class=\"markdownIt-Anchor\" href=\"#215-进程的组织\">#</a> 2.1.5 进程的组织</h4>\n<ol>\n<li>\n<p>链接方式</p>\n<ul>\n<li>把系统中具有<strong>相同状态</strong>的进程控制块 PCB 用其中的<strong>链接字</strong>连成一个对联</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081101.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081101.png\" class=\"\"></p>\n</li>\n<li>\n<p>索引方式</p>\n<ul>\n<li>系统根据所有进程的状态，建立索引表，索引表的每 - 一个表项指向一个 PCB 物理块</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081102.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081102.png\" class=\"\"></p>\n</li>\n<li>\n<p>进程队列</p>\n<ul>\n<li>把具有相同状态的进程控制块用队列组织起来</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081103.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081103.png\" class=\"\"></p>\n</li>\n</ol>\n<h3 id=\"22-进程的控制\"><a class=\"markdownIt-Anchor\" href=\"#22-进程的控制\">#</a> 2.2 进程的控制</h3>\n<h4 id=\"221-创建\"><a class=\"markdownIt-Anchor\" href=\"#221-创建\">#</a> 2.2.1 <strong>创建</strong></h4>\n<ul>\n<li>\n<p>什么情况下需要创建新进程呢？</p>\n<p>用户登录\t作业调度\t提供服务\t应用请求</p>\n</li>\n<li>\n<p>如何创建新进程？ /  创建新进程的步骤？</p>\n<ol>\n<li><strong>申请空白 PCB</strong></li>\n<li><strong>为新进程分配资源</strong></li>\n<li><strong>初始化进程控制块</strong></li>\n<li><strong>将新进程插入到就绪队列</strong></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"222-阻塞\"><a class=\"markdownIt-Anchor\" href=\"#222-阻塞\">#</a> 2.2.2 <strong>阻塞</strong></h4>\n<ul>\n<li>\n<p>什么情况下会进行进程的阻塞？</p>\n<p>请求系统服务\t启动某种操作\t新数据尚未达到\t无心工作可做</p>\n</li>\n<li>\n<p>完整进程阻塞的过程？</p>\n<ol>\n<li><strong>将进程的状态改为阻塞态</strong></li>\n<li><strong>将进程插入响应的阻塞队列</strong></li>\n<li><strong>转到进程调度程序，从就绪队列中选择进程为分配 CPU</strong></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"223-唤醒\"><a class=\"markdownIt-Anchor\" href=\"#223-唤醒\">#</a> 2.2.3 <strong>唤醒</strong></h4>\n<ul>\n<li>进程唤醒的过程？\n<ol>\n<li><strong>将进程从阻塞队列中移出</strong></li>\n<li><strong>将进程状态由阻塞状态改为就绪态</strong></li>\n<li><strong>将进程插入就绪队列</strong></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"224-终止\"><a class=\"markdownIt-Anchor\" href=\"#224-终止\">#</a> 2.2.4 <strong>终止</strong></h4>\n<ul>\n<li>完成进程终止的过程\n<ol>\n<li><strong>从进程 PCB 中读取进程状态</strong></li>\n<li><strong>若进程正在执行，则终止进程的执行</strong></li>\n<li><strong>释放资源</strong></li>\n<li><strong>将终止进程的 PCB 移出</strong></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"23-操作系统内核\"><a class=\"markdownIt-Anchor\" href=\"#23-操作系统内核\">#</a> 2.3 操作系统内核</h3>\n<p>​\t操作系统内核是计算机<strong>硬件的第一次扩充</strong>，与硬件关系密切</p>\n<h4 id=\"231-操作系统内核\"><a class=\"markdownIt-Anchor\" href=\"#231-操作系统内核\">#</a> 2.3.1 操作系统内核</h4>\n<ol>\n<li><strong>支撑功能</strong>：中断处理、始终管理、原语操作（原语操作也称原子操作，是一组在执行过程中不能被中断的操作。）</li>\n<li><strong>资源管理功能</strong>：进程管理、存储管理、设备管理</li>\n</ol>\n<h4 id=\"232-中断\"><a class=\"markdownIt-Anchor\" href=\"#232-中断\">#</a> 2.3.2 中断</h4>\n<ul>\n<li>\n<p>什么是中断 ？</p>\n<p>中断是<strong>改变</strong>处理器执行指令顺序的一种<strong>事件</strong>。出现中断时，计算机停止现在程序的运行，转向<strong>对这些中断事件的处理</strong>，处理结束后再<strong>返回到现行程序的间断处</strong></p>\n</li>\n<li>\n<p>为什么需要中断 ？</p>\n<p>引入中断机制后， <strong>CPU 可以与其他设备并行工作</strong>，能有效<strong>提高 CPU 的利用率</strong></p>\n</li>\n<li>\n<p>单重中断处理</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081104.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081104.png\" class=\"\"></p>\n</li>\n</ul>\n<h4 id=\"233-时钟管理\"><a class=\"markdownIt-Anchor\" href=\"#233-时钟管理\">#</a> 2.3.3 时钟管理</h4>\n<p>时钟是计算机系统的脉搏，计算机的很多活动都是由定时测量来驱动的</p>\n<ul>\n<li>\n<p>计算机系统中的时钟</p>\n<ol>\n<li>实时时钟 RTC（CMOS）</li>\n<li>OS 时钟</li>\n</ol>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081105.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081105.png\" class=\"\"></p>\n</li>\n<li>\n<p>时钟机制</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081106.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081106.png\" class=\"\"></p>\n</li>\n<li>\n<p>时钟程序功能</p>\n<ol>\n<li>维护日期和时间</li>\n<li>递减当前进程在一个时间片内的剩余执行时间，防止运行超时</li>\n<li>对 CPU 的使用情况记账</li>\n<li>递减报警计数器</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"234-系统调用\"><a class=\"markdownIt-Anchor\" href=\"#234-系统调用\">#</a> 2.3.4 系统调用</h4>\n<ul>\n<li>\n<p>什么是系统调用？</p>\n<p>系统调用是（一群）<strong>预先定义好的模块</strong>，提供<strong>一条管道</strong>让应用程序能由此到<strong>核心程序</strong>的服务。系统调用是<strong>系统程序</strong>与<strong>用户程序</strong>之间的<strong>接口</strong></p>\n</li>\n<li>\n<p>系统调用和一般函数调用的区别？</p>\n<p>区别 1: 系统调用运行在<strong>系统态</strong>，一般函数运行在<strong>用户态</strong></p>\n<p>区别 2:<strong> 执行过程不同</strong> (系统调用执行时，当前进程被中断)</p>\n<p>区别 3: 系统调用进行中断处理，多了<strong>系统开销</strong></p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081107.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081107.png\" class=\"\"></p>\n</li>\n<li>\n<p>系统调用的类型</p>\n<ol>\n<li><strong>进程控制类</strong>系统调用。创建、撤销进程；获得、改变进程属性。</li>\n<li><strong>文件操作类</strong>系统调用。创建、删除、打开、关闭和读 / 写文件。</li>\n<li><strong>设备管理类</strong>系统调用。请求、释放设备。</li>\n<li><strong>通信类</strong>系统调用。打开、关闭链接，交换信息。</li>\n<li><strong>信息维护类</strong>系统调用。返回系统当前日期、时间、版本号、用户数、空闲内存和磁盘空间大小等信息。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"24-进程同步\"><a class=\"markdownIt-Anchor\" href=\"#24-进程同步\">#</a> 2.4 进程同步</h3>\n<p>操作系统同步机制的<strong>主要任务</strong>就是要<strong>保证</strong>在多任务共享系统资源的情况下，<strong>程序执行能得到正确的结果</strong>。</p>\n<h4 id=\"241-进程同步的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#241-进程同步的基本概念\">#</a> 2.4.1 进程同步的基本概念</h4>\n<ol>\n<li>\n<p>两个任务</p>\n<ul>\n<li>一是<strong>对具有资源共享关系的进程</strong>，保证诸进程以<strong>互斥</strong>的方式<strong>访问临界资源</strong>。<strong>临界资源是必须以互斥方式访问的共享资源</strong>。</li>\n<li>二是对具有相互合作关系的进程，保证相互合作的诸进程协调执行。相互合作的进程可能同时存在资源共享的关系。</li>\n</ul>\n</li>\n<li>\n<p><strong>并发问题的解决</strong></p>\n<ul>\n<li>\n<p>如果 PIN 和 POUT<strong> 互斥</strong>地访问 count ，<strong>即 PIN 访问 count 时， POUT 就必须等待 PIN 对 count 的访问完全结束，再开始对 count 的访问</strong>，反之亦然。这样就不会出现计算结果的错误了。</p>\n<p>像 count 这样必须以<strong>互斥方式访问</strong>的<strong>共享资源</strong>称为<strong>临界资源</strong>。</p>\n</li>\n<li>\n<p>这里采用临界区<strong>加锁</strong>的方法，在临界区前加入<strong>进入区代码</strong>，在临界区之后加<strong>退出区代码</strong>来实现</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"242-同步机制应遵循的准则\"><a class=\"markdownIt-Anchor\" href=\"#242-同步机制应遵循的准则\">#</a> 2.4.2 同步机制应遵循的准则</h4>\n<p>同步机制应遵循的准则可以提供判断、选择和评价同步技术的参考依据。</p>\n<ol>\n<li>\n<p><strong>空闲让进</strong></p>\n<p><strong>当没有进程处于临界区时</strong>，表明临界资源处于空闲状态，应<strong>允许一个</strong>请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。</p>\n</li>\n<li>\n<p><strong>忙则等待</strong></p>\n<p>当己有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。</p>\n</li>\n<li>\n<p><strong>有限等待</strong></p>\n<p>对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免进程陷入无限等待的状态。</p>\n</li>\n<li>\n<p><strong>让权等待</strong></p>\n<p><strong>当进程申请不到共享资源的访问权时，应立即释放处理机</strong>，以兔进程陷入 “忙等” 状态，浪费 CPU 资源</p>\n</li>\n</ol>\n<h4 id=\"243-信号量机制\"><a class=\"markdownIt-Anchor\" href=\"#243-信号量机制\">#</a> 2.4.3 信号量机制</h4>\n<p>​\t在信号量机制中，用<strong>信号量的取值</strong>来表示资源的使用状况，或某种事件是否发生，以此为基础实现进程的同步。</p>\n<p>​\t对不同的共享资源设置被称为信号量的变量，<strong>用信号量的取值来表示资源的使用状况</strong>，或某种事件是否发生。</p>\n<p>​\t通过信号量的取值来判断进程是否能访问与信号量对应的共享资源。</p>\n<ol>\n<li>\n<p><strong>整形信号量机制</strong></p>\n<p><strong>如果整型量 &gt; 0，说明有可用资源；如果整型量≤0，说明资源忙，进程必须等待。</strong></p>\n<p>对于<strong>一次只允许一个进程访问</strong>的临界资源，可定义一个用于<strong>互斥</strong>的整型信号量，并将其<strong>初始化为 1</strong>。</p>\n<ol>\n<li>\n<p>具体操作</p>\n<p>整型信号量的值只能通过两个特定的原子操作 wait 和 signal 来改变</p>\n<p>wait 和 signal 操作</p>\n<pre><code class=\"language-伪代码\">wait(s) //用于申请资源\n&#123;\n    while s&lt;=0 do no-op;// s &lt;= 0时循环执行空操作\n    s=s-1;\n&#125;\n\nsignal(s) //用于释放资源\n&#123;\n    s=s+1;\n&#125;\n</code></pre>\n</li>\n<li>\n<p>总结</p>\n<ol>\n<li>整型信号量的值只能由 wait 和 siqnal 操作改变。</li>\n<li>wait 和 signal 操作都是<strong>原子操作</strong>，即这两个操作中对信号量的访问<strong>不能被中断</strong>。</li>\n<li>原子操作可以通过关中断来实现。</li>\n<li><strong>不同的资源对应不同的信号量，并不是系统中所有的资源都用同一个信号量表示</strong>。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>记录型信号量</strong></p>\n<ul>\n<li>优点：是不存在 “忙等” 采取了” 让权等待” 的策略</li>\n</ul>\n</li>\n<li>\n<p><strong>AND 型信号量机制</strong></p>\n<ol>\n<li>基本思想是将进程在整个运行过程中所需要的所有资源一次性地全部分配给进程，待该进程使用完后再一起释放。只要还有一个资源不能分配给该进程，其他所有可能为之分配的资源也不分配给它。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"244-经典的进程同步问题\"><a class=\"markdownIt-Anchor\" href=\"#244-经典的进程同步问题\">#</a> 2.4.4 经典的进程同步问题</h4>\n<ol>\n<li>\n<p>生产者一 消费者问题描述</p>\n<ul>\n<li>\n<p>问题描述</p>\n<ul>\n<li>生产者进程生产消息，并将消息提供给消费者进程消费。在生产者进程和消费者进程之间设置了一个具有 n 个缓冲区的缓冲池，生产者进程可以将它所产生的消息放入缓冲池的一个缓冲区中，消费者进程可以从一个缓冲区中取得一个消息消费。</li>\n<li>任意两个进程必须以互斥的方式访问公共缓冲池。当缓冲池空，没有可供消费的消息时，消费者进程必须阻塞等待。当缓冲池装满消息，没有空闲缓冲区时，生产者进程必须阻塞等待。</li>\n</ul>\n</li>\n<li>\n<p>需要解决的问题</p>\n<ul>\n<li>实现任意两个进程对缓冲池的互斥访问。</li>\n<li>实现对生产者进程和消费者进程的 “协调”</li>\n<li>即缓冲池中有消息时消费者进程才能执行取消息的操作。无消息时，阻塞消费者进程。缓冲池中有空闲缓冲区时，生产者进程才能执行放消息的操作。无空闲缓冲区时，阻塞生产者进程。</li>\n</ul>\n</li>\n<li>\n<p>信号量的设置</p>\n<ul>\n<li>设置一个互斥信号量 mulex ，用于实现对公共缓冲池的互斥访问，初值为 1。</li>\n<li>设置两个资源信号量，分别表示可用资源数。empty : 表示缓冲池中的空缓冲区数，初值为 n。full : 表示装有消息的缓冲区数，初值为 0 (一个缓冲区中放一个消息)。</li>\n</ul>\n</li>\n<li>\n<p>同步程序</p>\n<ul>\n<li>利用记录型信号量机制实现生产者 —— 消费者问题的同步代码如下:</li>\n</ul>\n</li>\n<li>\n<p>生产者进程同步代码</p>\n<pre><code class=\"language-伪代码\">Producer:\nbegin\nrepeat\n...\nproduce an item in nextp;\nwait(empty);//申请空缓冲区\nwait(mutex);//申请公共缓冲池的互斥访问权\nbuffer(in)=nextp; //将消息放入in指针指向的缓冲区\nin=(in+ 1) mod n; //in指针指向下一个空缓冲区\nsignal(mutex); //释放对公共缓冲池的互斥访问权\nsignal(full); //释放消息资源\nuntil false\nend\n</code></pre>\n</li>\n<li>\n<p>消费者进程同步代码</p>\n<pre><code class=\"language-伪代码\">Consumer:\nbegin \nrepeat\n...\nwait(ull); //申请消息\nwait(mutex); //申请公共缓冲池的互斥访问权\nnextc= buffer(out); //从out指针指向的缓冲区中取消息\nout=(out+ 1) mod h; //out指针指向下一个装有消息的缓冲区\nsignal(mutex); //释放对公共缓冲池的互斥访问权\nsignal(empty); //释放空缓冲区\nconsume item in nextc ;\nuntil false\nend\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"245-管程\"><a class=\"markdownIt-Anchor\" href=\"#245-管程\">#</a> 2.4.5 管程</h4>\n<ol>\n<li>\n<p>管程的定义</p>\n<p>管程是描述共享资源的数据结构和在数据结构上的共享资源管理程序的集合。其中包括变量的定义、变量的初始化代码，以及管理共享资源的过程。</p>\n</li>\n<li>\n<p>对管程的说明</p>\n<ul>\n<li><strong>管程是可供程序员调用的软件包</strong>，是一个由过程、变量及数据结构等组成的集合，它们组成一个特殊的模块或软件包。<strong>进程可以在任何需要的时候调用管程中的过程</strong>，但不能在管程外的过程中直接访问管程内的数据结构。</li>\n<li>每次只有一个进程调用管程执行，任意时刻管程中只能有一个活跃进程。</li>\n<li>管程是一种编程语言的构件</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"25-进程通信\"><a class=\"markdownIt-Anchor\" href=\"#25-进程通信\">#</a> 2.5 进程通信</h3>\n<p>​\t操作系统提供进程通信功能，以支持进程之间的信息交换。</p>\n<h4 id=\"251-共享存储器系统\"><a class=\"markdownIt-Anchor\" href=\"#251-共享存储器系统\">#</a> 2.5.1 共享存储器系统</h4>\n<p>​\t在共享存储器系统中，<strong>相互通信的进程共享某些数据结构或共享存储区</strong>，进程之间能够通过这些空间进行通信。共享存储器系统可分为两种类型。</p>\n<ol>\n<li>基于<strong>共享数据结构</strong>的通信方式。要求诸进程公用某些数据结构，以实现进程间的信息交换。</li>\n<li>基于<strong>共享存储区</strong>的通信方式。进程通过对共享存储区中的数据的读或写来实现通信。</li>\n</ol>\n<h4 id=\"252-消息传递系统\"><a class=\"markdownIt-Anchor\" href=\"#252-消息传递系统\">#</a> 2.5.2 消息传递系统</h4>\n<p>​\t进程间通过<strong>操作系统提供的一组通信程序</strong>传递格式化的信息。这种方式对应用程序隐藏了通信实现的细节使通信过程对用户是透明的。根据传递消息方式的不同，分为直接通信方式和间接通信方式。</p>\n<ol>\n<li><strong>直接通信方式</strong>。操作系统利用发送程序<strong>直接</strong>把消息发送给目标程序。</li>\n<li><strong>间接通信方式</strong>。进程之间的通信需要通过用于<strong>暂存</strong>消息的共享数据结构来实现，如信箱。该方式可以实现实时通信，又可以实现非实时通信。</li>\n</ol>\n<h4 id=\"253-管道\"><a class=\"markdownIt-Anchor\" href=\"#253-管道\">#</a> 2.5.3 管道</h4>\n<p>​\t<strong>管道</strong>是连接读写进程的<strong>一个特殊文件</strong>，也被称为管道文件。管道文件存在于<strong>外存</strong>中，其中的消息没有固定长度，能用于进程间大量的信息通信。向管道提供输入的发送进程以<strong>字符流</strong>的形式将大量的数据送入管道。接受管道输出的接收进程，从管道中接收数据。</p>\n<h4 id=\"254-消息缓冲队列\"><a class=\"markdownIt-Anchor\" href=\"#254-消息缓冲队列\">#</a> 2.5.4 消息缓冲队列</h4>\n<p>​\t用于本地进程之间的通信，包括<strong>数据结构、发送原语和接收原语</strong>。</p>\n<p>​\t发送进程<strong>发送消息</strong>时，先<strong>申请一个消息缓冲区</strong>，将要发送的消息<strong>从发送进程的发送区放入消息</strong></p>\n<p><strong>缓冲区</strong>。然后，<strong>调用发送原语</strong>将消息<strong>发送给接收进程</strong>，发送原语将发送缓冲区插入接收进程的消</p>\n<p>息缓冲队列。</p>\n<p>​\t接收消息的进程<strong>通过调用接收原语</strong>将该进程消息缓冲队列中的消息复制到自己的消息接收区。</p>\n<p>​\t消息缓冲区是一个结构型数据结构。</p>\n<p>​\t消息缓冲队列需要被当作<strong>临界资源</strong>，在发送原语和接收原语中<strong>对消息缓冲队列的访问</strong>需要<strong>进行互斥与同步</strong></p>\n<h3 id=\"26-线程\"><a class=\"markdownIt-Anchor\" href=\"#26-线程\">#</a> 2.6 线程</h3>\n<h4 id=\"261-线程的描述\"><a class=\"markdownIt-Anchor\" href=\"#261-线程的描述\">#</a> 2.6.1 线程的描述</h4>\n<p>​\t<strong>为了进一步提高程序的并发性 ，减少系统开销，在操作系统中引入了线程的概念</strong>。</p>\n<p>​\t引入线程作为独立调度和分派的单位，<strong>不独立拥有资源，而与其他线程共享同一进程的资源</strong>，减少了系统的时空开销。</p>\n<p>​\t<strong>线程的实质是把进程的任务划分成更小，具有独立功能的单位</strong>，以线程的形式来并发执行，以提高程序并发执行的程度。</p>\n<ol>\n<li>\n<p>线程的概念</p>\n<p><strong>线程是进程中的一个实体</strong>，是被系统独立调度和分派的基本单位。<strong>一个线程可以创建和撤销另一个线程。同一进程中的多个线程可以并发执行。</strong></p>\n</li>\n<li>\n<p>线程的分类</p>\n<p>用户级线程和内核级线程。</p>\n</li>\n<li>\n<p>线程的三种基本状态</p>\n<p>就绪、运行和阻塞。</p>\n<p>就绪态是线程一 - 旦获得 CPU 就可以投入运行的状态。</p>\n<p>运行态是线程获得 CPU 正在运行的状态。</p>\n<p>阻塞态是线程由于等待某个事件的发生而暂停执行的状态。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081108.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081108.png\" class=\"\"></p>\n</li>\n<li>\n<p>线程控制块（TCB）</p>\n<p>每个线程都由一个数据结构表示，包括它的<strong>基本状态、标识及记账信息</strong>，这个数据结构就是<strong>线程控制块</strong>。</p>\n<p>线程控制块记录了操作系统所需的，用于描述线程情况及控制线程运行所需的全部信息。</p>\n<p>线程控制块采用<strong>链接</strong>方式来组织，把<strong>同一进程中具有相同状态的 TCB 用指针链接成列</strong>。</p>\n</li>\n<li>\n<p>线程与进程的关系</p>\n<ol>\n<li><strong>资源和调度</strong>。<strong>线程是程序执行的基本单位，进程是拥有资源的基本单位。</strong></li>\n<li><strong>地址空间资源</strong>。<strong>不同进程的地址空间是相互独立的，而同一进程中的各线程共享同一地址空间。</strong></li>\n<li><strong>通信关系</strong>。进程之间的通信必须使用操作系统提供的进程间通信机制，而同一进程中的各线程间可以<strong>通过直接读或写全局变量</strong>来进行通信，甚至无需操作系统的参与。</li>\n<li><strong>并发性</strong>。多进程之间可以并发执行，多线程之间也可以并发执行，同 - 进程中的多个线程之间也可以并发执行。</li>\n<li><strong>系统开销</strong>。创建或撤销进程时，系统都要为之分配或回收资源，系统开销大。</li>\n<li><strong>本人说明：可以理解为线程是 java 的线程，进程是 windows 的一个软件</strong></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"262-线程的控制\"><a class=\"markdownIt-Anchor\" href=\"#262-线程的控制\">#</a> 2.6.2 线程的控制</h4>\n<p>​\t线程控制包括创建新线程、终止线程、线程调度和线程切换，以及线程由于等待某个事件的发生而被阻塞与该事件发生后线程被唤醒。</p>\n<p>​\t<strong>用户线程的创建通过调用线程库中的实用程序完成。</strong></p>\n<p>​\t<strong>内核线程的创建由内核完成。</strong></p>\n<p>​\t如果进程中一个用户线程被阻塞，则整个进程必须等待。</p>\n<p>​\t当被阻塞的线程所等待的事件发生时，则由有关进程唤醒原语<strong>将该线程所属的进程唤醒，然后由有关线程唤醒原语将该线程唤醒</strong></p>\n<p>​\t如果进程中的一个内核线程被阻塞，内核可以调度同一个进程中的另一个内核线程运行。</p>\n<p>​\t<strong>一个进程中的所有线程共享同一个地址空间</strong>和诸如打开的文件之类的其他资源。</p>\n<p>​\t<strong>一个线程对资源的任何修改都会影响同一个进程中其他线程的环境。</strong></p>\n<p>​\t<strong>同一进程中线程间共享内存和文件资源</strong>，各线程间可通过<strong>直接读写全局变量</strong>进行通信。</p>\n<p>​\t对于<strong>不同进程的线程间</strong>通信，则必须<strong>使用操作系统提供的线程间</strong>通信机制。</p>\n<hr>\n<h2 id=\"第三章进程调度与死锁重点\"><a class=\"markdownIt-Anchor\" href=\"#第三章进程调度与死锁重点\">#</a> 第三章：进程调度与死锁（重点）</h2>\n<h3 id=\"本章考试重点\"><a class=\"markdownIt-Anchor\" href=\"#本章考试重点\">#</a> 本章考试重点</h3>\n<ul>\n<li>进程调度\n<ul>\n<li>进程调度算法（选择、填空、简答、综合)</li>\n<li>实时系统中的调度概念及算法 (选择、填空、简答、综合)</li>\n<li>进程切换 (选择、填空、简答)</li>\n<li>多处理器调度 (选择、填空、简答)</li>\n</ul>\n</li>\n<li>死锁\n<ul>\n<li>死锁产生的原因、必要条件 (选择、填空、简答</li>\n<li>死锁的预防和避免 (选择、填空、简答)</li>\n<li>银行家算法 (选择、填空、简答、综合)</li>\n<li>死锁的检测和解除 (选择、填空、简答)</li>\n</ul>\n</li>\n<li>近三年分值分布: 21~ 26 分</li>\n</ul>\n<h3 id=\"31-进程调度的功能与时机\"><a class=\"markdownIt-Anchor\" href=\"#31-进程调度的功能与时机\">#</a> 3.1 进程调度的功能与时机</h3>\n<ol>\n<li>\n<p>功能</p>\n<p><strong>进程调度功能</strong>由操作系统内核的<strong>进程调度程序完成</strong>。</p>\n<p>进程调度的功能是<strong>按照某种策略和算法</strong>从<strong>就绪态</strong>进程中为<strong>当前空闲的 CPU</strong> 选择在其上运行的新进程。</p>\n</li>\n<li>\n<p>时机</p>\n<p>当一个进程运行结束、进程阻塞、中断返回、在支持抢占式调度的系统中<strong>有比当前运行进程优先级更高的进程到来</strong>、当前运行进程的<strong>时间片用完</strong>，系统都会通过<strong>执行进程调度程序</strong>重新进行进程调度。（优先级高、当前时间片用完）</p>\n</li>\n</ol>\n<h3 id=\"32-进程调度算法综合题\"><a class=\"markdownIt-Anchor\" href=\"#32-进程调度算法综合题\">#</a> 3.2 进程调度算法（综合题）</h3>\n<p>进程调度算法是指从<strong>就绪态</strong>进程中选择一个进程为其分配 CPU ，<strong>使其进入执行态</strong>的算法。也就是说进程调度算法要 **“决定” 把 CPU 分配给就绪队列中的哪个进程 **。</p>\n<p>进程调度由操作系统内核中的进程调度程序完成。</p>\n<h4 id=\"321-选择调度方式和算法的若干准则\"><a class=\"markdownIt-Anchor\" href=\"#321-选择调度方式和算法的若干准则\">#</a> 3.2.1 选择调度方式和算法的<strong>若干准则</strong></h4>\n<ol>\n<li>\n<p><strong>周转时间短</strong></p>\n<p><strong>周转时间</strong>是指从<strong>作业被提交给系统开始，到作业完成为止</strong>的这段时间间隔。</p>\n<p>包括<strong> 4 部分</strong>时间：</p>\n<p>➢作业在<strong>外存后备队列上等待调度的时间</strong>，</p>\n<p>➢进程在<strong>就绪队列上等待进程调度的时间</strong>，</p>\n<p>➢进程在<strong> CPU 上执行的时间</strong>，</p>\n<p>➢进程等待<strong> I/O 操作完成的时间</strong>。</p>\n<ul>\n<li>\n<p>如果系统中<strong>有 n 个作业</strong>，系统的<strong>平均周转时间</strong>等于 n 个作业的周转时间<strong>之和除以 n</strong>。</p>\n<p>作业的周转时间 T 与系统为它提供的服务时间 Ts 之比为 W， W 称为<strong>带权周转时间</strong>。</p>\n<p>服务时间<strong> Ts 是一个作业在 CPU 上执行的总时间</strong>。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>响应时间快</strong></p>\n<p>响应时间是指<strong>用户提交一个请求开始</strong>至<strong>系统首次产生响应</strong>的时间为止的一段时间。</p>\n<p>它包括<strong> 3 部分</strong>时间：从<strong>输入设备信息传送到处理机</strong>的时间、<strong>处理机对请求信息进行处理</strong>的时间，以及<strong>将所形成的响应信息回送到终端显示器</strong>的时间。</p>\n<p><strong>对于交互式系统，响应时间是衡量系统时间性能的重要指标。</strong></p>\n</li>\n<li>\n<p><strong>截止时间的保证</strong></p>\n<p>截止时间是指某个任务<strong>必须开始的最迟时间或必须完成的最迟时间</strong>。是评价实时系统性能的重要指标。</p>\n</li>\n<li>\n<p><strong>系统吞吐量高</strong></p>\n<p><strong>吞吐量</strong>是指<strong>单位时间内完成的作业数</strong>。是评价系统性能的重要指标之一。</p>\n</li>\n<li>\n<p>处理机利用率好</p>\n<p>CPU 是计算机系统中影响时间性能的最重要的硬件资源，在多任务系统中，进程调度算法对 CPU 的利用率有很大影响。因此，在<strong>选择和设计进程调度算法时应该考虑使 CPU 的利用率尽可能高</strong>。</p>\n</li>\n</ol>\n<h4 id=\"322-先来先服务调度算法fcfs\"><a class=\"markdownIt-Anchor\" href=\"#322-先来先服务调度算法fcfs\">#</a> 3.2.2 先来先服务调度算法 (<strong>FCFS</strong> )</h4>\n<ol>\n<li>\n<p>调度算法</p>\n<p>在进程调度中，FCFS 就是从就绪队列的队首选择最先到达就绪队列的进程，为该进程分配 CPU。（First-Come ， First- Served）</p>\n</li>\n<li>\n<p>性能分析</p>\n<p>FCFS<strong> 适合长进程</strong>，有利于 CPU 繁忙的进程。</p>\n</li>\n<li>\n<p>综合题</p>\n<pre><code>有3个进程p1、p2和p3 ，分别在0、1、 2时刻进入系统，需要的运行(服务)时间长度分别为24、3、3 .，按照FCFS调度算法， 3个进程的等待时间和周转时间分别是?\n\n[答案]\n等待时间=开始时间-进入时间，周转时间=运行时间+等待时间。\n注意：开始运行时间从0开始计算\n</code></pre>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">进程名</th>\n<th style=\"text-align:center\">进入系统时间</th>\n<th style=\"text-align:center\">开始运行</th>\n<th style=\"text-align:center\">运行时间</th>\n<th style=\"text-align:center\">等待时间</th>\n<th style=\"text-align:center\">周转时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">p1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">24</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">p2</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">26</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">p3</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">28</td>\n</tr>\n</tbody>\n</table>\n<pre><code>此种情况下平均周转时间T和平均带权周转时间W为多少?\n\n[答案] T=(24+26+ 28)/3=26\n\t  W=(24/24+ 26/3+ 28/3)/3-6.33\n\n[解析]\n\t等待时间=开始时间-进入时间\n\t周转时间=运行时间+等待时间\n\t系统的平均周转时间:各个进程的周转时间总和/进程数\n\t带权周转时间:周转时间/运行时间\n\t平均带权周转时间:各个进程的带权周转时间总和/进程数\n</code></pre>\n</li>\n</ol>\n<h4 id=\"323-短进程优先调度算法-shortest-process-firstspf\"><a class=\"markdownIt-Anchor\" href=\"#323-短进程优先调度算法-shortest-process-firstspf\">#</a> 3.2.3 短进程优先调度算法 (Shortest-Process-First，SPF)</h4>\n<ul>\n<li>算法的缺陷\n<ol>\n<li><strong>对长进程不利</strong>。如果系统中不断有短进程到来长进程<strong>可能长时间得不到调度</strong>。</li>\n<li><strong>不能保证紧迫进程的及时处理</strong>，因<strong>本算法不考虑进程的紧迫程度</strong>。</li>\n<li><strong>进程的长度由用户估计而定，可能有偏差</strong>。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"324-优先权调度算法\"><a class=\"markdownIt-Anchor\" href=\"#324-优先权调度算法\">#</a> 3.2.4 优先权调度算法</h4>\n<ol>\n<li>\n<p>调度算法</p>\n<p>​\t在使用优先权调度的系统中， 每个进程都有一个与之关联的优先权。</p>\n<p>​\t当使用优先权调度算法进行进程调度时，系统将 CPU 分配给就绪队列中<strong>优先权值最高</strong>的进程。</p>\n</li>\n<li>\n<p>优先权调度算法的分类</p>\n<p>① 非抢占式优先权调度算法高优先权进程一旦得到处理机， 便一直运行下去直到完成或由于某事件使该进程主动放弃处理机。</p>\n<p>​\t即使更高优先权进程到来，也不能剥夺当前进程的 CPU 使用权，只能在就绪队列中等待。</p>\n<p>② 抢占式优先权调度算法</p>\n<p>​\t新到达的就绪进程与正在运行进程的优先权相比较，若<strong>新到达进程的优先权高于当前正在运行进程的优先权</strong>，则<strong>系统会抢占 CPU</strong> ，分配给新到达的进程，正在执行的进程暂停执行。</p>\n</li>\n<li>\n<p>优先权的类型</p>\n<p>根据优先权的变化特点将优先权的类型分为<strong>静态和动态</strong>。</p>\n<p>① <strong>静态优先权</strong>。在创建时确定，在进程的整个运行期间不变。</p>\n<p>② <strong>动态优先权</strong>。进程创建时被赋予的优先权，随进程的推进或随其等待时间的增加而改变。<strong>动态优先权调度算法可以使系统获得更好的调度性能</strong>。</p>\n</li>\n<li>\n<p>优先权调度算法存在的问题和解决方案</p>\n<p>① 问题。无穷阻塞或称饥饿问题。指就绪态进程因得不到 CPU 而等待的状态。优先权调度算法可能使某个低优先权进程无穷等待。</p>\n<p>② 解决方案。<strong>老化 (Aging) 技术。逐渐增加在系统中等待时间很长进程的优先权。</strong></p>\n</li>\n</ol>\n<h4 id=\"325时间片轮转调度算法\"><a class=\"markdownIt-Anchor\" href=\"#325时间片轮转调度算法\">#</a> 3.2.5 时间片轮转调度算法</h4>\n<p>​\t时间片轮转调度算法在现代分时系统中广泛使用， UNIX、Linux、 Windows 操作 系统都采用基于时间片轮转、支持优先权和抢占式调度的混合式进程调度算法。</p>\n<ol>\n<li>\n<p>时间片轮转调度算法</p>\n<p>时间片是一个较小的时间单位，通常为 10~ 100ms。每当进程在 CPU_上连续运行的时间等于一一个时间片长度时，操作系统在时钟中断处理过程中会抢占 CPU，进行进程切换，用新的就绪进程替代当前进程，<strong>被替换的当前进程重新回到就绪队列中</strong>。</p>\n</li>\n<li>\n<p>时间片大小的确定</p>\n<p><strong>时间片太长</strong>，可降低进程的周转时间，但可能造成交互用户的响应时间过长。</p>\n<p><strong>时间片太短</strong>，会增加进程切换和调度的开销，系统的平均周转时间也较长。</p>\n<p>① <strong>系统对响应时间的要求</strong>。响应时间越短，时间片取值应该越小。</p>\n<p>设系统响应时间为 T ，进程数目为 N，时间片为 q ，则有 T=Nq ，即在 N - 定的情况下， T 的大小取决于 q。</p>\n<p>② <strong>就绪队列中进程的数目</strong>。进程越多，响应时间越长。当设定了系统的最长响应时间值后，时间片的大小就与系统允许的最大进程数成反比。</p>\n<p>③ <strong>系统的处理能力</strong>。必须保证系统支持的基本命令能在一个时间片内执行完。</p>\n</li>\n<li>\n<p>时间片轮转调度算法的性能评价</p>\n<p>时间片轮转调度算法的性能<strong>依赖于时间片的大小</strong>。</p>\n<p>时间片很大，与先来先服务算法一样。</p>\n<p>时间片很小，会增加 CPU 用于进程切换和进程调度的开销。</p>\n</li>\n</ol>\n<h4 id=\"326-多级队列调度\"><a class=\"markdownIt-Anchor\" href=\"#326-多级队列调度\">#</a> 3.2.6 多级队列调度</h4>\n<p>​\t通常根据<strong>不同进程对响应时间要求的不同</strong>，采用<strong>多级队列调度算法</strong></p>\n<p>​\t多级队列调度算法，根据<strong>进程占用内存的大小、优先权或进程类型</strong>，将就绪队列分成多个独立队列，<strong>进程被永久地分配到一个队列，每个队列有自己的调度算法</strong>。<strong>降低了进程调度的开销</strong></p>\n<h4 id=\"327多级反馈队列调度\"><a class=\"markdownIt-Anchor\" href=\"#327多级反馈队列调度\">#</a> 3.2.7 多级反馈队列调度</h4>\n<p>​\t采用多级队列调度，对低优先权进程会存在无穷阻塞 (饥饿) 的问题。</p>\n<p>​\t多级反馈队列调度算法可以弥补这些不足。在采用多级反馈队列调度的系统中建立多个优先权不同的就绪队列，为每个队列赋予大小不同的时间片。</p>\n<p>​\t有一种<strong>反馈策略规定</strong>：队列优先权越高，时间片越短。新进程被创建后，先插入预先权最高的队列。仅当高优先权队列空时，才调度优先权次之的队列。同一队列中， 采用时间片轮转调度算法。使用 CPU 时间过多的进程会被移到优先权较低的队列中，在较低优先权队列中等待时间过长的进程会被移到较高优先权队列中。</p>\n<p>​\t多级反馈队列调度算法的设计要考虑以下几个方面的问题。</p>\n<ol>\n<li>就绪队列的数量。</li>\n<li>根据进程优先权确定进程应该进入哪个就绪队列的算法。</li>\n<li>用以确定进程何时转移到较高优先权队列的算法。</li>\n<li>用以确定进程何时转移到较低优先权队列的算法。</li>\n<li>用以确定进程在需要服务时应该进入哪个队列的算法。</li>\n</ol>\n<h3 id=\"33-实时系统中的调度\"><a class=\"markdownIt-Anchor\" href=\"#33-实时系统中的调度\">#</a> 3.3 实时系统中的调度</h3>\n<h4 id=\"331-实现实时调度的基本条件\"><a class=\"markdownIt-Anchor\" href=\"#331-实现实时调度的基本条件\">#</a> 3.3.1 实现实时调度的基本条件</h4>\n<p>​\t为了满足实时系统对截止时间的要求，实现实时调度应具备下列几个条件:</p>\n<ol>\n<li>\n<p><strong>提供必要的调度信息</strong><br>\n① 就绪时间<br>\n② 开始截止时间和完成截止时间<br>\n③ 处理时间<br>\n④ 资源要求<br>\n⑤优先级</p>\n</li>\n<li>\n<p><strong>系统处理能力强</strong></p>\n<p>（具体没啥用，随便看看）</p>\n<p>​\t在实时系统中，通常有多个实时进程，若处理机的处理能力不够强，处理速度不够快，若使某些实时进程不能得到及时处理，可能发生难以预料的后果。</p>\n<p>​\t可通过提高处理机的处理能力或增加处理机的数量以提高系统的处理能力。</p>\n</li>\n<li>\n<p><strong>采用抢占式调度机制</strong></p>\n<ol>\n<li><strong>基于时钟中断的抢占式优先权调度算法</strong><br>\n若高优先权大于正在执行的进程，就等当前进程到时钟中断的时候抢占</li>\n<li><strong>立即抢占的优先权调度算法</strong><br>\n一旦接收到就给当前执行的进程一个中断信号，然后抢占</li>\n</ol>\n</li>\n<li>\n<p>具有快速切换机制<br>\n就是需要进程<strong>对外部中断做出快速响应</strong>和<strong>快速的进程切换</strong></p>\n</li>\n</ol>\n<h4 id=\"332-常用的实时调度算法\"><a class=\"markdownIt-Anchor\" href=\"#332-常用的实时调度算法\">#</a> 3.3.2 常用的实时调度算法</h4>\n<ol>\n<li>\n<p>最早截止时间优先 EDF 算法</p>\n<p>根据进程的开始截止时间确定进程的优先级，<strong>截止时间越早，进程的优先级越高</strong>，越优先获得处理机。</p>\n</li>\n<li>\n<p>最低松弛度优先 LLF 算法</p>\n<p>​\t<strong>松弛度用来表示个实时进程的紧迫程度</strong>。</p>\n<p>​\t如果一个进程的完成截止时间为 T ，当前时间为 Tc 处理完该任务还需要的时间为 Ts，则松弛度 L 的计算式表示为: L=T-Tc-Ts</p>\n<p>​\t<strong>调度时，每次选择松弛度最小的进程</strong>。该算法按松弛度排序，<strong>让松弛度最小的进程排在就绪队列队首</strong>。</p>\n</li>\n</ol>\n<h3 id=\"34-进程切换\"><a class=\"markdownIt-Anchor\" href=\"#34-进程切换\">#</a> 3.4 进程切换</h3>\n<p>​\t含义：<strong>用新选择的进程替换原来的进行进程</strong></p>\n<ul>\n<li>进程切换包括的步骤如下:\n<ol>\n<li><strong>保存 CPU 上下文环境。</strong></li>\n<li><strong>更新进程控制块。</strong></li>\n<li><strong>修改进程状态，把执行态改为就绪态或者阻塞态。</strong></li>\n<li><strong>将被替换进程的进程控制块移到就绪队列或阻塞队列。</strong></li>\n<li><strong>执行新进程，并更新改进程的进程控制块。</strong></li>\n<li><strong>更新内存管理的数据结构。</strong></li>\n<li><strong>恢复上下文。</strong></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"35-多处理器调度\"><a class=\"markdownIt-Anchor\" href=\"#35-多处理器调度\">#</a> 3.5 多处理器调度</h3>\n<h4 id=\"351-多处理器系统的类型\"><a class=\"markdownIt-Anchor\" href=\"#351-多处理器系统的类型\">#</a> 3.5.1 多处理器系统的类型</h4>\n<p>根据处理器的耦合程度，分为紧密耦合和松弛耦合；根据处理器的结构，分为对称和非对称。</p>\n<ol>\n<li>\n<p>紧密耦合和松弛耦合</p>\n<ol>\n<li>紧密耦合</li>\n<li>松弛耦合</li>\n</ol>\n</li>\n<li>\n<p>对称和非对称</p>\n<p>对称属于同构，非对称在功能和结构上各不相同。</p>\n</li>\n</ol>\n<h4 id=\"352-多处理器系统中的进程分配方式\"><a class=\"markdownIt-Anchor\" href=\"#352-多处理器系统中的进程分配方式\">#</a> 3.5.2 多处理器系统中的进程分配方式</h4>\n<ol>\n<li>\n<p>对称多处理器系统中的进程分配方式</p>\n<ol>\n<li>\n<p>静态分配</p>\n<p>操作系统为每个处理器建立 - 个专门的就绪队列</p>\n</li>\n<li>\n<p>动态分配</p>\n<p>每个进程经过多次调度，每次获得的不一定是同一个处理器。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>非对称多处理器系统 (MPS) 中的进程分配方式</p>\n<p>采<strong>用主一从式</strong>操作系统，操作系统的核心部分驻留在一台主机上，而从机上只运行用户程序，只有主机 执行调度程序，所有从机的进程都是由主机分配的。</p>\n</li>\n</ol>\n<h4 id=\"353-进程线程调度方式\"><a class=\"markdownIt-Anchor\" href=\"#353-进程线程调度方式\">#</a> 3.5.3 进程（线程）调度方式</h4>\n<ol>\n<li>\n<p>自调度</p>\n<p>采用自调度的系统中设置<strong>有个公共的就绪队列，任何一个空闲的处理器都可以自行从该就绪队列中选取一个进程或者一个线程运行</strong>。</p>\n<ul>\n<li>\n<p>优点</p>\n<p>➢ 易移植</p>\n<p>➢ 有利于提高 CPU 的利用率</p>\n</li>\n<li>\n<p>缺点</p>\n<p>➢ 瓶颈问题，容易产生并发问题</p>\n<p>➢ 低效性，高速缓冲的命中率较低</p>\n<p>➢ 线程切换频繁</p>\n</li>\n</ul>\n</li>\n<li>\n<p>成组调度</p>\n<p>系统<strong>将一组相互合作的进程或线程同时分配到一组处理器上运行，进程或线程与处理器对应</strong>。</p>\n<ul>\n<li>优点:<br>\n➢ 减少线程切换，改善系统性能。<br>\n➢ 减少调度开销。一次调度一组，减少调度频率。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"36-死锁\"><a class=\"markdownIt-Anchor\" href=\"#36-死锁\">#</a> 3.6 死锁</h3>\n<h4 id=\"361-产生死锁的原因和必要条件\"><a class=\"markdownIt-Anchor\" href=\"#361-产生死锁的原因和必要条件\">#</a> 3.6.1 产生死锁的原因和必要条件</h4>\n<p>​\t<strong>当多个进程可能竞争数量有限的资源。若一个进程所申请的资源被其他处于阻塞状态的进程占有，该进程就会因为不能获得所申请的资源而被阻塞。</strong></p>\n<p>​\t这种由于多个进程竞争共享资源而引起的<strong>进程不能向前推进的僵持状态</strong>称为<strong>死锁</strong>。</p>\n<p><strong>产生死锁的原因</strong>：竞争共享资源且分配资源的顺序不当。</p>\n<p>产生死锁的必要条件：</p>\n<ol>\n<li>\n<p><strong>互斥条件</strong></p>\n<p>指一个进程在访问资源的过程中，其他进程不能访问该资源</p>\n</li>\n<li>\n<p><strong>请求和保持条件</strong></p>\n<p>进程已经保持了至少一个资源，又提出了新的资源要求且已经被其他进程占有，此时进程阻塞，但又对已经获得的资源保持不放，使得其他进程无法使用被保持的资源。</p>\n</li>\n<li>\n<p><strong>不剥夺条件</strong></p>\n<p>进程已经获得的资源不能被剥夺，只能由进程自己释放。</p>\n</li>\n<li>\n<p><strong>环路等待条件</strong></p>\n<p>在发生死锁时，必然存在一个进程申请资源的环形链。</p>\n<p>注意：只有上述 4 个条件同时满足时才会发生死锁。</p>\n</li>\n</ol>\n<h4 id=\"362-处理死锁的基本方法\"><a class=\"markdownIt-Anchor\" href=\"#362-处理死锁的基本方法\">#</a> 3.6.2 处理死锁的基本方法</h4>\n<p>处理死锁的基本方法有<strong>预防死锁、避免死锁、检测并解除死锁和忽略死锁</strong>问题。</p>\n<ol>\n<li>\n<p>死锁的预防</p>\n<p>通过保证至少其中一个条件不成立来达到预防发生死锁的目的。</p>\n<ol>\n<li>\n<p><strong>摒弃请求和保持条件</strong><br>\n所有进程执行前要一次性地申请在整个运行过程中所需要的全部资源</p>\n</li>\n<li>\n<p><strong>摒弃不剥夺条件</strong></p>\n<p>一个已保持了某些资源的进程，当它再提出新的资源要求而不能立即得到满足时，必须释放它已经保持的所有资源。</p>\n</li>\n<li>\n<p><strong>摒弃环路等待条件</strong></p>\n<p>进程必须按规定的顺序申请资源</p>\n</li>\n</ol>\n</li>\n<li>\n<p>死锁的避免</p>\n<p>​\t<strong>避免死锁的方法是把系统的资源分配状态分为安全状态和不安全状态</strong>，只要资源分配使系统资源分配状态处于安全状态，死锁就不会发生。</p>\n<p>​\t在避免死锁的方法中，允许进程动态地电请资源。</p>\n</li>\n</ol>\n<h4 id=\"363-银行家算法\"><a class=\"markdownIt-Anchor\" href=\"#363-银行家算法\">#</a> 3.6.3 银行家算法</h4>\n<p>​\t1965 年 Dijkstra (迪杰斯特拉) 提出了种能够避免死锁的资源分配算法。</p>\n<p>​\t其基本思想是<strong>一个进程提出资源请求后，系统先进行资源的试分配。然后检测本次的试分配是否使系统处于安全状态，若安全则按试分配方案分配资源，否则不分配资源</strong>。</p>\n<pre><code>\t银行家算法的由来是银行家贷款给客户这一问题。银行家(操作系统)把一定数量的资金(资源)供多个用户(进程)周转使用。当顾客对资金的最大申请量不超过银行家现金时就可接纳一个新顾客。银行可以对顾客的借款推迟支付，但一定使顾客总能在有限的时间内得到借款;当顾客得到全部资金后，他一定能在有限的时间里归还(回收)所有资金(资源)。\n</code></pre>\n<p>银行家算法分为两个过程:<br>\n 一是进行资源试分配的过程；<br>\n 二是对试分配后系统的状态做安全性检测的过程。</p>\n<h4 id=\"364-死锁的检测和解除\"><a class=\"markdownIt-Anchor\" href=\"#364-死锁的检测和解除\">#</a> 3.6.4 死锁的检测和解除</h4>\n<p>何时调用检测算法？</p>\n<p>​\t➢ 死锁可能发生的频率</p>\n<p>​\t➢ 当死锁发生时受影响的进程数量</p>\n<p>死锁定理</p>\n<p>​\t➢ 死锁状态的充分条件是当且仅当资源分配状态是不可完全简化的。</p>\n<p>死锁的解除</p>\n<p>​\t➢ 终止处于死锁状态的进程</p>\n<p>​\t➢ 抢占死锁进程占有的资源</p>\n<p>单选题</p>\n<pre><code>某系统中有n (n为大于1的整数)个并发进程，每个进程需要同类资源m个(m为大于0的整数), 请问该系统不会发生死锁的最少资源数是( C )。\n\nA. n+m\nB.n*m\nC.n*(m-1)+1\nD.以上都对\n\n[解析]\n例如,若某系统中有4个并发进程,每个进程需要同类资源3个,则只要分配4*(3-1)+ 1共9个资源,该系统就不会发生死锁。每个进程都申请到两个资源后,还有1个资源,无论哪个进程获得这个资源都可以继续向前推进,当获得这个资源的进程执行完后,可以释放3个资源再分配给其他3个进程,因此不会发生死锁。\n</code></pre>\n<hr>\n<h2 id=\"第四章内存管理重点\"><a class=\"markdownIt-Anchor\" href=\"#第四章内存管理重点\">#</a> 第四章：内存管理（重点）</h2>\n<h3 id=\"考试重点\"><a class=\"markdownIt-Anchor\" href=\"#考试重点\">#</a> 考试重点</h3>\n<p>​\t➢ 存储器的层次结构 (选择、填空、简答)</p>\n<p>​\t➢ 程序的链接和装入 (选择、填空、简答)</p>\n<p>​\t➢ 连续分配存储管理、动态分区分配算法 (选择、填空、简答、综合)</p>\n<p>​\t➢ 分页、快表、两级页表 (选择、填空、简答、综合)</p>\n<p>​\t➢ 虚拟存储、缺页、页分配策略 (选择、填空、简答)</p>\n<p>​\t➢ 页置换算法 (选择、填空、简答、综合)</p>\n<p>​\t➢ 分段系统、段表、段页式存储管理 (选择、填空、简答)</p>\n<p><strong>本章近 3 年分值: 19~22 分</strong></p>\n<h3 id=\"41-存储器的层次结构\"><a class=\"markdownIt-Anchor\" href=\"#41-存储器的层次结构\">#</a> 4.1 存储器的层次结构</h3>\n<p>​\t内存是计算机存储系统的一部分，为了更好地理解后续章节内容，先了解存储器系统的层次结构。存储器系统是一个具有不同容量、成本和访问时间的存储设备的层次结构。</p>\n<p>在这个层次系统中，从高层到底层 (L0~L5)，较低层的存储设备速度更慢、容量更大、价格更便宜。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081201.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081201.png\" class=\"\"></p>\n<p>如果存储在高速缓存中，需要 1~ 10 个周期。</p>\n<p>如果存放在主存中，访问它们需要 50~ 100 个周期。</p>\n<p>如果存放在磁盘中，访问它们需要大约 2000 万个周期。</p>\n<p>​\t➢ 程序的执行遵循<strong>局部性</strong>原理。</p>\n<p>​\t程序在执行时呈现出局部性规律，即在一段较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域。</p>\n<ol>\n<li>程序执行时，除了少部分的转移和过程调用指令，<strong> 大多数情况下是顺序执行</strong></li>\n<li><strong>过程调用</strong>将会使程序的执行轨迹由一部分内存区域转移到另一部分内存区域</li>\n<li>程序中存在很多<strong>循环</strong>结构，它们虽然由少数指令构成但<strong>多次执行</strong></li>\n<li>程序中往往包括许多对数据结构的处理，如对数组操作，它们往往<strong>局限在很小的范围内</strong></li>\n</ol>\n<p>➢ 总的来说，<strong> 局部性</strong>原理<strong>表现为时间和空间的局部性</strong><br>\n➢ 时间局部性。如果程序中的某条指令一旦执行则不久后该指令可能再次执行。<br>\n➢ 空间局部性。一旦程序访问了某个单元，不久后其附近的存储单元也将被访问</p>\n<h3 id=\"42-程序的链接和装入\"><a class=\"markdownIt-Anchor\" href=\"#42-程序的链接和装入\">#</a> 4.2 程序的链接和装入</h3>\n<p>高级语言程序必须经过编译、链接才能成为可执行程序。操作系统需要为程序的执行分配内存空间。下面介绍链接程序的功能和程序被装入内存的几种方式。</p>\n<h4 id=\"421-程序的链接\"><a class=\"markdownIt-Anchor\" href=\"#421-程序的链接\">#</a> 4.2.1 程序的链接</h4>\n<p><strong>链接程序</strong>要解决的问题是<strong>将编译后的目标模块装配成一个可执行的程序</strong>。根据链接进行的时间和实现方式的不同，可以把链接分为静态链接和动态链接。<br>\n➢ <strong>静态链接</strong></p>\n<p>​\t在程序运行前，用链接程序将目标模块链接成一个完整的装入模块。运行速度快，占用大</p>\n<p>➢ <strong>动态链接</strong></p>\n<p>​\t将部分目标模块链接推迟到其中函数被调用执行。采用动态链接节省空间，方便开发，速度慢</p>\n<h4 id=\"422-程序的装入\"><a class=\"markdownIt-Anchor\" href=\"#422-程序的装入\">#</a> 4.2.2 程序的装入</h4>\n<p>​\t将源程序变为可执行程序须经过<strong>编译、链接和装入</strong> 3 个阶段。</p>\n<p>​\t可执行程序以<strong>二进制可执行文件</strong>的形式存储在磁盘上，为执行程序，操作系统需要把程序调入内存。程序装入内存的方式分为<strong>绝对装入、可重定位装入 (静态重定位) 和动态运行时装入</strong></p>\n<ol>\n<li>\n<p><strong>绝对装入方式</strong></p>\n<p>编译程序事先已知程序在内存中的驻留位置，编译时产生物理地址的目标代码。因此装入模块被装入内存后，无需对程序和数据的地址进行修改。</p>\n</li>\n<li>\n<p><strong>可重定位装入方式</strong> (静态重定位)</p>\n<p>​\t如果<strong>编译时不知道</strong>目标程序将驻留在内存的什么位置，则编译时就必须生成可重定位的代码，其中的地址都是<strong>逻辑地址</strong>（相对地址）, 在程序被装入内存时，再把这些逻辑地址映射为物理地址</p>\n<p>​\t在程序装入时对目标程序中的指令和数据地址的修改过程称为<strong>重定位</strong>。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081202.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081202.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>动态运行时装入</strong> (动态重定位)</p>\n<p>​\t一个进程在被换出之前所在的内存位置与后来被从外存重新调入时内存位置不同，这种装入方式称为<strong>动态运行时装入</strong>。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081203.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081203.png\" class=\"\"></p>\n</li>\n</ol>\n<h3 id=\"43-连续分配存储管理方式\"><a class=\"markdownIt-Anchor\" href=\"#43-连续分配存储管理方式\">#</a> 4.3 连续分配存储管理方式</h3>\n<p>连续分配是指操作系统分配内存时，为每个进程分配块物理地址连续的内存空间，连续分配方式有 3 种类型。</p>\n<p>➢ 单一连续区分配方式<br>\n➢ 固定分区分配方式<br>\n➢ 动态分区分配方式</p>\n<h4 id=\"431-单一连续区分配方式\"><a class=\"markdownIt-Anchor\" href=\"#431-单一连续区分配方式\">#</a> 4.3.1 单一连续区分配方式</h4>\n<p>​\t适用于单用户、单任务的操作系统，把内存分为<strong>系统区和用户区</strong>。系统区用于驻留操作系统，用户区用于分配给用户进程使用。</p>\n<p>​\t在单用户、单任务操作系统中较常用的方法是设置<strong>一个基址寄存器和一个界限寄存器</strong>。</p>\n<p>​\t<strong>基址寄存器</strong>中<strong>存放程序在物理内存中的最小地址</strong></p>\n<p>​\t<strong>界限寄存器</strong>中<strong>存放装入用户区程序的地址范围</strong></p>\n<p>​\t在 CPU 访问内存时，检查 CPU 要访问的内存单元的地址是否大于界限寄存器的值，如果大于，则是非法地址，表示用户进程访存越界，程序执行会被中断。</p>\n<h4 id=\"432-固定分区分配方式\"><a class=\"markdownIt-Anchor\" href=\"#432-固定分区分配方式\">#</a> 4.3.2 固定分区分配方式</h4>\n<p>​\t将内存用户区划分成若干个固定大小的区域，每个用户区中驻留一道程序。当有一个空闲分区时，可从外存的后备队列中选择一个大小适当的作业装 入该分区</p>\n<ul>\n<li>\n<p>划分分区的方法</p>\n<ul>\n<li>\n<p>分区大小相等</p>\n<p>把用户区划分成大小相等的若干个分区。</p>\n<p>缺点是内存利用率比较低。程序太小浪费空间，程序太大装不下</p>\n</li>\n<li>\n<p>分区大小不相等</p>\n<p>先划分多个大小不同、数量固定的若干个分区。分配的时候看哪个更接近就分配哪个。减少了浪费。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081204.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081204.png\" class=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"433-动态分区分配方式\"><a class=\"markdownIt-Anchor\" href=\"#433-动态分区分配方式\">#</a> 4.3.3 动态分区分配方式</h4>\n<p>​\t系统初始只有一个大空闲区，根据进程需要的空间大小分配内存。内存中<strong>分区的大小和数量是变化的</strong>。动态分区方式比固定分区方式<strong>显著地提高了内存利用率</strong>。系统维护一个记录当前空闲分区情况的数据结构，<strong>当进程请求内存时，系统从所有空闲区中找到大小合适的空闲分区进行分配</strong>。</p>\n<p>​\t常用的数据结构有<strong>空闲分区表</strong>和<strong>空闲分区链</strong></p>\n<p>➢ <strong>空闲分区表</strong></p>\n<p>​\t<img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081205.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081205.png\" class=\"\"></p>\n<p>​\t缺点：设置太多表项会浪费内存空间；设置太少无法记录所有空闲分区情况</p>\n<p>➢ <strong>空闲分区链</strong></p>\n<p>​\t可以<strong>动态地为每一个空闲分区建立一 个结点</strong>，每个结点包括分区大小、分区起始地址、指向前一个空闲分区结点的指针，以及指向后一个空闲分区结点的指针。空闲分区链中的<strong>每个结点占用的内存可以动态分配动态回收</strong>。</p>\n<p>➢ <strong>动态分区分配算法</strong></p>\n<p>​\t当进程需要内存空间时，操作系统通过执行动态分区分配算法从多个空闲分区中选定一个合适的分区分配给进程。</p>\n<p>​\t内存分配功能由内存分配程序完成。内存不再需要时，由系统调用内存回收程序回收原来被占的内存。</p>\n<ol>\n<li>\n<p>首次适应算法 FF (First Fit)</p>\n<p>​\t要求空闲分区链以<strong>地址递增</strong>的顺序链接。在内存分配时，从链首开始顺序查找，直至找到一个能满足进程大小要求的空闲分区为止。余下的空闲分区仍留在空闲链中。</p>\n<p>​\t该算法先分配低地址部分的内存空间，容易使低地址部分留下小分区，而高地址部分大空闲区较多。当进程请求大空间时，要找到合适的空闲分区，<strong> 时间开销大</strong>。</p>\n</li>\n<li>\n<p>循环首次适应算法 NF (Next Fit)</p>\n<p>​\t为进程分配内存空间时，<strong> 从上次找到的空闲分区的下一个空闲分区开始查找直到找到第个能满足要求的空闲分区</strong>，并从中划出一块与请求的大小相等的内存空间分配给进程。</p>\n<p>​\t为实现该算法，应设置一个起始查找指针，以指示下一次起始查找的空闲分区，并采用<strong>循环查找方式</strong>。循环首次适应算法的优点是:<strong> 空闲区分布均匀，查找开销较小。缺点是容易使系统缺乏大空闲区</strong>。</p>\n</li>\n<li>\n<p>最佳适应算法 BF (Best Fit)</p>\n<p>​\t该算法每次分配内存，把大小与进程所请求的<strong>内存大小最接近分配给进程</strong>。该算法要求将所有的空闲区按分区大小递增顺序形成一个空闲区链。</p>\n<p>​\t优点：避免大材小用，提高内存利用率，但容易留下难以利用的小空闲区</p>\n</li>\n</ol>\n<p>外部碎片 / 外碎片：低地址部分的空闲分区反复被划分，可能留下许多很小的空闲分区<br>\n内部碎片 / 内碎片：分配给进程的分区若大于进程请求的分区，分区内会有部分未利用的空间</p>\n<h3 id=\"44-基本本页存储管理方式\"><a class=\"markdownIt-Anchor\" href=\"#44-基本本页存储管理方式\">#</a> 4.4 基本本页存储管理方式</h3>\n<p>➢ <strong>离散内存管理方式</strong></p>\n<p>​\t\t把进程<strong>离散地</strong>存储在内存中物理地址不连续的区域中</p>\n<p>​\t根据离散内存管理分配内存空间的基本单位不同，分为 3 种管理方式:<strong> 分页存储管理、分段存储管理和段页式存储管理</strong>。</p>\n<h4 id=\"441-分页存储管理的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#441-分页存储管理的基本概念\">#</a> 4.4.1 分页存储管理的基本概念</h4>\n<ol>\n<li>\n<p>基础概念</p>\n<ol>\n<li>\n<p>页（Page）：将一个进程的<strong>逻辑地址空间</strong>分成多个大小相同的片</p>\n</li>\n<li>\n<p>页框 / 页帧：将<strong>物理内存空间</strong>分成与页大小相同的多个存储块</p>\n</li>\n<li>\n<p>分页存储：为进程分配内存时，<strong>以页框为单位</strong>将进程的若干个页<strong>装入多个不相邻的页框中</strong></p>\n</li>\n<li>\n<p>页内碎片：进程的最后一页装不满一个页框时，剩下的碎片</p>\n</li>\n<li>\n<p>页表：<strong>系统为进程建立的数据结构，实现从页号到页框号的映射</strong></p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081206.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081206.png\" class=\"\"></p>\n<h3 id=\"45-基于分页的虚拟存储系统\"><a class=\"markdownIt-Anchor\" href=\"#45-基于分页的虚拟存储系统\">#</a> 4.5 基于分页的虚拟存储系统</h3>\n<p><strong>虚拟存储器</strong>是指具有<strong>请求调入功能和置换功能</strong>，能从逻辑上对内存容量进行扩充的一种存储器系统。在虚拟存储器系统中，<strong> 进程无需全部装入</strong>，只要装入一部分即可运行。</p>\n<p>​\t虚拟存储技术实现的思想：先将进程的一部分装入内存，其余的部分需要的时候再请求系统装入，这就是请求调入。</p>\n<p>​\t置换：如果请求调入时，没有足够的内存，则由操作系统选择一部分内存中的内容换到外存。</p>\n<p>优点：</p>\n<p>(1) 提高内存利用率；<br>\n(2) 提高多道程序度；<br>\n(3) 把逻辑地址空间和物理地址空间分开，使程序员不再关心物理内存的容量对编程的限制。</p>\n<p>虚拟存储系统具有以下几个主要特征：</p>\n<p>(1) 离散性。指进程可以分散地存储在物理内存中。分页、分段和段页式存储都属于离散的内存管理方式。离散性是实现虚拟存储管理的基础。<br>\n(2) 多次性。指不必把进程一 - 次性全部装入内存，可分多次装入。<br>\n(3) 对换性。指在内存中的进程可以换出，以腾出内存空间换入外存中的进程。<br>\n(4) 虚拟性。指虚拟存储系统为用户提供了比实际物理内存大的逻辑内存空间，程序员不必在编程时受物理内存空间大小的限制。虚拟性是实现虚拟存储系统的最重要目标。</p>\n<p>​\t请求分页系统是最基本、最常用的虚拟存储系统的实现方式。其基本原理是，把进程的逻辑地址空间分成大小相同的页，操作系统创建进程时只把进程的一部分页调入内存。进程运行过程中访问内存、若发现所访问的页不在内存中，则<strong>产生一个缺页异常信号</strong>，系统响应缺页异常，<strong> 请求调入缺页</strong>。</p>\n<p>​\t若调入缺页时内存已满，则需要先从内存中选择一个或若千个页换出到外存空间，以腾出内存空间容纳请求调入的缺页。</p>\n<h4 id=\"451-请求分页中的硬件支持\"><a class=\"markdownIt-Anchor\" href=\"#451-请求分页中的硬件支持\">#</a> 4.5.1 请求分页中的硬件支持</h4>\n<p>​\t为了实现请求分页，需要特殊的页表 (相对基本分页而言)、缺页异常机构和支持请求分页的地址变换机构。</p>\n<ol>\n<li>\n<p>页表</p>\n<p>是支持请求分页系统最重要的数据结构，其作用是记录描述页的各种数据，包括在实现逻辑地址到物理地址映射时需要的页号与页框号的对应关系。</p>\n<p>​\t除了页号和页框号之外，页表中增加了请求换入和页置换时需要的数据。</p>\n<p>​\t在支持请求分页的系统中一般包含以下基本字段:</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081601.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081601.png\" class=\"\"></p>\n<p>​\t页框号：存放页所在的页框号。</p>\n<p>​\t状态位 P : 标识页是否在内存中。可规定 0 不在，1 在。</p>\n<p>​\t访问字段 A : 用于记录页最近被访问的情况。系统总是希望根据 A 的值把最近、最久未访问的页换出到外存。</p>\n<p>​\t修改位 M : 标识页最近是否被修改过。</p>\n<p>​\t保护位：标识页的访问权限，如 1 表示可读可写 0 表示只读。</p>\n</li>\n<li>\n<p>缺页异常机构</p>\n<p>​\t主要作用是在访问内存过程中发现缺页时产生缺页异常信息，使 CPU 中断当前控制流的执行，转去执行操作系统的缺页异常处理程序，完成请求调页。</p>\n</li>\n<li>\n<p>地址变换</p>\n<p>请求分页系统中的地址变化过程如下:<br>\n(1) 由分页地址变换机构从逻辑地址中分离出页号和页内偏移地址。</p>\n<p>(2) 以页号为索引查找快表，若快表中有该页的页表项，则读出页框号，计算物理地址。</p>\n<p>(3) 若快表中无该页信息，转到内存页表中查找。若页表中的状态位 P 显示该页调入内存，则从相应的页表项读出页所在的页框号，并计算物理地址，然后把该页表项写入快表。</p>\n<p>(4) 若该页尚末调入内存，则产生缺页异常请求操作系统从外存中把该页调入内存，然后修改页表，重新执行被中断的指令。请求分页中的地址变换过程如下图 4-44 所示。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081602.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081602.png\" class=\"\"></p>\n</li>\n</ol>\n<h4 id=\"452-页分配策略\"><a class=\"markdownIt-Anchor\" href=\"#452-页分配策略\">#</a> 4.5.2 页分配策略</h4>\n<ol>\n<li>\n<p>最少页框数</p>\n<p>指能保证进程正常运行所需要的最少的页框数。为了保证进程顺利执行，操作系统为进程分配的初始页数应该大于或等于最少页框数。</p>\n</li>\n</ol>\n<h4 id=\"453-页调入策略\"><a class=\"markdownIt-Anchor\" href=\"#453-页调入策略\">#</a> 4.5.3 页调入策略</h4>\n<ol>\n<li>\n<p>何时调入页<br>\n大多数系统都采用<strong>预先凋入页</strong>的策略，将预计不久之后会被访问的页预先调入内存，而不是缺哪一页时再调入该页。</p>\n<p>​\t在实际系统中，通常是在<strong>调入缺页时，把与所缺页相邻的若千页也调入内存</strong>。</p>\n</li>\n<li>\n<p>从何处调入页</p>\n<p>当系统拥有足够的对换空间时，若发生缺页请求则从对换区调入页。从对换区调入页比从文件区调入页的速度快。对换区中的页是进程运行前从文件区复制到对换区的。</p>\n</li>\n</ol>\n<h4 id=\"454-页置换算法\"><a class=\"markdownIt-Anchor\" href=\"#454-页置换算法\">#</a> 4.5.4 页置换算法</h4>\n<p>​\t页置换算法是从内存中选择换出页的算法。</p>\n<ol>\n<li>\n<p>最佳置换算法和先进先出置换算法</p>\n<p>( 1 )<strong> 最佳置换算法</strong></p>\n<p>​\t选择以后永远不会被访问的页或者在未来最长时间内不再被访问的页作为换出页。该算法主要用于<strong>理论研究</strong>。</p>\n<p>( 2 )<strong> 先进先出页置换算法</strong></p>\n<p>​\t为每个页记录该项调入内存的时间，当选择换出页时，选择进入内存时间最早的页。</p>\n<p>​\t实现简单，但<strong>效率低</strong>，会导致较高的缺页率，有的页刚被换出，可能又要立即被访问。</p>\n</li>\n<li>\n<p>最近最久未使用 LRU 置换算法</p>\n<p>​\t<strong>选择最近最久末使用的页换出</strong>。同样的页引用序列，LRU 算法<strong>置换次数</strong>较先进先出算法少，性能较好。</p>\n</li>\n<li>\n<p>其他置换算法</p>\n<p>​\t附加引用位算法、简单 Clock 置换算法、 改进型 Clock 算法、最少使用置换算法。</p>\n</li>\n</ol>\n<h4 id=\"综合题\"><a class=\"markdownIt-Anchor\" href=\"#综合题\">#</a> 综合题</h4>\n<p>[答案] 先进先出页置换算法</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081603.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081603.png\" class=\"\"></p>\n<h4 id=\"455-请求分页系统的性能分析\"><a class=\"markdownIt-Anchor\" href=\"#455-请求分页系统的性能分析\">#</a> 4.5.5 请求分页系统的性能分析</h4>\n<p>请求调入和置换技术都是以时间换空间的技术。</p>\n<ol>\n<li>\n<p>缺页率对有效访问时间的影响</p>\n<p>​\t进程执行中访存发生缺页时，需要请求从外存调入缺页。如果内存中没有空闲页框，还需要进行页置换，调入缺页后，指令需要重新执行。因此，一旦发生缺页，进程会存在因为访存而带来的时间延迟。</p>\n<p>​\t有效访问时间正比于缺页率。</p>\n</li>\n<li>\n<p>工作集</p>\n<p>​\t引入<strong>工作集机制</strong>是为了<strong>能有效降低缺页率</strong>，从而提高访存的时间效率。程序运行时<strong>对页的访问是不均匀的</strong>，往往在<strong>某段时间内集中于访问某些页</strong>。若能将<strong>某段时间间隔内要访问的页提前调入内存</strong>，将会大大降低缺页率，从而减少置换次数，提高 CPU 的利用率。<strong>工作集</strong>就是<strong>在某段时间间隔内，进程实际要访问的页的集合</strong>。</p>\n</li>\n<li>\n<p>抖动产生的原因和预防方法</p>\n<p>​\t多道程序度太高，使运行进程的大部分时间都用于进行页的换入、换出，而几乎不能完成任何有效工作的状态称为抖动。<br>\n​\t引起<strong>抖动的原因</strong>是<strong>系统中的进程数量太多，每个进程能分配到的页框态少</strong>，以至于进程运行过程中频繁请求调页。</p>\n<p>抖动的预防:<br>\n( 1 )<strong> 采取局部置换策略</strong>。仅在进程自己的内存空间范围内置换页。<br>\n(2) 在 CPU 调度程序中<strong>引入工作集</strong>算法。<br>\n( 3 )<strong> 挂起若干进程</strong>。腾出进程占用的空间。</p>\n</li>\n</ol>\n<h3 id=\"46-分段存储管理\"><a class=\"markdownIt-Anchor\" href=\"#46-分段存储管理\">#</a> 4.6 分段存储管理</h3>\n<h4 id=\"461-分段机制的引入\"><a class=\"markdownIt-Anchor\" href=\"#461-分段机制的引入\">#</a> 4.6.1 分段机制的引入</h4>\n<p>​\t在分页存储管理方式中，逻辑地址是维的，一个进程的逻辑地址形成个地址空间。 这种逻辑空间的使用方式对于程序员来说很不方便，分段能为进程提供多个地址空间，把逻辑上关联的部分放在一个地址空间中逻辑上没有关联也没有共同特征的部分放在不同的地址空间中。这样不仅方便用户编程，而且能很好地解决部分存储空间动态增长、信息共享和信息保护问题。</p>\n<p>​\t把分别存放逻辑上相关的信息、相互独立的逻辑地址空间称为一个段，每个段由一个从 0 到最大线性地址的逻辑地址空间构成。</p>\n<p>​\t各个段的长度可以是 0 到最大值之间的任何一个值不同段的长度可以不相同，段的长度在进程运行期间可以改变。</p>\n<p>​\t在使用分段存储管理的系统中，程序员使用二维的逻辑地址，一个数用来表示段，另一个数用来表示段内偏移。段是一个逻辑实体，程序员可以通过使用二维地址来访问不同的逻辑段。</p>\n<p>​\t一个段可能包括一个过程，或者一个数组、一个堆栈、一些数值变量，但是一般不会同时包含多种不同的内容。</p>\n<h4 id=\"462-分段系统的基本原理\"><a class=\"markdownIt-Anchor\" href=\"#462-分段系统的基本原理\">#</a> 4.6.2 分段系统的基本原理</h4>\n<ol>\n<li>\n<p>分段</p>\n<p>​\t在分段的存储管理方式中，进程的地址空间被划分成若千个段。每个段定义了一组逻辑信息，每个段的大小由相应的逻辑信息组的长度确定，段的大小不一样 **, 每个段的逻辑地址从 0 开始，采用一段连续的地址空间 **。系统为每个段分配一个连续的物理内存区域，各个不同的段<strong>可以离散地放入物理内存不同的区域</strong>。</p>\n</li>\n<li>\n<p>分段的逻辑地址结构<br>\n分段机制的逻辑地址是二维的，由段号和段内地址组成。</p>\n<p>32 位系统中分段的地址形式为:</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081604.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081604.png\" class=\"\"></p>\n</li>\n<li>\n<p>段表</p>\n<p>​\t段表是<strong>由操作系统维护</strong>的用于支持分段存储管理地址映射的<strong>数据结构</strong>。通常，<strong> 每个进程有一个段表</strong>，段表由段表项构成。每个段表项包含<strong>段号、段基址</strong> (段的起始地址) 和<strong>段长</strong> (段大小) 3 个部分。一个进程可能包含若干个段，每一个段在段表中有一个段表项与之对应。根据段表可以知道一个段在物理内存中的位置。</p>\n</li>\n<li>\n<p>分段系统的地址变换</p>\n<p>​\t逻辑地址由段号 s 和段内偏移 d 构成。<br>\n​\t已知逻辑单元的地址为 s:d， 求物理地址的步骤为:<br>\n​\t(1) 以 s 为索引，从段表中找到段号为 s 的段表项。<br>\n​\t(2) 从找到的段表项中读出 s 段的基地址和段大小。<br>\n​\t(3) 如果<strong> d &lt; = 段大小</strong>，则将<strong>段基址与段内偏移 d 相加，得到与逻辑单元 s:d 对应的物理单元地址</strong>。</p>\n</li>\n<li>\n<p>分页和分段的主要区别</p>\n<ol>\n<li>页是按物理单位划分的，分页的引入是为了提高内存的利用率和支持虚拟存储。而段是按逻辑单位划分的，一个段含有一 - 组意义相对完整的信息。引入分段的目的是为了方便程序员编程。</li>\n<li>页的大小是固定的，而段的大小不固定，取决于用户编写的程序和编译器。</li>\n<li>分页的地址空间是一维的，程序员给出的地址只是一个助记符，已知的逻辑地址是一个整数。分段的地址空间是二维的，程序员在标识一个逻辑地址时需要给出两个数：一个是段号，一个是段内偏移。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"463-段页式存储管理\"><a class=\"markdownIt-Anchor\" href=\"#463-段页式存储管理\">#</a> 4.6.3 段页式存储管理</h4>\n<ol>\n<li>\n<p>段页式存储管理的基本原理</p>\n<p>​\t在段页式存储管理系统中，将用户进程的逻辑空间先划分成若干个段，每个段再划分成若千个页。进程以页为单位在物理内存中离散存放，每个段中被离散存放的页具有逻辑相关性。</p>\n</li>\n<li>\n<p>地址变换过程</p>\n<p>​\t在段页式存储管理系统中，逻辑地址与分段系统的逻辑地址相同，由段号 s 和段内地址 d 构成，地址变换过程如下<br>\n (1) 以段号 s 作索引，找到段 s 的段表项，得到该段页表的起始地址。<br>\n(2) 通过分页机制从<strong>段内偏移 d 中分离出页号 P 和页内偏移 W</strong>。<br>\n(3) 以段内页号<strong> P 作索引</strong>，从段 s 的页表中<strong>搜索</strong>页号<strong> P</strong> 对应的<strong>页表项</strong>。<br>\n(4) 从页表项中<strong>得到</strong>页所在的<strong>页框号</strong>。<br>\n(5) 由<strong>页框号</strong>与<strong>页内偏移 W</strong> 得到某逻辑地址对应的物理地址。</p>\n<p>物理地址 = 页框号 * 页框大小 + 页内偏移 W<br>\n 采用段页式存储管理的好处是，程序员可以使用分段的逻辑地址，而实际上进程却以页为单位存放于物理内存中。段页式系统的地址变换如下图。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081607.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081607.png\" class=\"\"></p>\n</li>\n</ol>\n<h4 id=\"464-综合题\"><a class=\"markdownIt-Anchor\" href=\"#464-综合题\">#</a> 4.6.4 综合题</h4>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081605.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081605.png\" class=\"\"><br>\n<img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081606.png\" alt=\"\"><img data-src=\"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081606.png\" class=\"\"></p>\n<h3 id=\"47-linux的伙伴系统\"><a class=\"markdownIt-Anchor\" href=\"#47-linux的伙伴系统\">#</a> 4.7 Linux 的伙伴系统</h3>\n<hr>\n<h2 id=\"第五章文件管理\"><a class=\"markdownIt-Anchor\" href=\"#第五章文件管理\">#</a> 第五章：文件管理</h2>\n<h3 id=\"51-文件\"><a class=\"markdownIt-Anchor\" href=\"#51-文件\">#</a> 5.1 文件</h3>\n<h3 id=\"52-目录\"><a class=\"markdownIt-Anchor\" href=\"#52-目录\">#</a> 5.2 目录</h3>\n<h3 id=\"53-文件系统的实现\"><a class=\"markdownIt-Anchor\" href=\"#53-文件系统的实现\">#</a> 5.3 文件系统的实现</h3>\n<hr>\n<h2 id=\"第六章设备管理\"><a class=\"markdownIt-Anchor\" href=\"#第六章设备管理\">#</a> 第六章：设备管理</h2>\n<h3 id=\"61-io系统的组成\"><a class=\"markdownIt-Anchor\" href=\"#61-io系统的组成\">#</a> 6.1 I/O 系统的组成</h3>\n<h3 id=\"62-io控制方式\"><a class=\"markdownIt-Anchor\" href=\"#62-io控制方式\">#</a> 6.2 I/O 控制方式</h3>\n<h3 id=\"63-缓冲管理\"><a class=\"markdownIt-Anchor\" href=\"#63-缓冲管理\">#</a> 6.3 缓冲管理</h3>\n<h3 id=\"64-设备分配\"><a class=\"markdownIt-Anchor\" href=\"#64-设备分配\">#</a> 6.4 设备分配</h3>\n<h3 id=\"65-io软件原理\"><a class=\"markdownIt-Anchor\" href=\"#65-io软件原理\">#</a> 6.5 I/O 软件原理</h3>\n<h3 id=\"66-磁盘管理\"><a class=\"markdownIt-Anchor\" href=\"#66-磁盘管理\">#</a> 6.6 磁盘管理</h3>\n",
            "tags": [
                "操作系统概论"
            ]
        }
    ]
}