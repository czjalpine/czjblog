{
    "version": "https://jsonfeed.org/version/1",
    "title": "失心耀的博客 • All posts by \"本科\" category",
    "description": "",
    "home_page_url": "https://xinyao_idiot.gitee.io/zxy",
    "items": [
        {
            "id": "https://xinyao_idiot.gitee.io/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/",
            "url": "https://xinyao_idiot.gitee.io/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/",
            "title": "操作系统概论",
            "date_published": "2021-08-11T10:27:00.000Z",
            "content_html": "<h1 id=\"操作系统概论\"><a class=\"markdownIt-Anchor\" href=\"#操作系统概论\">#</a> 操作系统概论</h1>\n<h2 id=\"考试题型\"><a class=\"markdownIt-Anchor\" href=\"#考试题型\">#</a> 考试题型</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">题型</th>\n<th style=\"text-align:center\">数量</th>\n<th style=\"text-align:center\">分支</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">单选</td>\n<td style=\"text-align:center\">1 分 * 20</td>\n<td style=\"text-align:center\">20 分</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">填空</td>\n<td style=\"text-align:center\">2 分 * 10</td>\n<td style=\"text-align:center\">20 分</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">简答</td>\n<td style=\"text-align:center\">4 分 * 5</td>\n<td style=\"text-align:center\">20 分</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">综合</td>\n<td style=\"text-align:center\">10 分 * 4</td>\n<td style=\"text-align:center\">40 分</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"第一章操作系统简介\"><a class=\"markdownIt-Anchor\" href=\"#第一章操作系统简介\">#</a> 第一章：操作系统简介</h2>\n<h3 id=\"11-什么是操作系统\"><a class=\"markdownIt-Anchor\" href=\"#11-什么是操作系统\">#</a> 1.1 什么是操作系统</h3>\n<ol>\n<li>\n<p>操作系统的定义</p>\n<p>操作系统（Operating System，OS）是一种复杂的<strong>系统软件</strong>，是不同于<strong>程序代码</strong>、<strong>数据结构</strong>、<strong>数据初始化文件的集合</strong>，可执行。（选择、填空、简答）</p>\n</li>\n<li>\n<p><strong>用户与硬件之间</strong>的接口</p>\n<p>操作系统与<strong>硬件部分相互作用</strong>，比并且为运行在计算机上的<strong>应用程序提供执行环境</strong>。（选择、填空）</p>\n</li>\n<li>\n<p>资源的管理者</p>\n<ul>\n<li>\n<p><strong>处理机管理</strong></p>\n<p>定义：决定把处理机先给哪个程序用，后给哪个程序用</p>\n</li>\n<li>\n<p><strong>内存管理</strong></p>\n<p>定义：给程序分配内存空间</p>\n</li>\n<li>\n<p><strong>设备管理</strong></p>\n<p>定义：完成证明分配设备，分配哪台设备，怎么和设备连接等</p>\n</li>\n<li>\n<p><strong>文件管理</strong></p>\n<p>定义：为每个文件分配空间、建立目录、对目录进行组织管理以及根据用户请求从外存（硬盘）读取数据或将数据写入外存（硬盘）</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"12-操作系统的发展\"><a class=\"markdownIt-Anchor\" href=\"#12-操作系统的发展\">#</a> 1.2 操作系统的发展</h3>\n<ol>\n<li>\n<p>发展历程</p>\n<ul>\n<li>\n<p><strong>单道 批处理系统</strong></p>\n<ul>\n<li>定义：单道批处理系统<strong>内存中只有一道作业</strong></li>\n<li>特点：<strong>自动性、顺序性、单道性</strong>（选择、填空）</li>\n<li>优点：减少了等待人工操作的时间</li>\n<li>缺点：CPU 资源不能得到充分的利用</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080901.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080901.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>多道 批处理系统</strong></p>\n<ul>\n<li>定义：由操作系统的<strong>作业调度程序按一定策略</strong>从后备作业队列中<strong>选择若干个作业调入内存</strong>，使他们共享 CPU 和系统中的各种资源</li>\n<li>特点：<strong>多道性、无序性、调度性、复杂性</strong>（选择、填空）</li>\n<li>优点：能够提高 CPU、内存和 IO 设备的利用率和系统的吞吐量（选择、简答）</li>\n<li>缺点：系统平均周转时间长（选择、简答）</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080902.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080902.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>分时 操作系统</strong></p>\n<ul>\n<li>定义：允许<strong>多个用户</strong>通过终端机<strong>同时使用</strong>计算机，每个用户通过终端与主机交互时都能得到快速响应。</li>\n<li>特点：<strong>多路性、独立性、及时性、交互性</strong>（选择、填空）</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080903.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080903.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>实时 操作系统</strong></p>\n<ul>\n<li>定义：实时系统必须<strong>及时响应</strong>外部时间的请求，在规定时间内完成对该事件的处理。主要用于<strong>实时控制</strong>和<strong>实时信息处理</strong>领域。（选择、填空）</li>\n<li>特点：<strong>多路性、独立性、及时性、交互性、可靠性</strong>（选择、填空）</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080904.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080904.png\" class=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>操作系统产品现状（可略）</p>\n<table>\n<thead>\n<tr>\n<th>操作系统</th>\n<th>运行主体</th>\n<th>实例（了解即可）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>主机</strong>操作系统</td>\n<td>大型主机</td>\n<td>IBM 的 OS / 360、OS / 390</td>\n</tr>\n<tr>\n<td><strong>服务器</strong>操作系统</td>\n<td>网络服务器</td>\n<td>Linux、Windows Server</td>\n</tr>\n<tr>\n<td><strong>微机</strong>操作系统</td>\n<td>微型计算机</td>\n<td>Windows7、Mac OS</td>\n</tr>\n<tr>\n<td><strong>嵌入式</strong>操作系统</td>\n<td>嵌入式设备</td>\n<td>Android、iOS</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ol>\n<h3 id=\"13-操作系统特征\"><a class=\"markdownIt-Anchor\" href=\"#13-操作系统特征\">#</a> 1.3 操作系统特征</h3>\n<ul>\n<li>现在操作系统都支持<strong>多任务</strong>，具有<strong>并发</strong>、<strong>共享</strong>、<strong>虚拟</strong>和<strong>异步性</strong>特征。\n<ul>\n<li>并发：两个或多个事件在<strong>同一时间间隔</strong>内发生</li>\n<li>共享：系统中的<strong>资源</strong>可供内存中多个并发执行的<strong>进程共同使用</strong>。</li>\n<li>虚拟：最常用<strong>内存虚拟化</strong>，用户感觉到的内存大于实际内存。</li>\n<li>异步性：进程以<strong>不可预知的速度</strong>向前推进。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"14-操作系统的功能\"><a class=\"markdownIt-Anchor\" href=\"#14-操作系统的功能\">#</a> 1.4 操作系统的功能</h3>\n<ol>\n<li>\n<p>管理计算机资源</p>\n<ul>\n<li>\n<p>内存管理</p>\n<ul>\n<li>\n<p>含义：</p>\n<p>内存管理的主要任务是为<strong>多道程序的运行提供良好的环境</strong>，方便用户<strong>使用内存</strong>，提高内存的利用率，以及从<strong>逻辑上扩充内存</strong>以实现<strong>虚拟存储</strong>。</p>\n</li>\n<li>\n<p>内容：</p>\n<ol>\n<li>\n<p>内存分配</p>\n<p>主要任务是<strong>为每道程序分配内存空间</strong>，可采用两种分配方式，即<strong>静态分配方式</strong>和<strong>动态分配方式</strong>。</p>\n<ul>\n<li>静态分配方式\n<ul>\n<li>先把内存划分先把内存划分定的区域</li>\n<li>大小数量不再变化</li>\n</ul>\n</li>\n<li>动态分配方式\n<ul>\n<li>根据进程实际，请求分配内存</li>\n<li>大小数量动态变化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>内存保护</p>\n<ol>\n<li>\n<p>主要任务：</p>\n<p>一是使操作系统<strong>内核的空间</strong>不会被用户随意访问，以保证系统的安全和稳定；</p>\n<p>二是确保<strong>每道用户程序</strong>都在<strong>自己的内存空间</strong>中运行，互不干扰。</p>\n</li>\n<li>\n<p>内存保护的方式：</p>\n<ol>\n<li>\n<p>采用界限寄存器存放允许程序访问的地址区间的上限和下限。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080905.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080905.png\" class=\"\"></p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>地址映射</p>\n<p><strong>含义：<strong>CPU 执行程序过程中访问内存时，需要把</strong>程序的逻辑地址转变为物理地址</strong>，这个转换过程称为<strong>地址映射</strong>。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080906.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080906.png\" class=\"\"></p>\n</li>\n<li>\n<p>内存扩充</p>\n<p><strong>含义：<strong>借助于</strong>虚拟技术</strong>，从<strong>逻辑</strong>上扩充内存容量，使系统能够向用户提供比物理内存大的存储容量。</p>\n<p>👉<strong>请求调入：</strong></p>\n<p>允许系统在<strong>装入一部分用户程序</strong>时就启动该程序运行，在程序运行过程中<strong>若发现要执行的指令或访问的数据尚未装入内存</strong>，通过<strong>请求调入将需要指令或数据装入内存。</strong></p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080907.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080907.png\" class=\"\"></p>\n<p>👉<strong>置换功能：</strong></p>\n<p>在请求调入时，<strong>若发现内存空间不足</strong>，需要<strong>先将内存中的一部分内容换到外存中</strong>，以便<strong>腾出内存空间</strong>装入当前需要的内容。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080908.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080908.png\" class=\"\"></p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>进程管理</p>\n<ul>\n<li>内容：进程的描述与组织、进程控制、进程同步、进程通信及进程调度。</li>\n</ul>\n</li>\n<li>\n<p>设备管理</p>\n<ul>\n<li>含义：设备管理主要完成用户的<strong> I/O 请求</strong>，为用户<strong>分配 I/O 设备</strong>。</li>\n<li>功能：\n<ol>\n<li><strong>缓冲管理</strong></li>\n<li><strong>设备分配</strong></li>\n<li><strong>设备处理</strong></li>\n<li><strong>设备独立性和虚拟设备</strong> (设备独立性功能使应用程序独<br>\n立于物理设备)</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>文件管理</p>\n<ul>\n<li>\n<p>功能：</p>\n<ol>\n<li>\n<p>文件存储空间的管理</p>\n<p>为每个文件分配必要的<strong>外存空间</strong>，<strong>提高外存利用率</strong>，并能有助于<strong>提高访问文件的速度</strong>。</p>\n</li>\n<li>\n<p>目录管理</p>\n<p>为每个文件建立<strong>目录项</strong>并对众多目录项进行有效组织。目录项包括文件名、文件属性及文件的地址等信息。</p>\n</li>\n<li>\n<p>文件的读、写管理和存取控制</p>\n<p>根据用户的请求，<strong>从外存中读取数据</strong>或<strong>将数据写入外存</strong>。防止未经审核的用户存取文件，防止冒名顶替存取文件，防止以不正确的方式使用文件。</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>提供用户接口</p>\n<ul>\n<li>命令接口\n<ul>\n<li>目的：为了便于用户与计算机系统的交互</li>\n<li>分类：联机用户接口和脱机用户接口</li>\n<li>联机：常命令接口由一组键盘操作命令和命令解释程序组成</li>\n<li>脱机：为批处理作业的用户提供，也称为批处理用户接口</li>\n</ul>\n</li>\n<li>图形用户接口\n<ul>\n<li>用户可以轻松地通过<strong>选择窗口、菜单、对话框、滚动条、图标等</strong>简单的操作来完成对作业和任务的提交与控制。</li>\n</ul>\n</li>\n<li>程序接口\n<ul>\n<li>用户程序接口指的是<strong>应用程序</strong>和系统的<strong>核心程序</strong>的接口，就是<strong>系统调用</strong>。</li>\n<li>系统调用是一组预先定义好的模块，它们提供<strong>一条管道</strong>让应用程序或用户能由此得到<strong>核心程</strong>序的服务。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"15-操作系统的体系结构\"><a class=\"markdownIt-Anchor\" href=\"#15-操作系统的体系结构\">#</a> 1.5 操作系统的体系结构</h3>\n<ol>\n<li>简单的监控程序模型\n<ul>\n<li>功能简陋，任意时刻系统中只能运行一个任务 ，保证了对系统信息的互斥访问，保护了系统数据的安全。</li>\n</ul>\n</li>\n<li>单体结构模型一\n<ul>\n<li>所有的软件和数据结构都放置在 - 个逻辑模块中，对外层的用户程序提供一个完整的内核界面 —— 系统调用。</li>\n</ul>\n</li>\n<li>层次结构模型\n<ul>\n<li>基本思想是将操作系统分解为多个小的，容易理解的层。系统功能被隔离在不同层中。</li>\n</ul>\n</li>\n<li>客户 / 服务器模型与微内核结构\n<ul>\n<li>核心思想是核心功能外移，即把传统操作系统内核中的一些组成部分放到内核之外作为 - 个独立的服务器进程来实现。</li>\n</ul>\n</li>\n<li>动态可扩展结构模型\n<ul>\n<li>基本思想就是在运行过程中，能够动态地实现系统行为扩展的结构，也可称之为弹性结构。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"16-指令的执行\"><a class=\"markdownIt-Anchor\" href=\"#16-指令的执行\">#</a> 1.6 指令的执行</h3>\n<ol>\n<li>\n<p><strong>指令周期</strong></p>\n<ul>\n<li><strong>程序是具有独立功能的一组指令的集合</strong>，程序的执行就是按照某种控制流执行指令的过程。</li>\n<li>一个<strong>单一指令</strong>需要的<strong>处理</strong>称为<strong>指令周期</strong>。</li>\n<li>一个指令周期可以划分为两个步骤，分别是<strong>取指周期</strong>和<strong>执行周期</strong>。</li>\n<li><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080909.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080909.png\" class=\"\"></li>\n<li>** 程序计数器 (PC)<strong> 保存有下一次要取的指令的地址。取到的指令被放置在处理器的</strong>指令寄存器 (IR)** 中。</li>\n</ul>\n</li>\n<li>\n<p><strong>取指令和执行指令</strong></p>\n<p>指令中包含确定处理器要采取动作的位，处理器解释指令并执行要求的动作。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080910.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21080910.png\" class=\"\"></p>\n<p>👉动作分类：</p>\n<ul>\n<li><strong>处理器与存储器</strong>之间的<strong>指令或数据传送</strong>操作</li>\n<li><strong>处理器与 I/O 设备</strong>之间的<strong>指令或数据传送</strong>操作</li>\n<li><strong>算术运算</strong>操作或<strong>逻辑运算</strong>操作</li>\n<li><strong>控制</strong>操作，即<strong>修改指令的执行顺序</strong>的操作</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"第二章进程管理重点\"><a class=\"markdownIt-Anchor\" href=\"#第二章进程管理重点\">#</a> 第二章：进程管理（重点）</h2>\n<h3 id=\"21-进程的描述\"><a class=\"markdownIt-Anchor\" href=\"#21-进程的描述\">#</a> 2.1 进程的描述</h3>\n<h4 id=\"211程序的顺序执行与并发执行\"><a class=\"markdownIt-Anchor\" href=\"#211程序的顺序执行与并发执行\">#</a> 2.1.1 程序的顺序执行与并发执行</h4>\n<ol>\n<li>\n<p>顺序执行</p>\n<ul>\n<li>含义：先进入内存的程序先执行，在一个程序执行完毕之前，不能执行其他程序</li>\n<li>特点：<strong>顺序性、封闭性、可再现性</strong></li>\n</ul>\n</li>\n<li>\n<p>并发执行</p>\n<ul>\n<li>含义：程序并发执行是指<strong>同一时间间隔内</strong>运行多个程序。一个程序执行结束前，可以运行其他程序</li>\n<li>特点：<strong>间断性、失去封闭性、不可再现性</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>宏观并行</strong>：用户看到多个程序同时向前推进</p>\n<p><strong>微观串行</strong>：任意时刻<strong>一个 CPU</strong> 上只有<strong>一个程序</strong>在执行</p>\n</li>\n</ol>\n<h4 id=\"212进程的概念\"><a class=\"markdownIt-Anchor\" href=\"#212进程的概念\">#</a> 2.1.2 进程的概念</h4>\n<ul>\n<li>\n<p>定义：</p>\n<ul>\n<li>\n<p>进程是允许并发执行的<strong>程序</strong>在某个数据集合上的<strong>运行过程</strong></p>\n</li>\n<li>\n<p>进程是由<strong>正文段、用户数据段及进程控制块</strong>共同组成的执行环境</p>\n<table>\n<thead>\n<tr>\n<th>正文段</th>\n<th>存放被执行的机器指令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>用户数据段</strong></td>\n<td><strong>存放用户数据</strong></td>\n</tr>\n<tr>\n<td><strong>进程控制块</strong></td>\n<td><strong>存放进程的运行环境</strong></td>\n</tr>\n</tbody>\n</table>\n</li>\n</ul>\n</li>\n<li>\n<p>特征：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特征</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">并发性</td>\n<td style=\"text-align:center\">多个进程实体能在一 - 段时间间隔内同时运行<br /><strong>并发性是进程和现代操作系统的重要特征</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">动态性</td>\n<td style=\"text-align:center\">进程是实体的执行过程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">独立性</td>\n<td style=\"text-align:center\">独立运行和资源调度的基本单位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">异步性</td>\n<td style=\"text-align:center\">进程的执行时断时续 ，何时执行、何时暂停都无法预知</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">结构特征</td>\n<td style=\"text-align:center\">进程实体包括用户<strong>正文段、 用户数据段</strong>和<strong>进程控制块</strong></td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>进程与程序的比较：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">程序</th>\n<th style=\"text-align:center\">进程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">动态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">永久</td>\n<td style=\"text-align:center\">暂时</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">指令集合</td>\n<td style=\"text-align:center\">包括正文段、用户数据段、进程控制块</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>进程和程序的联系</p>\n<ol>\n<li>进程是程序的一次执行</li>\n<li>一个程序可以对应多个进程</li>\n<li>同一个程序可以在不同的数据集合上运行，构成不同的进程</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"213-进程控制块pcb\"><a class=\"markdownIt-Anchor\" href=\"#213-进程控制块pcb\">#</a> 2.1.3 进程控制块（PCB）</h4>\n<ul>\n<li>进程实体包括用户正文段、用户数据段和进程控制段</li>\n<li>含义：进程控制块是进程实体的一部分，是操作系统中最重要的数据结构。<strong>记录</strong>了操作系统所需要的、用于<strong>描述进程</strong>及<strong>控制进程</strong>运行所需的<strong>全部信息</strong></li>\n<li>包含的信息\n<ol>\n<li>进程标识符信息：用于唯一标识一个进程</li>\n<li>处理机状态信息\n<ol>\n<li>通用寄存器</li>\n<li>指令计数器</li>\n<li>程序状态字 PSW</li>\n<li>用户栈指针</li>\n</ol>\n</li>\n<li>进程调度信息：包括进程状态信息、进程优先级和进程调度所需的其他信息</li>\n<li>进程控制信息：包括程序和数据的地址、进程同步和通信机制、资源清单、以及链接指针</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"214-进程的状态\"><a class=\"markdownIt-Anchor\" href=\"#214-进程的状态\">#</a> 2.1.4 进程的状态</h4>\n<ul>\n<li>就绪态</li>\n<li>执行态</li>\n<li>阻塞态</li>\n</ul>\n<h4 id=\"215-进程的组织\"><a class=\"markdownIt-Anchor\" href=\"#215-进程的组织\">#</a> 2.1.5 进程的组织</h4>\n<ol>\n<li>\n<p>链接方式</p>\n<ul>\n<li>把系统中具有<strong>相同状态</strong>的进程控制块 PCB 用其中的<strong>链接字</strong>连成一个对联</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081101.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081101.png\" class=\"\"></p>\n</li>\n<li>\n<p>索引方式</p>\n<ul>\n<li>系统根据所有进程的状态，建立索引表，索引表的每 - 一个表项指向一个 PCB 物理块</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081102.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081102.png\" class=\"\"></p>\n</li>\n<li>\n<p>进程队列</p>\n<ul>\n<li>把具有相同状态的进程控制块用队列组织起来</li>\n</ul>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081103.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081103.png\" class=\"\"></p>\n</li>\n</ol>\n<h3 id=\"22-进程的控制\"><a class=\"markdownIt-Anchor\" href=\"#22-进程的控制\">#</a> 2.2 进程的控制</h3>\n<h4 id=\"221-创建\"><a class=\"markdownIt-Anchor\" href=\"#221-创建\">#</a> 2.2.1 <strong>创建</strong></h4>\n<ul>\n<li>\n<p>什么情况下需要创建新进程呢？</p>\n<p>用户登录\t作业调度\t提供服务\t应用请求</p>\n</li>\n<li>\n<p>如何创建新进程？ /  创建新进程的步骤？</p>\n<ol>\n<li><strong>申请空白 PCB</strong></li>\n<li><strong>为新进程分配资源</strong></li>\n<li><strong>初始化进程控制块</strong></li>\n<li><strong>将新进程插入到就绪队列</strong></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"222-阻塞\"><a class=\"markdownIt-Anchor\" href=\"#222-阻塞\">#</a> 2.2.2 <strong>阻塞</strong></h4>\n<ul>\n<li>\n<p>什么情况下会进行进程的阻塞？</p>\n<p>请求系统服务\t启动某种操作\t新数据尚未达到\t无心工作可做</p>\n</li>\n<li>\n<p>完整进程阻塞的过程？</p>\n<ol>\n<li><strong>将进程的状态改为阻塞态</strong></li>\n<li><strong>将进程插入响应的阻塞队列</strong></li>\n<li><strong>转到进程调度程序，从就绪队列中选择进程为分配 CPU</strong></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"223-唤醒\"><a class=\"markdownIt-Anchor\" href=\"#223-唤醒\">#</a> 2.2.3 <strong>唤醒</strong></h4>\n<ul>\n<li>进程唤醒的过程？\n<ol>\n<li><strong>将进程从阻塞队列中移出</strong></li>\n<li><strong>将进程状态由阻塞状态改为就绪态</strong></li>\n<li><strong>将进程插入就绪队列</strong></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"224-终止\"><a class=\"markdownIt-Anchor\" href=\"#224-终止\">#</a> 2.2.4 <strong>终止</strong></h4>\n<ul>\n<li>完成进程终止的过程\n<ol>\n<li><strong>从进程 PCB 中读取进程状态</strong></li>\n<li><strong>若进程正在执行，则终止进程的执行</strong></li>\n<li><strong>释放资源</strong></li>\n<li><strong>将终止进程的 PCB 移出</strong></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"23-操作系统内核\"><a class=\"markdownIt-Anchor\" href=\"#23-操作系统内核\">#</a> 2.3 操作系统内核</h3>\n<p>​\t操作系统内核是计算机<strong>硬件的第一次扩充</strong>，与硬件关系密切</p>\n<h4 id=\"231-操作系统内核\"><a class=\"markdownIt-Anchor\" href=\"#231-操作系统内核\">#</a> 2.3.1 操作系统内核</h4>\n<ol>\n<li><strong>支撑功能</strong>：中断处理、始终管理、原语操作（原语操作也称原子操作，是一组在执行过程中不能被中断的操作。）</li>\n<li><strong>资源管理功能</strong>：进程管理、存储管理、设备管理</li>\n</ol>\n<h4 id=\"232-中断\"><a class=\"markdownIt-Anchor\" href=\"#232-中断\">#</a> 2.3.2 中断</h4>\n<ul>\n<li>\n<p>什么是中断 ？</p>\n<p>中断是<strong>改变</strong>处理器执行指令顺序的一种<strong>事件</strong>。出现中断时，计算机停止现在程序的运行，转向<strong>对这些中断事件的处理</strong>，处理结束后再<strong>返回到现行程序的间断处</strong></p>\n</li>\n<li>\n<p>为什么需要中断 ？</p>\n<p>引入中断机制后， <strong>CPU 可以与其他设备并行工作</strong>，能有效<strong>提高 CPU 的利用率</strong></p>\n</li>\n<li>\n<p>单重中断处理</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081104.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081104.png\" class=\"\"></p>\n</li>\n</ul>\n<h4 id=\"233-时钟管理\"><a class=\"markdownIt-Anchor\" href=\"#233-时钟管理\">#</a> 2.3.3 时钟管理</h4>\n<p>时钟是计算机系统的脉搏，计算机的很多活动都是由定时测量来驱动的</p>\n<ul>\n<li>\n<p>计算机系统中的时钟</p>\n<ol>\n<li>实时时钟 RTC（CMOS）</li>\n<li>OS 时钟</li>\n</ol>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081105.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081105.png\" class=\"\"></p>\n</li>\n<li>\n<p>时钟机制</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081106.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081106.png\" class=\"\"></p>\n</li>\n<li>\n<p>时钟程序功能</p>\n<ol>\n<li>维护日期和时间</li>\n<li>递减当前进程在一个时间片内的剩余执行时间，防止运行超时</li>\n<li>对 CPU 的使用情况记账</li>\n<li>递减报警计数器</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"234-系统调用\"><a class=\"markdownIt-Anchor\" href=\"#234-系统调用\">#</a> 2.3.4 系统调用</h4>\n<ul>\n<li>\n<p>什么是系统调用？</p>\n<p>系统调用是（一群）<strong>预先定义好的模块</strong>，提供<strong>一条管道</strong>让应用程序能由此到<strong>核心程序</strong>的服务。系统调用是<strong>系统程序</strong>与<strong>用户程序</strong>之间的<strong>接口</strong></p>\n</li>\n<li>\n<p>系统调用和一般函数调用的区别？</p>\n<p>区别 1: 系统调用运行在<strong>系统态</strong>，一般函数运行在<strong>用户态</strong></p>\n<p>区别 2:<strong> 执行过程不同</strong> (系统调用执行时，当前进程被中断)</p>\n<p>区别 3: 系统调用进行中断处理，多了<strong>系统开销</strong></p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081107.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081107.png\" class=\"\"></p>\n</li>\n<li>\n<p>系统调用的类型</p>\n<ol>\n<li><strong>进程控制类</strong>系统调用。创建、撤销进程；获得、改变进程属性。</li>\n<li><strong>文件操作类</strong>系统调用。创建、删除、打开、关闭和读 / 写文件。</li>\n<li><strong>设备管理类</strong>系统调用。请求、释放设备。</li>\n<li><strong>通信类</strong>系统调用。打开、关闭链接，交换信息。</li>\n<li><strong>信息维护类</strong>系统调用。返回系统当前日期、时间、版本号、用户数、空闲内存和磁盘空间大小等信息。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"24-进程同步\"><a class=\"markdownIt-Anchor\" href=\"#24-进程同步\">#</a> 2.4 进程同步</h3>\n<p>操作系统同步机制的<strong>主要任务</strong>就是要<strong>保证</strong>在多任务共享系统资源的情况下，<strong>程序执行能得到正确的结果</strong>。</p>\n<h4 id=\"241-进程同步的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#241-进程同步的基本概念\">#</a> 2.4.1 进程同步的基本概念</h4>\n<ol>\n<li>\n<p>两个任务</p>\n<ul>\n<li>一是<strong>对具有资源共享关系的进程</strong>，保证诸进程以<strong>互斥</strong>的方式<strong>访问临界资源</strong>。<strong>临界资源是必须以互斥方式访问的共享资源</strong>。</li>\n<li>二是对具有相互合作关系的进程，保证相互合作的诸进程协调执行。相互合作的进程可能同时存在资源共享的关系。</li>\n</ul>\n</li>\n<li>\n<p><strong>并发问题的解决</strong></p>\n<ul>\n<li>\n<p>如果 PIN 和 POUT<strong> 互斥</strong>地访问 count ，<strong>即 PIN 访问 count 时， POUT 就必须等待 PIN 对 count 的访问完全结束，再开始对 count 的访问</strong>，反之亦然。这样就不会出现计算结果的错误了。</p>\n<p>像 count 这样必须以<strong>互斥方式访问</strong>的<strong>共享资源</strong>称为<strong>临界资源</strong>。</p>\n</li>\n<li>\n<p>这里采用临界区<strong>加锁</strong>的方法，在临界区前加入<strong>进入区代码</strong>，在临界区之后加<strong>退出区代码</strong>来实现</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"242-同步机制应遵循的准则\"><a class=\"markdownIt-Anchor\" href=\"#242-同步机制应遵循的准则\">#</a> 2.4.2 同步机制应遵循的准则</h4>\n<p>同步机制应遵循的准则可以提供判断、选择和评价同步技术的参考依据。</p>\n<ol>\n<li>\n<p><strong>空闲让进</strong></p>\n<p><strong>当没有进程处于临界区时</strong>，表明临界资源处于空闲状态，应<strong>允许一个</strong>请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。</p>\n</li>\n<li>\n<p><strong>忙则等待</strong></p>\n<p>当己有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。</p>\n</li>\n<li>\n<p><strong>有限等待</strong></p>\n<p>对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免进程陷入无限等待的状态。</p>\n</li>\n<li>\n<p><strong>让权等待</strong></p>\n<p><strong>当进程申请不到共享资源的访问权时，应立即释放处理机</strong>，以兔进程陷入 “忙等” 状态，浪费 CPU 资源</p>\n</li>\n</ol>\n<h4 id=\"243-信号量机制\"><a class=\"markdownIt-Anchor\" href=\"#243-信号量机制\">#</a> 2.4.3 信号量机制</h4>\n<p>​\t在信号量机制中，用<strong>信号量的取值</strong>来表示资源的使用状况，或某种事件是否发生，以此为基础实现进程的同步。</p>\n<p>​\t对不同的共享资源设置被称为信号量的变量，<strong>用信号量的取值来表示资源的使用状况</strong>，或某种事件是否发生。</p>\n<p>​\t通过信号量的取值来判断进程是否能访问与信号量对应的共享资源。</p>\n<ol>\n<li>\n<p><strong>整形信号量机制</strong></p>\n<p><strong>如果整型量 &gt; 0，说明有可用资源；如果整型量≤0，说明资源忙，进程必须等待。</strong></p>\n<p>对于<strong>一次只允许一个进程访问</strong>的临界资源，可定义一个用于<strong>互斥</strong>的整型信号量，并将其<strong>初始化为 1</strong>。</p>\n<ol>\n<li>\n<p>具体操作</p>\n<p>整型信号量的值只能通过两个特定的原子操作 wait 和 signal 来改变</p>\n<p>wait 和 signal 操作</p>\n<pre><code class=\"language-伪代码\">wait(s) //用于申请资源\n&#123;\n    while s&lt;=0 do no-op;// s &lt;= 0时循环执行空操作\n    s=s-1;\n&#125;\n\nsignal(s) //用于释放资源\n&#123;\n    s=s+1;\n&#125;\n</code></pre>\n</li>\n<li>\n<p>总结</p>\n<ol>\n<li>整型信号量的值只能由 wait 和 siqnal 操作改变。</li>\n<li>wait 和 signal 操作都是<strong>原子操作</strong>，即这两个操作中对信号量的访问<strong>不能被中断</strong>。</li>\n<li>原子操作可以通过关中断来实现。</li>\n<li><strong>不同的资源对应不同的信号量，并不是系统中所有的资源都用同一个信号量表示</strong>。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>记录型信号量</strong></p>\n<ul>\n<li>优点：是不存在 “忙等” 采取了” 让权等待” 的策略</li>\n</ul>\n</li>\n<li>\n<p><strong>AND 型信号量机制</strong></p>\n<ol>\n<li>基本思想是将进程在整个运行过程中所需要的所有资源一次性地全部分配给进程，待该进程使用完后再一起释放。只要还有一个资源不能分配给该进程，其他所有可能为之分配的资源也不分配给它。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"244-经典的进程同步问题\"><a class=\"markdownIt-Anchor\" href=\"#244-经典的进程同步问题\">#</a> 2.4.4 经典的进程同步问题</h4>\n<ol>\n<li>\n<p>生产者一 消费者问题描述</p>\n<ul>\n<li>\n<p>问题描述</p>\n<ul>\n<li>生产者进程生产消息，并将消息提供给消费者进程消费。在生产者进程和消费者进程之间设置了一个具有 n 个缓冲区的缓冲池，生产者进程可以将它所产生的消息放入缓冲池的一个缓冲区中，消费者进程可以从一个缓冲区中取得一个消息消费。</li>\n<li>任意两个进程必须以互斥的方式访问公共缓冲池。当缓冲池空，没有可供消费的消息时，消费者进程必须阻塞等待。当缓冲池装满消息，没有空闲缓冲区时，生产者进程必须阻塞等待。</li>\n</ul>\n</li>\n<li>\n<p>需要解决的问题</p>\n<ul>\n<li>实现任意两个进程对缓冲池的互斥访问。</li>\n<li>实现对生产者进程和消费者进程的 “协调”</li>\n<li>即缓冲池中有消息时消费者进程才能执行取消息的操作。无消息时，阻塞消费者进程。缓冲池中有空闲缓冲区时，生产者进程才能执行放消息的操作。无空闲缓冲区时，阻塞生产者进程。</li>\n</ul>\n</li>\n<li>\n<p>信号量的设置</p>\n<ul>\n<li>设置一个互斥信号量 mulex ，用于实现对公共缓冲池的互斥访问，初值为 1。</li>\n<li>设置两个资源信号量，分别表示可用资源数。empty : 表示缓冲池中的空缓冲区数，初值为 n。full : 表示装有消息的缓冲区数，初值为 0 (一个缓冲区中放一个消息)。</li>\n</ul>\n</li>\n<li>\n<p>同步程序</p>\n<ul>\n<li>利用记录型信号量机制实现生产者 —— 消费者问题的同步代码如下:</li>\n</ul>\n</li>\n<li>\n<p>生产者进程同步代码</p>\n<pre><code class=\"language-伪代码\">Producer:\nbegin\nrepeat\n...\nproduce an item in nextp;\nwait(empty);//申请空缓冲区\nwait(mutex);//申请公共缓冲池的互斥访问权\nbuffer(in)=nextp; //将消息放入in指针指向的缓冲区\nin=(in+ 1) mod n; //in指针指向下一个空缓冲区\nsignal(mutex); //释放对公共缓冲池的互斥访问权\nsignal(full); //释放消息资源\nuntil false\nend\n</code></pre>\n</li>\n<li>\n<p>消费者进程同步代码</p>\n<pre><code class=\"language-伪代码\">Consumer:\nbegin \nrepeat\n...\nwait(ull); //申请消息\nwait(mutex); //申请公共缓冲池的互斥访问权\nnextc= buffer(out); //从out指针指向的缓冲区中取消息\nout=(out+ 1) mod h; //out指针指向下一个装有消息的缓冲区\nsignal(mutex); //释放对公共缓冲池的互斥访问权\nsignal(empty); //释放空缓冲区\nconsume item in nextc ;\nuntil false\nend\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"245-管程\"><a class=\"markdownIt-Anchor\" href=\"#245-管程\">#</a> 2.4.5 管程</h4>\n<ol>\n<li>\n<p>管程的定义</p>\n<p>管程是描述共享资源的数据结构和在数据结构上的共享资源管理程序的集合。其中包括变量的定义、变量的初始化代码，以及管理共享资源的过程。</p>\n</li>\n<li>\n<p>对管程的说明</p>\n<ul>\n<li><strong>管程是可供程序员调用的软件包</strong>，是一个由过程、变量及数据结构等组成的集合，它们组成一个特殊的模块或软件包。<strong>进程可以在任何需要的时候调用管程中的过程</strong>，但不能在管程外的过程中直接访问管程内的数据结构。</li>\n<li>每次只有一个进程调用管程执行，任意时刻管程中只能有一个活跃进程。</li>\n<li>管程是一种编程语言的构件</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"25-进程通信\"><a class=\"markdownIt-Anchor\" href=\"#25-进程通信\">#</a> 2.5 进程通信</h3>\n<p>​\t操作系统提供进程通信功能，以支持进程之间的信息交换。</p>\n<h4 id=\"251-共享存储器系统\"><a class=\"markdownIt-Anchor\" href=\"#251-共享存储器系统\">#</a> 2.5.1 共享存储器系统</h4>\n<p>​\t在共享存储器系统中，<strong>相互通信的进程共享某些数据结构或共享存储区</strong>，进程之间能够通过这些空间进行通信。共享存储器系统可分为两种类型。</p>\n<ol>\n<li>基于<strong>共享数据结构</strong>的通信方式。要求诸进程公用某些数据结构，以实现进程间的信息交换。</li>\n<li>基于<strong>共享存储区</strong>的通信方式。进程通过对共享存储区中的数据的读或写来实现通信。</li>\n</ol>\n<h4 id=\"252-消息传递系统\"><a class=\"markdownIt-Anchor\" href=\"#252-消息传递系统\">#</a> 2.5.2 消息传递系统</h4>\n<p>​\t进程间通过<strong>操作系统提供的一组通信程序</strong>传递格式化的信息。这种方式对应用程序隐藏了通信实现的细节使通信过程对用户是透明的。根据传递消息方式的不同，分为直接通信方式和间接通信方式。</p>\n<ol>\n<li><strong>直接通信方式</strong>。操作系统利用发送程序<strong>直接</strong>把消息发送给目标程序。</li>\n<li><strong>间接通信方式</strong>。进程之间的通信需要通过用于<strong>暂存</strong>消息的共享数据结构来实现，如信箱。该方式可以实现实时通信，又可以实现非实时通信。</li>\n</ol>\n<h4 id=\"253-管道\"><a class=\"markdownIt-Anchor\" href=\"#253-管道\">#</a> 2.5.3 管道</h4>\n<p>​\t<strong>管道</strong>是连接读写进程的<strong>一个特殊文件</strong>，也被称为管道文件。管道文件存在于<strong>外存</strong>中，其中的消息没有固定长度，能用于进程间大量的信息通信。向管道提供输入的发送进程以<strong>字符流</strong>的形式将大量的数据送入管道。接受管道输出的接收进程，从管道中接收数据。</p>\n<h4 id=\"254-消息缓冲队列\"><a class=\"markdownIt-Anchor\" href=\"#254-消息缓冲队列\">#</a> 2.5.4 消息缓冲队列</h4>\n<p>​\t用于本地进程之间的通信，包括<strong>数据结构、发送原语和接收原语</strong>。</p>\n<p>​\t发送进程<strong>发送消息</strong>时，先<strong>申请一个消息缓冲区</strong>，将要发送的消息<strong>从发送进程的发送区放入消息</strong></p>\n<p><strong>缓冲区</strong>。然后，<strong>调用发送原语</strong>将消息<strong>发送给接收进程</strong>，发送原语将发送缓冲区插入接收进程的消</p>\n<p>息缓冲队列。</p>\n<p>​\t接收消息的进程<strong>通过调用接收原语</strong>将该进程消息缓冲队列中的消息复制到自己的消息接收区。</p>\n<p>​\t消息缓冲区是一个结构型数据结构。</p>\n<p>​\t消息缓冲队列需要被当作<strong>临界资源</strong>，在发送原语和接收原语中<strong>对消息缓冲队列的访问</strong>需要<strong>进行互斥与同步</strong></p>\n<h3 id=\"26-线程\"><a class=\"markdownIt-Anchor\" href=\"#26-线程\">#</a> 2.6 线程</h3>\n<h4 id=\"261-线程的描述\"><a class=\"markdownIt-Anchor\" href=\"#261-线程的描述\">#</a> 2.6.1 线程的描述</h4>\n<p>​\t<strong>为了进一步提高程序的并发性 ，减少系统开销，在操作系统中引入了线程的概念</strong>。</p>\n<p>​\t引入线程作为独立调度和分派的单位，<strong>不独立拥有资源，而与其他线程共享同一进程的资源</strong>，减少了系统的时空开销。</p>\n<p>​\t<strong>线程的实质是把进程的任务划分成更小，具有独立功能的单位</strong>，以线程的形式来并发执行，以提高程序并发执行的程度。</p>\n<ol>\n<li>\n<p>线程的概念</p>\n<p><strong>线程是进程中的一个实体</strong>，是被系统独立调度和分派的基本单位。<strong>一个线程可以创建和撤销另一个线程。同一进程中的多个线程可以并发执行。</strong></p>\n</li>\n<li>\n<p>线程的分类</p>\n<p>用户级线程和内核级线程。</p>\n</li>\n<li>\n<p>线程的三种基本状态</p>\n<p>就绪、运行和阻塞。</p>\n<p>就绪态是线程一 - 旦获得 CPU 就可以投入运行的状态。</p>\n<p>运行态是线程获得 CPU 正在运行的状态。</p>\n<p>阻塞态是线程由于等待某个事件的发生而暂停执行的状态。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081108.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081108.png\" class=\"\"></p>\n</li>\n<li>\n<p>线程控制块（TCB）</p>\n<p>每个线程都由一个数据结构表示，包括它的<strong>基本状态、标识及记账信息</strong>，这个数据结构就是<strong>线程控制块</strong>。</p>\n<p>线程控制块记录了操作系统所需的，用于描述线程情况及控制线程运行所需的全部信息。</p>\n<p>线程控制块采用<strong>链接</strong>方式来组织，把<strong>同一进程中具有相同状态的 TCB 用指针链接成列</strong>。</p>\n</li>\n<li>\n<p>线程与进程的关系</p>\n<ol>\n<li><strong>资源和调度</strong>。<strong>线程是程序执行的基本单位，进程是拥有资源的基本单位。</strong></li>\n<li><strong>地址空间资源</strong>。<strong>不同进程的地址空间是相互独立的，而同一进程中的各线程共享同一地址空间。</strong></li>\n<li><strong>通信关系</strong>。进程之间的通信必须使用操作系统提供的进程间通信机制，而同一进程中的各线程间可以<strong>通过直接读或写全局变量</strong>来进行通信，甚至无需操作系统的参与。</li>\n<li><strong>并发性</strong>。多进程之间可以并发执行，多线程之间也可以并发执行，同 - 进程中的多个线程之间也可以并发执行。</li>\n<li><strong>系统开销</strong>。创建或撤销进程时，系统都要为之分配或回收资源，系统开销大。</li>\n<li><strong>本人说明：可以理解为线程是 java 的线程，进程是 windows 的一个软件</strong></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"262-线程的控制\"><a class=\"markdownIt-Anchor\" href=\"#262-线程的控制\">#</a> 2.6.2 线程的控制</h4>\n<p>​\t线程控制包括创建新线程、终止线程、线程调度和线程切换，以及线程由于等待某个事件的发生而被阻塞与该事件发生后线程被唤醒。</p>\n<p>​\t<strong>用户线程的创建通过调用线程库中的实用程序完成。</strong></p>\n<p>​\t<strong>内核线程的创建由内核完成。</strong></p>\n<p>​\t如果进程中一个用户线程被阻塞，则整个进程必须等待。</p>\n<p>​\t当被阻塞的线程所等待的事件发生时，则由有关进程唤醒原语<strong>将该线程所属的进程唤醒，然后由有关线程唤醒原语将该线程唤醒</strong></p>\n<p>​\t如果进程中的一个内核线程被阻塞，内核可以调度同一个进程中的另一个内核线程运行。</p>\n<p>​\t<strong>一个进程中的所有线程共享同一个地址空间</strong>和诸如打开的文件之类的其他资源。</p>\n<p>​\t<strong>一个线程对资源的任何修改都会影响同一个进程中其他线程的环境。</strong></p>\n<p>​\t<strong>同一进程中线程间共享内存和文件资源</strong>，各线程间可通过<strong>直接读写全局变量</strong>进行通信。</p>\n<p>​\t对于<strong>不同进程的线程间</strong>通信，则必须<strong>使用操作系统提供的线程间</strong>通信机制。</p>\n<hr>\n<h2 id=\"第三章进程调度与死锁重点\"><a class=\"markdownIt-Anchor\" href=\"#第三章进程调度与死锁重点\">#</a> 第三章：进程调度与死锁（重点）</h2>\n<h3 id=\"本章考试重点\"><a class=\"markdownIt-Anchor\" href=\"#本章考试重点\">#</a> 本章考试重点</h3>\n<ul>\n<li>进程调度\n<ul>\n<li>进程调度算法（选择、填空、简答、综合)</li>\n<li>实时系统中的调度概念及算法 (选择、填空、简答、综合)</li>\n<li>进程切换 (选择、填空、简答)</li>\n<li>多处理器调度 (选择、填空、简答)</li>\n</ul>\n</li>\n<li>死锁\n<ul>\n<li>死锁产生的原因、必要条件 (选择、填空、简答</li>\n<li>死锁的预防和避免 (选择、填空、简答)</li>\n<li>银行家算法 (选择、填空、简答、综合)</li>\n<li>死锁的检测和解除 (选择、填空、简答)</li>\n</ul>\n</li>\n<li>近三年分值分布: 21~ 26 分</li>\n</ul>\n<h3 id=\"31-进程调度的功能与时机\"><a class=\"markdownIt-Anchor\" href=\"#31-进程调度的功能与时机\">#</a> 3.1 进程调度的功能与时机</h3>\n<ol>\n<li>\n<p>功能</p>\n<p><strong>进程调度功能</strong>由操作系统内核的<strong>进程调度程序完成</strong>。</p>\n<p>进程调度的功能是<strong>按照某种策略和算法</strong>从<strong>就绪态</strong>进程中为<strong>当前空闲的 CPU</strong> 选择在其上运行的新进程。</p>\n</li>\n<li>\n<p>时机</p>\n<p>当一个进程运行结束、进程阻塞、中断返回、在支持抢占式调度的系统中<strong>有比当前运行进程优先级更高的进程到来</strong>、当前运行进程的<strong>时间片用完</strong>，系统都会通过<strong>执行进程调度程序</strong>重新进行进程调度。（优先级高、当前时间片用完）</p>\n</li>\n</ol>\n<h3 id=\"32-进程调度算法综合题\"><a class=\"markdownIt-Anchor\" href=\"#32-进程调度算法综合题\">#</a> 3.2 进程调度算法（综合题）</h3>\n<p>进程调度算法是指从<strong>就绪态</strong>进程中选择一个进程为其分配 CPU ，<strong>使其进入执行态</strong>的算法。也就是说进程调度算法要 **“决定” 把 CPU 分配给就绪队列中的哪个进程 **。</p>\n<p>进程调度由操作系统内核中的进程调度程序完成。</p>\n<h4 id=\"321-选择调度方式和算法的若干准则\"><a class=\"markdownIt-Anchor\" href=\"#321-选择调度方式和算法的若干准则\">#</a> 3.2.1 选择调度方式和算法的<strong>若干准则</strong></h4>\n<ol>\n<li>\n<p><strong>周转时间短</strong></p>\n<p><strong>周转时间</strong>是指从<strong>作业被提交给系统开始，到作业完成为止</strong>的这段时间间隔。</p>\n<p>包括<strong> 4 部分</strong>时间：</p>\n<p>➢作业在<strong>外存后备队列上等待调度的时间</strong>，</p>\n<p>➢进程在<strong>就绪队列上等待进程调度的时间</strong>，</p>\n<p>➢进程在<strong> CPU 上执行的时间</strong>，</p>\n<p>➢进程等待<strong> I/O 操作完成的时间</strong>。</p>\n<ul>\n<li>\n<p>如果系统中<strong>有 n 个作业</strong>，系统的<strong>平均周转时间</strong>等于 n 个作业的周转时间<strong>之和除以 n</strong>。</p>\n<p>作业的周转时间 T 与系统为它提供的服务时间 Ts 之比为 W， W 称为<strong>带权周转时间</strong>。</p>\n<p>服务时间<strong> Ts 是一个作业在 CPU 上执行的总时间</strong>。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>响应时间快</strong></p>\n<p>响应时间是指<strong>用户提交一个请求开始</strong>至<strong>系统首次产生响应</strong>的时间为止的一段时间。</p>\n<p>它包括<strong> 3 部分</strong>时间：从<strong>输入设备信息传送到处理机</strong>的时间、<strong>处理机对请求信息进行处理</strong>的时间，以及<strong>将所形成的响应信息回送到终端显示器</strong>的时间。</p>\n<p><strong>对于交互式系统，响应时间是衡量系统时间性能的重要指标。</strong></p>\n</li>\n<li>\n<p><strong>截止时间的保证</strong></p>\n<p>截止时间是指某个任务<strong>必须开始的最迟时间或必须完成的最迟时间</strong>。是评价实时系统性能的重要指标。</p>\n</li>\n<li>\n<p><strong>系统吞吐量高</strong></p>\n<p><strong>吞吐量</strong>是指<strong>单位时间内完成的作业数</strong>。是评价系统性能的重要指标之一。</p>\n</li>\n<li>\n<p>处理机利用率好</p>\n<p>CPU 是计算机系统中影响时间性能的最重要的硬件资源，在多任务系统中，进程调度算法对 CPU 的利用率有很大影响。因此，在<strong>选择和设计进程调度算法时应该考虑使 CPU 的利用率尽可能高</strong>。</p>\n</li>\n</ol>\n<h4 id=\"322-先来先服务调度算法fcfs\"><a class=\"markdownIt-Anchor\" href=\"#322-先来先服务调度算法fcfs\">#</a> 3.2.2 先来先服务调度算法 (<strong>FCFS</strong> )</h4>\n<ol>\n<li>\n<p>调度算法</p>\n<p>在进程调度中，FCFS 就是从就绪队列的队首选择最先到达就绪队列的进程，为该进程分配 CPU。（First-Come ， First- Served）</p>\n</li>\n<li>\n<p>性能分析</p>\n<p>FCFS<strong> 适合长进程</strong>，有利于 CPU 繁忙的进程。</p>\n</li>\n<li>\n<p>综合题</p>\n<pre><code>有3个进程p1、p2和p3 ，分别在0、1、 2时刻进入系统，需要的运行(服务)时间长度分别为24、3、3 .，按照FCFS调度算法， 3个进程的等待时间和周转时间分别是?\n\n[答案]\n等待时间=开始时间-进入时间，周转时间=运行时间+等待时间。\n注意：开始运行时间从0开始计算\n</code></pre>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">进程名</th>\n<th style=\"text-align:center\">进入系统时间</th>\n<th style=\"text-align:center\">开始运行</th>\n<th style=\"text-align:center\">运行时间</th>\n<th style=\"text-align:center\">等待时间</th>\n<th style=\"text-align:center\">周转时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">p1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">24</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">p2</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">26</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">p3</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">28</td>\n</tr>\n</tbody>\n</table>\n<pre><code>此种情况下平均周转时间T和平均带权周转时间W为多少?\n\n[答案] T=(24+26+ 28)/3=26\n\t  W=(24/24+ 26/3+ 28/3)/3-6.33\n\n[解析]\n\t等待时间=开始时间-进入时间\n\t周转时间=运行时间+等待时间\n\t系统的平均周转时间:各个进程的周转时间总和/进程数\n\t带权周转时间:周转时间/运行时间\n\t平均带权周转时间:各个进程的带权周转时间总和/进程数\n</code></pre>\n</li>\n</ol>\n<h4 id=\"323-短进程优先调度算法-shortest-process-firstspf\"><a class=\"markdownIt-Anchor\" href=\"#323-短进程优先调度算法-shortest-process-firstspf\">#</a> 3.2.3 短进程优先调度算法 (Shortest-Process-First，SPF)</h4>\n<ul>\n<li>算法的缺陷\n<ol>\n<li><strong>对长进程不利</strong>。如果系统中不断有短进程到来长进程<strong>可能长时间得不到调度</strong>。</li>\n<li><strong>不能保证紧迫进程的及时处理</strong>，因<strong>本算法不考虑进程的紧迫程度</strong>。</li>\n<li><strong>进程的长度由用户估计而定，可能有偏差</strong>。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"324-优先权调度算法\"><a class=\"markdownIt-Anchor\" href=\"#324-优先权调度算法\">#</a> 3.2.4 优先权调度算法</h4>\n<ol>\n<li>\n<p>调度算法</p>\n<p>​\t在使用优先权调度的系统中， 每个进程都有一个与之关联的优先权。</p>\n<p>​\t当使用优先权调度算法进行进程调度时，系统将 CPU 分配给就绪队列中<strong>优先权值最高</strong>的进程。</p>\n</li>\n<li>\n<p>优先权调度算法的分类</p>\n<p>① 非抢占式优先权调度算法高优先权进程一旦得到处理机， 便一直运行下去直到完成或由于某事件使该进程主动放弃处理机。</p>\n<p>​\t即使更高优先权进程到来，也不能剥夺当前进程的 CPU 使用权，只能在就绪队列中等待。</p>\n<p>② 抢占式优先权调度算法</p>\n<p>​\t新到达的就绪进程与正在运行进程的优先权相比较，若<strong>新到达进程的优先权高于当前正在运行进程的优先权</strong>，则<strong>系统会抢占 CPU</strong> ，分配给新到达的进程，正在执行的进程暂停执行。</p>\n</li>\n<li>\n<p>优先权的类型</p>\n<p>根据优先权的变化特点将优先权的类型分为<strong>静态和动态</strong>。</p>\n<p>① <strong>静态优先权</strong>。在创建时确定，在进程的整个运行期间不变。</p>\n<p>② <strong>动态优先权</strong>。进程创建时被赋予的优先权，随进程的推进或随其等待时间的增加而改变。<strong>动态优先权调度算法可以使系统获得更好的调度性能</strong>。</p>\n</li>\n<li>\n<p>优先权调度算法存在的问题和解决方案</p>\n<p>① 问题。无穷阻塞或称饥饿问题。指就绪态进程因得不到 CPU 而等待的状态。优先权调度算法可能使某个低优先权进程无穷等待。</p>\n<p>② 解决方案。<strong>老化 (Aging) 技术。逐渐增加在系统中等待时间很长进程的优先权。</strong></p>\n</li>\n</ol>\n<h4 id=\"325时间片轮转调度算法\"><a class=\"markdownIt-Anchor\" href=\"#325时间片轮转调度算法\">#</a> 3.2.5 时间片轮转调度算法</h4>\n<p>​\t时间片轮转调度算法在现代分时系统中广泛使用， UNIX、Linux、 Windows 操作 系统都采用基于时间片轮转、支持优先权和抢占式调度的混合式进程调度算法。</p>\n<ol>\n<li>\n<p>时间片轮转调度算法</p>\n<p>时间片是一个较小的时间单位，通常为 10~ 100ms。每当进程在 CPU_上连续运行的时间等于一一个时间片长度时，操作系统在时钟中断处理过程中会抢占 CPU，进行进程切换，用新的就绪进程替代当前进程，<strong>被替换的当前进程重新回到就绪队列中</strong>。</p>\n</li>\n<li>\n<p>时间片大小的确定</p>\n<p><strong>时间片太长</strong>，可降低进程的周转时间，但可能造成交互用户的响应时间过长。</p>\n<p><strong>时间片太短</strong>，会增加进程切换和调度的开销，系统的平均周转时间也较长。</p>\n<p>① <strong>系统对响应时间的要求</strong>。响应时间越短，时间片取值应该越小。</p>\n<p>设系统响应时间为 T ，进程数目为 N，时间片为 q ，则有 T=Nq ，即在 N - 定的情况下， T 的大小取决于 q。</p>\n<p>② <strong>就绪队列中进程的数目</strong>。进程越多，响应时间越长。当设定了系统的最长响应时间值后，时间片的大小就与系统允许的最大进程数成反比。</p>\n<p>③ <strong>系统的处理能力</strong>。必须保证系统支持的基本命令能在一个时间片内执行完。</p>\n</li>\n<li>\n<p>时间片轮转调度算法的性能评价</p>\n<p>时间片轮转调度算法的性能<strong>依赖于时间片的大小</strong>。</p>\n<p>时间片很大，与先来先服务算法一样。</p>\n<p>时间片很小，会增加 CPU 用于进程切换和进程调度的开销。</p>\n</li>\n</ol>\n<h4 id=\"326-多级队列调度\"><a class=\"markdownIt-Anchor\" href=\"#326-多级队列调度\">#</a> 3.2.6 多级队列调度</h4>\n<p>​\t通常根据<strong>不同进程对响应时间要求的不同</strong>，采用<strong>多级队列调度算法</strong></p>\n<p>​\t多级队列调度算法，根据<strong>进程占用内存的大小、优先权或进程类型</strong>，将就绪队列分成多个独立队列，<strong>进程被永久地分配到一个队列，每个队列有自己的调度算法</strong>。<strong>降低了进程调度的开销</strong></p>\n<h4 id=\"327多级反馈队列调度\"><a class=\"markdownIt-Anchor\" href=\"#327多级反馈队列调度\">#</a> 3.2.7 多级反馈队列调度</h4>\n<p>​\t采用多级队列调度，对低优先权进程会存在无穷阻塞 (饥饿) 的问题。</p>\n<p>​\t多级反馈队列调度算法可以弥补这些不足。在采用多级反馈队列调度的系统中建立多个优先权不同的就绪队列，为每个队列赋予大小不同的时间片。</p>\n<p>​\t有一种<strong>反馈策略规定</strong>：队列优先权越高，时间片越短。新进程被创建后，先插入预先权最高的队列。仅当高优先权队列空时，才调度优先权次之的队列。同一队列中， 采用时间片轮转调度算法。使用 CPU 时间过多的进程会被移到优先权较低的队列中，在较低优先权队列中等待时间过长的进程会被移到较高优先权队列中。</p>\n<p>​\t多级反馈队列调度算法的设计要考虑以下几个方面的问题。</p>\n<ol>\n<li>就绪队列的数量。</li>\n<li>根据进程优先权确定进程应该进入哪个就绪队列的算法。</li>\n<li>用以确定进程何时转移到较高优先权队列的算法。</li>\n<li>用以确定进程何时转移到较低优先权队列的算法。</li>\n<li>用以确定进程在需要服务时应该进入哪个队列的算法。</li>\n</ol>\n<h3 id=\"33-实时系统中的调度\"><a class=\"markdownIt-Anchor\" href=\"#33-实时系统中的调度\">#</a> 3.3 实时系统中的调度</h3>\n<h4 id=\"331-实现实时调度的基本条件\"><a class=\"markdownIt-Anchor\" href=\"#331-实现实时调度的基本条件\">#</a> 3.3.1 实现实时调度的基本条件</h4>\n<p>​\t为了满足实时系统对截止时间的要求，实现实时调度应具备下列几个条件:</p>\n<ol>\n<li>\n<p><strong>提供必要的调度信息</strong><br>\n① 就绪时间<br>\n② 开始截止时间和完成截止时间<br>\n③ 处理时间<br>\n④ 资源要求<br>\n⑤优先级</p>\n</li>\n<li>\n<p><strong>系统处理能力强</strong></p>\n<p>（具体没啥用，随便看看）</p>\n<p>​\t在实时系统中，通常有多个实时进程，若处理机的处理能力不够强，处理速度不够快，若使某些实时进程不能得到及时处理，可能发生难以预料的后果。</p>\n<p>​\t可通过提高处理机的处理能力或增加处理机的数量以提高系统的处理能力。</p>\n</li>\n<li>\n<p><strong>采用抢占式调度机制</strong></p>\n<ol>\n<li><strong>基于时钟中断的抢占式优先权调度算法</strong><br>\n若高优先权大于正在执行的进程，就等当前进程到时钟中断的时候抢占</li>\n<li><strong>立即抢占的优先权调度算法</strong><br>\n一旦接收到就给当前执行的进程一个中断信号，然后抢占</li>\n</ol>\n</li>\n<li>\n<p>具有快速切换机制<br>\n就是需要进程<strong>对外部中断做出快速响应</strong>和<strong>快速的进程切换</strong></p>\n</li>\n</ol>\n<h4 id=\"332-常用的实时调度算法\"><a class=\"markdownIt-Anchor\" href=\"#332-常用的实时调度算法\">#</a> 3.3.2 常用的实时调度算法</h4>\n<ol>\n<li>\n<p>最早截止时间优先 EDF 算法</p>\n<p>根据进程的开始截止时间确定进程的优先级，<strong>截止时间越早，进程的优先级越高</strong>，越优先获得处理机。</p>\n</li>\n<li>\n<p>最低松弛度优先 LLF 算法</p>\n<p>​\t<strong>松弛度用来表示个实时进程的紧迫程度</strong>。</p>\n<p>​\t如果一个进程的完成截止时间为 T ，当前时间为 Tc 处理完该任务还需要的时间为 Ts，则松弛度 L 的计算式表示为: L=T-Tc-Ts</p>\n<p>​\t<strong>调度时，每次选择松弛度最小的进程</strong>。该算法按松弛度排序，<strong>让松弛度最小的进程排在就绪队列队首</strong>。</p>\n</li>\n</ol>\n<h3 id=\"34-进程切换\"><a class=\"markdownIt-Anchor\" href=\"#34-进程切换\">#</a> 3.4 进程切换</h3>\n<p>​\t含义：<strong>用新选择的进程替换原来的进行进程</strong></p>\n<ul>\n<li>进程切换包括的步骤如下:\n<ol>\n<li><strong>保存 CPU 上下文环境。</strong></li>\n<li><strong>更新进程控制块。</strong></li>\n<li><strong>修改进程状态，把执行态改为就绪态或者阻塞态。</strong></li>\n<li><strong>将被替换进程的进程控制块移到就绪队列或阻塞队列。</strong></li>\n<li><strong>执行新进程，并更新改进程的进程控制块。</strong></li>\n<li><strong>更新内存管理的数据结构。</strong></li>\n<li><strong>恢复上下文。</strong></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"35-多处理器调度\"><a class=\"markdownIt-Anchor\" href=\"#35-多处理器调度\">#</a> 3.5 多处理器调度</h3>\n<h4 id=\"351-多处理器系统的类型\"><a class=\"markdownIt-Anchor\" href=\"#351-多处理器系统的类型\">#</a> 3.5.1 多处理器系统的类型</h4>\n<p>根据处理器的耦合程度，分为紧密耦合和松弛耦合；根据处理器的结构，分为对称和非对称。</p>\n<ol>\n<li>\n<p>紧密耦合和松弛耦合</p>\n<ol>\n<li>紧密耦合</li>\n<li>松弛耦合</li>\n</ol>\n</li>\n<li>\n<p>对称和非对称</p>\n<p>对称属于同构，非对称在功能和结构上各不相同。</p>\n</li>\n</ol>\n<h4 id=\"352-多处理器系统中的进程分配方式\"><a class=\"markdownIt-Anchor\" href=\"#352-多处理器系统中的进程分配方式\">#</a> 3.5.2 多处理器系统中的进程分配方式</h4>\n<ol>\n<li>\n<p>对称多处理器系统中的进程分配方式</p>\n<ol>\n<li>\n<p>静态分配</p>\n<p>操作系统为每个处理器建立 - 个专门的就绪队列</p>\n</li>\n<li>\n<p>动态分配</p>\n<p>每个进程经过多次调度，每次获得的不一定是同一个处理器。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>非对称多处理器系统 (MPS) 中的进程分配方式</p>\n<p>采<strong>用主一从式</strong>操作系统，操作系统的核心部分驻留在一台主机上，而从机上只运行用户程序，只有主机 执行调度程序，所有从机的进程都是由主机分配的。</p>\n</li>\n</ol>\n<h4 id=\"353-进程线程调度方式\"><a class=\"markdownIt-Anchor\" href=\"#353-进程线程调度方式\">#</a> 3.5.3 进程（线程）调度方式</h4>\n<ol>\n<li>\n<p>自调度</p>\n<p>采用自调度的系统中设置<strong>有个公共的就绪队列，任何一个空闲的处理器都可以自行从该就绪队列中选取一个进程或者一个线程运行</strong>。</p>\n<ul>\n<li>\n<p>优点</p>\n<p>➢ 易移植</p>\n<p>➢ 有利于提高 CPU 的利用率</p>\n</li>\n<li>\n<p>缺点</p>\n<p>➢ 瓶颈问题，容易产生并发问题</p>\n<p>➢ 低效性，高速缓冲的命中率较低</p>\n<p>➢ 线程切换频繁</p>\n</li>\n</ul>\n</li>\n<li>\n<p>成组调度</p>\n<p>系统<strong>将一组相互合作的进程或线程同时分配到一组处理器上运行，进程或线程与处理器对应</strong>。</p>\n<ul>\n<li>优点:<br>\n➢ 减少线程切换，改善系统性能。<br>\n➢ 减少调度开销。一次调度一组，减少调度频率。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"36-死锁\"><a class=\"markdownIt-Anchor\" href=\"#36-死锁\">#</a> 3.6 死锁</h3>\n<h4 id=\"361-产生死锁的原因和必要条件\"><a class=\"markdownIt-Anchor\" href=\"#361-产生死锁的原因和必要条件\">#</a> 3.6.1 产生死锁的原因和必要条件</h4>\n<p>​\t<strong>当多个进程可能竞争数量有限的资源。若一个进程所申请的资源被其他处于阻塞状态的进程占有，该进程就会因为不能获得所申请的资源而被阻塞。</strong></p>\n<p>​\t这种由于多个进程竞争共享资源而引起的<strong>进程不能向前推进的僵持状态</strong>称为<strong>死锁</strong>。</p>\n<p><strong>产生死锁的原因</strong>：竞争共享资源且分配资源的顺序不当。</p>\n<p>产生死锁的必要条件：</p>\n<ol>\n<li>\n<p><strong>互斥条件</strong></p>\n<p>指一个进程在访问资源的过程中，其他进程不能访问该资源</p>\n</li>\n<li>\n<p><strong>请求和保持条件</strong></p>\n<p>进程已经保持了至少一个资源，又提出了新的资源要求且已经被其他进程占有，此时进程阻塞，但又对已经获得的资源保持不放，使得其他进程无法使用被保持的资源。</p>\n</li>\n<li>\n<p><strong>不剥夺条件</strong></p>\n<p>进程已经获得的资源不能被剥夺，只能由进程自己释放。</p>\n</li>\n<li>\n<p><strong>环路等待条件</strong></p>\n<p>在发生死锁时，必然存在一个进程申请资源的环形链。</p>\n<p>注意：只有上述 4 个条件同时满足时才会发生死锁。</p>\n</li>\n</ol>\n<h4 id=\"362-处理死锁的基本方法\"><a class=\"markdownIt-Anchor\" href=\"#362-处理死锁的基本方法\">#</a> 3.6.2 处理死锁的基本方法</h4>\n<p>处理死锁的基本方法有<strong>预防死锁、避免死锁、检测并解除死锁和忽略死锁</strong>问题。</p>\n<ol>\n<li>\n<p>死锁的预防</p>\n<p>通过保证至少其中一个条件不成立来达到预防发生死锁的目的。</p>\n<ol>\n<li>\n<p><strong>摒弃请求和保持条件</strong><br>\n所有进程执行前要一次性地申请在整个运行过程中所需要的全部资源</p>\n</li>\n<li>\n<p><strong>摒弃不剥夺条件</strong></p>\n<p>一个已保持了某些资源的进程，当它再提出新的资源要求而不能立即得到满足时，必须释放它已经保持的所有资源。</p>\n</li>\n<li>\n<p><strong>摒弃环路等待条件</strong></p>\n<p>进程必须按规定的顺序申请资源</p>\n</li>\n</ol>\n</li>\n<li>\n<p>死锁的避免</p>\n<p>​\t<strong>避免死锁的方法是把系统的资源分配状态分为安全状态和不安全状态</strong>，只要资源分配使系统资源分配状态处于安全状态，死锁就不会发生。</p>\n<p>​\t在避免死锁的方法中，允许进程动态地电请资源。</p>\n</li>\n</ol>\n<h4 id=\"363-银行家算法\"><a class=\"markdownIt-Anchor\" href=\"#363-银行家算法\">#</a> 3.6.3 银行家算法</h4>\n<p>​\t1965 年 Dijkstra (迪杰斯特拉) 提出了种能够避免死锁的资源分配算法。</p>\n<p>​\t其基本思想是<strong>一个进程提出资源请求后，系统先进行资源的试分配。然后检测本次的试分配是否使系统处于安全状态，若安全则按试分配方案分配资源，否则不分配资源</strong>。</p>\n<pre><code>\t银行家算法的由来是银行家贷款给客户这一问题。银行家(操作系统)把一定数量的资金(资源)供多个用户(进程)周转使用。当顾客对资金的最大申请量不超过银行家现金时就可接纳一个新顾客。银行可以对顾客的借款推迟支付，但一定使顾客总能在有限的时间内得到借款;当顾客得到全部资金后，他一定能在有限的时间里归还(回收)所有资金(资源)。\n</code></pre>\n<p>银行家算法分为两个过程:<br>\n 一是进行资源试分配的过程；<br>\n 二是对试分配后系统的状态做安全性检测的过程。</p>\n<h4 id=\"364-死锁的检测和解除\"><a class=\"markdownIt-Anchor\" href=\"#364-死锁的检测和解除\">#</a> 3.6.4 死锁的检测和解除</h4>\n<p>何时调用检测算法？</p>\n<p>​\t➢ 死锁可能发生的频率</p>\n<p>​\t➢ 当死锁发生时受影响的进程数量</p>\n<p>死锁定理</p>\n<p>​\t➢ 死锁状态的充分条件是当且仅当资源分配状态是不可完全简化的。</p>\n<p>死锁的解除</p>\n<p>​\t➢ 终止处于死锁状态的进程</p>\n<p>​\t➢ 抢占死锁进程占有的资源</p>\n<p>单选题</p>\n<pre><code>某系统中有n (n为大于1的整数)个并发进程，每个进程需要同类资源m个(m为大于0的整数), 请问该系统不会发生死锁的最少资源数是( C )。\n\nA. n+m\nB.n*m\nC.n*(m-1)+1\nD.以上都对\n\n[解析]\n例如,若某系统中有4个并发进程,每个进程需要同类资源3个,则只要分配4*(3-1)+ 1共9个资源,该系统就不会发生死锁。每个进程都申请到两个资源后,还有1个资源,无论哪个进程获得这个资源都可以继续向前推进,当获得这个资源的进程执行完后,可以释放3个资源再分配给其他3个进程,因此不会发生死锁。\n</code></pre>\n<hr>\n<h2 id=\"第四章内存管理重点\"><a class=\"markdownIt-Anchor\" href=\"#第四章内存管理重点\">#</a> 第四章：内存管理（重点）</h2>\n<h3 id=\"考试重点\"><a class=\"markdownIt-Anchor\" href=\"#考试重点\">#</a> 考试重点</h3>\n<p>​\t➢ 存储器的层次结构 (选择、填空、简答)</p>\n<p>​\t➢ 程序的链接和装入 (选择、填空、简答)</p>\n<p>​\t➢ 连续分配存储管理、动态分区分配算法 (选择、填空、简答、综合)</p>\n<p>​\t➢ 分页、快表、两级页表 (选择、填空、简答、综合)</p>\n<p>​\t➢ 虚拟存储、缺页、页分配策略 (选择、填空、简答)</p>\n<p>​\t➢ 页置换算法 (选择、填空、简答、综合)</p>\n<p>​\t➢ 分段系统、段表、段页式存储管理 (选择、填空、简答)</p>\n<p><strong>本章近 3 年分值: 19~22 分</strong></p>\n<h3 id=\"41-存储器的层次结构\"><a class=\"markdownIt-Anchor\" href=\"#41-存储器的层次结构\">#</a> 4.1 存储器的层次结构</h3>\n<p>​\t内存是计算机存储系统的一部分，为了更好地理解后续章节内容，先了解存储器系统的层次结构。存储器系统是一个具有不同容量、成本和访问时间的存储设备的层次结构。</p>\n<p>在这个层次系统中，从高层到底层 (L0~L5)，较低层的存储设备速度更慢、容量更大、价格更便宜。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081201.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081201.png\" class=\"\"></p>\n<p>如果存储在高速缓存中，需要 1~ 10 个周期。</p>\n<p>如果存放在主存中，访问它们需要 50~ 100 个周期。</p>\n<p>如果存放在磁盘中，访问它们需要大约 2000 万个周期。</p>\n<p>​\t➢ 程序的执行遵循<strong>局部性</strong>原理。</p>\n<p>​\t程序在执行时呈现出局部性规律，即在一段较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域。</p>\n<ol>\n<li>程序执行时，除了少部分的转移和过程调用指令，<strong> 大多数情况下是顺序执行</strong></li>\n<li><strong>过程调用</strong>将会使程序的执行轨迹由一部分内存区域转移到另一部分内存区域</li>\n<li>程序中存在很多<strong>循环</strong>结构，它们虽然由少数指令构成但<strong>多次执行</strong></li>\n<li>程序中往往包括许多对数据结构的处理，如对数组操作，它们往往<strong>局限在很小的范围内</strong></li>\n</ol>\n<p>➢ 总的来说，<strong> 局部性</strong>原理<strong>表现为时间和空间的局部性</strong><br>\n➢ 时间局部性。如果程序中的某条指令一旦执行则不久后该指令可能再次执行。<br>\n➢ 空间局部性。一旦程序访问了某个单元，不久后其附近的存储单元也将被访问</p>\n<h3 id=\"42-程序的链接和装入\"><a class=\"markdownIt-Anchor\" href=\"#42-程序的链接和装入\">#</a> 4.2 程序的链接和装入</h3>\n<p>高级语言程序必须经过编译、链接才能成为可执行程序。操作系统需要为程序的执行分配内存空间。下面介绍链接程序的功能和程序被装入内存的几种方式。</p>\n<h4 id=\"421-程序的链接\"><a class=\"markdownIt-Anchor\" href=\"#421-程序的链接\">#</a> 4.2.1 程序的链接</h4>\n<p><strong>链接程序</strong>要解决的问题是<strong>将编译后的目标模块装配成一个可执行的程序</strong>。根据链接进行的时间和实现方式的不同，可以把链接分为静态链接和动态链接。<br>\n➢ <strong>静态链接</strong></p>\n<p>​\t在程序运行前，用链接程序将目标模块链接成一个完整的装入模块。运行速度快，占用大</p>\n<p>➢ <strong>动态链接</strong></p>\n<p>​\t将部分目标模块链接推迟到其中函数被调用执行。采用动态链接节省空间，方便开发，速度慢</p>\n<h4 id=\"422-程序的装入\"><a class=\"markdownIt-Anchor\" href=\"#422-程序的装入\">#</a> 4.2.2 程序的装入</h4>\n<p>​\t将源程序变为可执行程序须经过<strong>编译、链接和装入</strong> 3 个阶段。</p>\n<p>​\t可执行程序以<strong>二进制可执行文件</strong>的形式存储在磁盘上，为执行程序，操作系统需要把程序调入内存。程序装入内存的方式分为<strong>绝对装入、可重定位装入 (静态重定位) 和动态运行时装入</strong></p>\n<ol>\n<li>\n<p><strong>绝对装入方式</strong></p>\n<p>编译程序事先已知程序在内存中的驻留位置，编译时产生物理地址的目标代码。因此装入模块被装入内存后，无需对程序和数据的地址进行修改。</p>\n</li>\n<li>\n<p><strong>可重定位装入方式</strong> (静态重定位)</p>\n<p>​\t如果<strong>编译时不知道</strong>目标程序将驻留在内存的什么位置，则编译时就必须生成可重定位的代码，其中的地址都是<strong>逻辑地址</strong>（相对地址）, 在程序被装入内存时，再把这些逻辑地址映射为物理地址</p>\n<p>​\t在程序装入时对目标程序中的指令和数据地址的修改过程称为<strong>重定位</strong>。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081202.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081202.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>动态运行时装入</strong> (动态重定位)</p>\n<p>​\t一个进程在被换出之前所在的内存位置与后来被从外存重新调入时内存位置不同，这种装入方式称为<strong>动态运行时装入</strong>。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081203.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081203.png\" class=\"\"></p>\n</li>\n</ol>\n<h3 id=\"43-连续分配存储管理方式\"><a class=\"markdownIt-Anchor\" href=\"#43-连续分配存储管理方式\">#</a> 4.3 连续分配存储管理方式</h3>\n<p>连续分配是指操作系统分配内存时，为每个进程分配块物理地址连续的内存空间，连续分配方式有 3 种类型。</p>\n<p>➢ 单一连续区分配方式<br>\n➢ 固定分区分配方式<br>\n➢ 动态分区分配方式</p>\n<h4 id=\"431-单一连续区分配方式\"><a class=\"markdownIt-Anchor\" href=\"#431-单一连续区分配方式\">#</a> 4.3.1 单一连续区分配方式</h4>\n<p>​\t适用于单用户、单任务的操作系统，把内存分为<strong>系统区和用户区</strong>。系统区用于驻留操作系统，用户区用于分配给用户进程使用。</p>\n<p>​\t在单用户、单任务操作系统中较常用的方法是设置<strong>一个基址寄存器和一个界限寄存器</strong>。</p>\n<p>​\t<strong>基址寄存器</strong>中<strong>存放程序在物理内存中的最小地址</strong></p>\n<p>​\t<strong>界限寄存器</strong>中<strong>存放装入用户区程序的地址范围</strong></p>\n<p>​\t在 CPU 访问内存时，检查 CPU 要访问的内存单元的地址是否大于界限寄存器的值，如果大于，则是非法地址，表示用户进程访存越界，程序执行会被中断。</p>\n<h4 id=\"432-固定分区分配方式\"><a class=\"markdownIt-Anchor\" href=\"#432-固定分区分配方式\">#</a> 4.3.2 固定分区分配方式</h4>\n<p>​\t将内存用户区划分成若干个固定大小的区域，每个用户区中驻留一道程序。当有一个空闲分区时，可从外存的后备队列中选择一个大小适当的作业装 入该分区</p>\n<ul>\n<li>\n<p>划分分区的方法</p>\n<ul>\n<li>\n<p>分区大小相等</p>\n<p>把用户区划分成大小相等的若干个分区。</p>\n<p>缺点是内存利用率比较低。程序太小浪费空间，程序太大装不下</p>\n</li>\n<li>\n<p>分区大小不相等</p>\n<p>先划分多个大小不同、数量固定的若干个分区。分配的时候看哪个更接近就分配哪个。减少了浪费。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081204.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081204.png\" class=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"433-动态分区分配方式\"><a class=\"markdownIt-Anchor\" href=\"#433-动态分区分配方式\">#</a> 4.3.3 动态分区分配方式</h4>\n<p>​\t系统初始只有一个大空闲区，根据进程需要的空间大小分配内存。内存中<strong>分区的大小和数量是变化的</strong>。动态分区方式比固定分区方式<strong>显著地提高了内存利用率</strong>。系统维护一个记录当前空闲分区情况的数据结构，<strong>当进程请求内存时，系统从所有空闲区中找到大小合适的空闲分区进行分配</strong>。</p>\n<p>​\t常用的数据结构有<strong>空闲分区表</strong>和<strong>空闲分区链</strong></p>\n<p>➢ <strong>空闲分区表</strong></p>\n<p>​\t<img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081205.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081205.png\" class=\"\"></p>\n<p>​\t缺点：设置太多表项会浪费内存空间；设置太少无法记录所有空闲分区情况</p>\n<p>➢ <strong>空闲分区链</strong></p>\n<p>​\t可以<strong>动态地为每一个空闲分区建立一 个结点</strong>，每个结点包括分区大小、分区起始地址、指向前一个空闲分区结点的指针，以及指向后一个空闲分区结点的指针。空闲分区链中的<strong>每个结点占用的内存可以动态分配动态回收</strong>。</p>\n<p>➢ <strong>动态分区分配算法</strong></p>\n<p>​\t当进程需要内存空间时，操作系统通过执行动态分区分配算法从多个空闲分区中选定一个合适的分区分配给进程。</p>\n<p>​\t内存分配功能由内存分配程序完成。内存不再需要时，由系统调用内存回收程序回收原来被占的内存。</p>\n<ol>\n<li>\n<p>首次适应算法 FF (First Fit)</p>\n<p>​\t要求空闲分区链以<strong>地址递增</strong>的顺序链接。在内存分配时，从链首开始顺序查找，直至找到一个能满足进程大小要求的空闲分区为止。余下的空闲分区仍留在空闲链中。</p>\n<p>​\t该算法先分配低地址部分的内存空间，容易使低地址部分留下小分区，而高地址部分大空闲区较多。当进程请求大空间时，要找到合适的空闲分区，<strong> 时间开销大</strong>。</p>\n</li>\n<li>\n<p>循环首次适应算法 NF (Next Fit)</p>\n<p>​\t为进程分配内存空间时，<strong> 从上次找到的空闲分区的下一个空闲分区开始查找直到找到第个能满足要求的空闲分区</strong>，并从中划出一块与请求的大小相等的内存空间分配给进程。</p>\n<p>​\t为实现该算法，应设置一个起始查找指针，以指示下一次起始查找的空闲分区，并采用<strong>循环查找方式</strong>。循环首次适应算法的优点是:<strong> 空闲区分布均匀，查找开销较小。缺点是容易使系统缺乏大空闲区</strong>。</p>\n</li>\n<li>\n<p>最佳适应算法 BF (Best Fit)</p>\n<p>​\t该算法每次分配内存，把大小与进程所请求的<strong>内存大小最接近分配给进程</strong>。该算法要求将所有的空闲区按分区大小递增顺序形成一个空闲区链。</p>\n<p>​\t优点：避免大材小用，提高内存利用率，但容易留下难以利用的小空闲区</p>\n</li>\n</ol>\n<p>外部碎片 / 外碎片：低地址部分的空闲分区反复被划分，可能留下许多很小的空闲分区<br>\n内部碎片 / 内碎片：分配给进程的分区若大于进程请求的分区，分区内会有部分未利用的空间</p>\n<h3 id=\"44-基本本页存储管理方式\"><a class=\"markdownIt-Anchor\" href=\"#44-基本本页存储管理方式\">#</a> 4.4 基本本页存储管理方式</h3>\n<p>➢ <strong>离散内存管理方式</strong></p>\n<p>​\t\t把进程<strong>离散地</strong>存储在内存中物理地址不连续的区域中</p>\n<p>​\t根据离散内存管理分配内存空间的基本单位不同，分为 3 种管理方式:<strong> 分页存储管理、分段存储管理和段页式存储管理</strong>。</p>\n<h4 id=\"441-分页存储管理的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#441-分页存储管理的基本概念\">#</a> 4.4.1 分页存储管理的基本概念</h4>\n<ol>\n<li>\n<p>基础概念</p>\n<ol>\n<li>\n<p>页（Page）：将一个进程的<strong>逻辑地址空间</strong>分成多个大小相同的片</p>\n</li>\n<li>\n<p>页框 / 页帧：将<strong>物理内存空间</strong>分成与页大小相同的多个存储块</p>\n</li>\n<li>\n<p>分页存储：为进程分配内存时，<strong>以页框为单位</strong>将进程的若干个页<strong>装入多个不相邻的页框中</strong></p>\n</li>\n<li>\n<p>页内碎片：进程的最后一页装不满一个页框时，剩下的碎片</p>\n</li>\n<li>\n<p>页表：<strong>系统为进程建立的数据结构，实现从页号到页框号的映射</strong></p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081206.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081206.png\" class=\"\"></p>\n<h3 id=\"45-基于分页的虚拟存储系统\"><a class=\"markdownIt-Anchor\" href=\"#45-基于分页的虚拟存储系统\">#</a> 4.5 基于分页的虚拟存储系统</h3>\n<p>​\t<strong>虚拟存储器</strong>是指具有<strong>请求调入功能和置换功能</strong>，能从逻辑上对内存容量进行扩充的一种存储器系统。在虚拟存储器系统中，<strong> 进程无需全部装入</strong>，只要装入一部分即可运行。</p>\n<p>​\t虚拟存储技术实现的思想：先将进程一部分装入内存，其余部分需要时再请求系统装入，这就是请求调入。</p>\n<p>​\t置换：如果请求调入时，没有足够的内存，则由操作系统选择一部分内存中的内容换到外存。</p>\n<p>优点：</p>\n<ol>\n<li>提高内存利用率；</li>\n<li>提高多道程序度；</li>\n<li>把逻辑地址空间和物理地址空间分开，程序员不再关心物理内存的容量对编程的限制。</li>\n</ol>\n<p>虚拟存储系统具有以下几个主要特征：</p>\n<ol>\n<li>\n<p>离散性</p>\n<p>指进程可以分散地存储在物理内存中。分页、分段和段页式存储都属于离散的内存管理方式。离散性是实现虚拟存储管理的基础。</p>\n</li>\n<li>\n<p>多次性</p>\n<p>指不必把进程一 - 次性全部装入内存，可分多次装入。</p>\n</li>\n<li>\n<p>对换性</p>\n<p>指在内存中的进程可以换出，以腾出内存空间换入外存中的进程。</p>\n</li>\n<li>\n<p>虚拟性</p>\n<p>把逻辑地址空间和物理地址空间分开，程序员不再关心物理内存的容量对编程的限制。虚拟性是实现虚拟存储系统的最重要目标。</p>\n</li>\n</ol>\n<p>​\t<strong>请求分页系统</strong>是<strong>最基本、最常用的虚拟存储系统</strong>的实现方式。其基本原理是，把进程的逻辑地址空间分成大小相同的页，操作系统创建进程时只把进程的一部分页调入内存。进程运行过程中访问内存、若访问页不在内存中，则<strong>产生一个缺页异常信号</strong>，系统响应缺页异常，<strong> 请求调入缺页</strong>。</p>\n<p>​\t若调入缺页时内存已满，则需要先从内存中选择一个或若千个页换出到外存空间，以腾出内存空间容纳请求调入的缺页。</p>\n<h4 id=\"451-请求分页中的硬件支持\"><a class=\"markdownIt-Anchor\" href=\"#451-请求分页中的硬件支持\">#</a> 4.5.1 请求分页中的硬件支持</h4>\n<p>​\t为了实现请求分页，需要特殊的页表 (相对基本分页而言)、缺页异常机构和支持请求分页的地址变换机构。</p>\n<ol>\n<li>\n<p>页表</p>\n<p>是支持请求分页系统最重要的数据结构，其作用是记录描述页的各种数据，包括在实现逻辑地址到物理地址映射时需要的页号与页框号的对应关系。</p>\n<p>​\t除了页号和页框号之外，页表中增加了请求换入和页置换时需要的数据。</p>\n<p>​\t在支持请求分页的系统中一般包含以下基本字段:</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081601.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081601.png\" class=\"\"></p>\n<p>​\t页框号：存放页所在的页框号。</p>\n<p>​\t状态位 P : 标识页是否在内存中。可规定 0 不在，1 在。</p>\n<p>​\t访问字段 A : 用于记录页最近被访问的情况。系统总是希望根据 A 的值把最近、最久未访问的页换出到外存。</p>\n<p>​\t修改位 M : 标识页最近是否被修改过。</p>\n<p>​\t保护位：标识页的访问权限，如 1 表示可读可写 0 表示只读。</p>\n</li>\n<li>\n<p>缺页异常机构</p>\n<p>​\t主要作用是在访问内存过程中发现缺页时产生缺页异常信息，使 CPU 中断当前控制流的执行，转去执行操作系统的缺页异常处理程序，完成请求调页。</p>\n</li>\n<li>\n<p>地址变换</p>\n<p>请求分页系统中的地址变化过程如下:</p>\n<ol>\n<li>\n<p>由分页地址变换机构从逻辑地址中分离出页号和页内偏移地址</p>\n</li>\n<li>\n<p>以页号为索引查找快表，若快表中有该页的页表项，则读出页框号，计算物理地址</p>\n</li>\n<li>\n<p>若快表中无该页信息，转到内存页表中查找。若页表中的状态位 P 显示该页调入内存，则从相应的页表项读出页所在的页框号，并计算物理地址，然后把该页表项写入快表</p>\n</li>\n<li>\n<p>若该页尚末调入内存，则产生缺页异常请求操作系统从外存中把该页调入内存，然后修改页表，重新执行被中断的指令。</p>\n<p>​\t\t\t\t\t\t\t\t请求分页中的地址变换过程，如下图</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081602.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081602.png\" class=\"\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"452-页分配策略\"><a class=\"markdownIt-Anchor\" href=\"#452-页分配策略\">#</a> 4.5.2 页分配策略</h4>\n<ol>\n<li>\n<p>最少页框数</p>\n<p>指能保证进程正常运行所需要的最少的页框数。为了保证进程顺利执行，操作系统为进程分配的初始页数应该大于或等于最少页框数。</p>\n</li>\n</ol>\n<h4 id=\"453-页调入策略\"><a class=\"markdownIt-Anchor\" href=\"#453-页调入策略\">#</a> 4.5.3 页调入策略</h4>\n<ol>\n<li>\n<p>何时调入页<br>\n大多数系统都采用<strong>预先凋入页</strong>的策略，将预计不久之后会被访问的页预先调入内存，而不是缺哪一页时再调入该页。</p>\n<p>​\t在实际系统中，通常是在<strong>调入缺页时，把与所缺页相邻的若千页也调入内存</strong>。</p>\n</li>\n<li>\n<p>从何处调入页</p>\n<p>当系统拥有足够的对换空间时，若发生缺页请求则从对换区调入页。从对换区调入页比从文件区调入页的速度快。对换区中的页是进程运行前从文件区复制到对换区的。</p>\n</li>\n</ol>\n<h4 id=\"454-页置换算法\"><a class=\"markdownIt-Anchor\" href=\"#454-页置换算法\">#</a> 4.5.4 页置换算法</h4>\n<p>​\t页置换算法是从内存中选择换出页的算法。</p>\n<ol>\n<li>\n<p>最佳置换算法和先进先出置换算法</p>\n<p>( 1 )<strong> 最佳置换算法</strong></p>\n<p>​\t选择以后永远不会被访问的页或者在未来最长时间内不再被访问的页作为换出页。该算法主要用于<strong>理论研究</strong>。</p>\n<p>( 2 )<strong> 先进先出页置换算法</strong></p>\n<p>​\t为每个页记录该项调入内存的时间，当选择换出页时，选择进入内存时间最早的页。</p>\n<p>​\t实现简单，但<strong>效率低</strong>，会导致较高的缺页率，有的页刚被换出，可能又要立即被访问。</p>\n</li>\n<li>\n<p>最近最久未使用 LRU 置换算法</p>\n<p>​\t<strong>选择最近最久末使用的页换出</strong>。同样的页引用序列，LRU 算法<strong>置换次数</strong>较先进先出算法少，性能较好。</p>\n</li>\n<li>\n<p>其他置换算法</p>\n<p>​\t附加引用位算法、简单 Clock 置换算法、 改进型 Clock 算法、最少使用置换算法。</p>\n</li>\n</ol>\n<h4 id=\"综合题\"><a class=\"markdownIt-Anchor\" href=\"#综合题\">#</a> 综合题</h4>\n<p>[答案] 先进先出页置换算法</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081603.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081603.png\" class=\"\"></p>\n<h4 id=\"455-请求分页系统的性能分析\"><a class=\"markdownIt-Anchor\" href=\"#455-请求分页系统的性能分析\">#</a> 4.5.5 请求分页系统的性能分析</h4>\n<p>请求调入和置换技术都是以时间换空间的技术。</p>\n<ol>\n<li>\n<p>缺页率对有效访问时间的影响</p>\n<p>​\t进程执行中访存发生缺页时，需要请求从外存调入缺页。如果内存中没有空闲页框，还需要进行页置换，调入缺页后，指令需要重新执行。因此，一旦发生缺页，进程会存在因为访存而带来的时间延迟。</p>\n<p>​\t有效访问时间正比于缺页率。</p>\n</li>\n<li>\n<p>工作集</p>\n<p>​\t引入<strong>工作集机制</strong>是为了<strong>能有效降低缺页率</strong>，从而提高访存的时间效率。程序运行时<strong>对页的访问是不均匀的</strong>，往往在<strong>某段时间内集中于访问某些页</strong>。若能将<strong>某段时间间隔内要访问的页提前调入内存</strong>，将会大大降低缺页率，从而减少置换次数，提高 CPU 的利用率。<strong>工作集</strong>就是<strong>在某段时间间隔内，进程实际要访问的页的集合</strong>。</p>\n</li>\n<li>\n<p>抖动产生的原因和预防方法</p>\n<p>​\t多道程序度太高，使运行进程的大部分时间都用于进行页的换入、换出，而几乎不能完成任何有效工作的状态称为抖动。<br>\n​\t引起<strong>抖动的原因</strong>是<strong>系统中的进程数量太多，每个进程能分配到的页框态少</strong>，以至于进程运行过程中频繁请求调页。</p>\n<p>抖动的预防:<br>\n( 1 )<strong> 采取局部置换策略</strong>。仅在进程自己的内存空间范围内置换页。<br>\n(2) 在 CPU 调度程序中<strong>引入工作集</strong>算法。<br>\n( 3 )<strong> 挂起若干进程</strong>。腾出进程占用的空间。</p>\n</li>\n</ol>\n<h3 id=\"46-分段存储管理\"><a class=\"markdownIt-Anchor\" href=\"#46-分段存储管理\">#</a> 4.6 分段存储管理</h3>\n<h4 id=\"461-分段机制的引入\"><a class=\"markdownIt-Anchor\" href=\"#461-分段机制的引入\">#</a> 4.6.1 分段机制的引入</h4>\n<p>​\t在分页存储管理方式中，逻辑地址是维的，一个进程的逻辑地址形成个地址空间。 这种逻辑空间的使用方式对于程序员来说很不方便，分段能为进程提供多个地址空间，把逻辑上关联的部分放在一个地址空间中逻辑上没有关联也没有共同特征的部分放在不同的地址空间中。这样不仅方便用户编程，而且能很好地解决部分存储空间动态增长、信息共享和信息保护问题。</p>\n<p>​\t把分别存放逻辑上相关的信息、相互独立的逻辑地址空间称为一个段，每个段由一个从 0 到最大线性地址的逻辑地址空间构成。</p>\n<p>​\t各个段的长度可以是 0 到最大值之间的任何一个值不同段的长度可以不相同，段的长度在进程运行期间可以改变。</p>\n<p>​\t在使用分段存储管理的系统中，程序员使用二维的逻辑地址，一个数用来表示段，另一个数用来表示段内偏移。段是一个逻辑实体，程序员可以通过使用二维地址来访问不同的逻辑段。</p>\n<p>​\t一个段可能包括一个过程，或者一个数组、一个堆栈、一些数值变量，但是一般不会同时包含多种不同的内容。</p>\n<h4 id=\"462-分段系统的基本原理\"><a class=\"markdownIt-Anchor\" href=\"#462-分段系统的基本原理\">#</a> 4.6.2 分段系统的基本原理</h4>\n<ol>\n<li>\n<p>分段</p>\n<p>​\t在分段的存储管理方式中，进程的地址空间被划分成若千个段。每个段定义了一组逻辑信息，每个段的大小由相应的逻辑信息组的长度确定，段的大小不一样 **, 每个段的逻辑地址从 0 开始，采用一段连续的地址空间 **。系统为每个段分配一个连续的物理内存区域，各个不同的段<strong>可以离散地放入物理内存不同的区域</strong>。</p>\n</li>\n<li>\n<p>分段的逻辑地址结构<br>\n分段机制的逻辑地址是二维的，由段号和段内地址组成。</p>\n<p>32 位系统中分段的地址形式为:</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081604.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081604.png\" class=\"\"></p>\n</li>\n<li>\n<p>段表</p>\n<p>​\t段表是<strong>由操作系统维护</strong>的用于支持分段存储管理地址映射的<strong>数据结构</strong>。通常，<strong> 每个进程有一个段表</strong>，段表由段表项构成。每个段表项包含<strong>段号、段基址</strong> (段的起始地址) 和<strong>段长</strong> (段大小) 3 个部分。一个进程可能包含若干个段，每一个段在段表中有一个段表项与之对应。根据段表可以知道一个段在物理内存中的位置。</p>\n</li>\n<li>\n<p>分段系统的地址变换</p>\n<p>​\t逻辑地址由段号 s 和段内偏移 d 构成。<br>\n​\t已知逻辑单元的地址为 s:d， 求物理地址的步骤为:<br>\n​\t(1) 以 s 为索引，从段表中找到段号为 s 的段表项。<br>\n​\t(2) 从找到的段表项中读出 s 段的基地址和段大小。<br>\n​\t(3) 如果<strong> d &lt; = 段大小</strong>，则将<strong>段基址与段内偏移 d 相加，得到与逻辑单元 s:d 对应的物理单元地址</strong>。</p>\n</li>\n<li>\n<p>分页和分段的主要区别</p>\n<ol>\n<li>页是按物理单位划分的，分页的引入是为了提高内存的利用率和支持虚拟存储。而段是按逻辑单位划分的，一个段含有一 - 组意义相对完整的信息。引入分段的目的是为了方便程序员编程。</li>\n<li>页的大小是固定的，而段的大小不固定，取决于用户编写的程序和编译器。</li>\n<li>分页的地址空间是一维的，程序员给出的地址只是一个助记符，已知的逻辑地址是一个整数。分段的地址空间是二维的，程序员在标识一个逻辑地址时需要给出两个数：一个是段号，一个是段内偏移。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"463-段页式存储管理\"><a class=\"markdownIt-Anchor\" href=\"#463-段页式存储管理\">#</a> 4.6.3 段页式存储管理</h4>\n<ol>\n<li>\n<p>段页式存储管理的基本原理</p>\n<p>​\t在段页式存储管理系统中，将用户进程的逻辑空间先划分成若干个段，每个段再划分成若千个页。进程以页为单位在物理内存中离散存放，每个段中被离散存放的页具有逻辑相关性。</p>\n</li>\n<li>\n<p>地址变换过程</p>\n<p>​\t在段页式存储管理系统中，逻辑地址与分段系统的逻辑地址相同，由段号 s 和段内地址 d 构成，地址变换过程如下<br>\n (1) 以段号 s 作索引，找到段 s 的段表项，得到该段页表的起始地址。<br>\n(2) 通过分页机制从<strong>段内偏移 d 中分离出页号 P 和页内偏移 W</strong>。<br>\n(3) 以段内页号<strong> P 作索引</strong>，从段 s 的页表中<strong>搜索</strong>页号<strong> P</strong> 对应的<strong>页表项</strong>。<br>\n(4) 从页表项中<strong>得到</strong>页所在的<strong>页框号</strong>。<br>\n(5) 由<strong>页框号</strong>与<strong>页内偏移 W</strong> 得到某逻辑地址对应的物理地址。</p>\n<p>物理地址 = 页框号 * 页框大小 + 页内偏移 W<br>\n 采用段页式存储管理的好处是，程序员可以使用分段的逻辑地址，而实际上进程却以页为单位存放于物理内存中。段页式系统的地址变换如下图。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081607.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081607.png\" class=\"\"></p>\n</li>\n</ol>\n<h4 id=\"464-综合题\"><a class=\"markdownIt-Anchor\" href=\"#464-综合题\">#</a> 4.6.4 综合题</h4>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081605.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081605.png\" class=\"\"><br>\n<img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081606.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081606.png\" class=\"\"></p>\n<h3 id=\"47-linux的伙伴系统\"><a class=\"markdownIt-Anchor\" href=\"#47-linux的伙伴系统\">#</a> 4.7 Linux 的伙伴系统</h3>\n<p>略</p>\n<hr>\n<h2 id=\"第五章文件管理\"><a class=\"markdownIt-Anchor\" href=\"#第五章文件管理\">#</a> 第五章：文件管理</h2>\n<h3 id=\"考试重点-2\"><a class=\"markdownIt-Anchor\" href=\"#考试重点-2\">#</a> 考试重点</h3>\n<p>文件结构、类型、存取、属性 (选择、填空、简答）<br>\n目录结构、路径名 (选择、填空、简答)<br>\n 实现文件、实现目录 (选择、填空、简答、综合)</p>\n<p>本章近 3 年分值: 14~19 分</p>\n<p><strong>操作系统中处理文件的部分称为文件系统</strong>，文件系统包括了文件及管理文件的软件集合。</p>\n<h3 id=\"51-文件\"><a class=\"markdownIt-Anchor\" href=\"#51-文件\">#</a> 5.1 文件</h3>\n<h4 id=\"511-文件命名\"><a class=\"markdownIt-Anchor\" href=\"#511-文件命名\">#</a> 5.1.1 文件命名</h4>\n<p>​\t<strong>文件名</strong>向用户提供了简单、直观的文件<strong>访问方式</strong>。<strong>按名存取</strong>。</p>\n<p>​\t所有操作系统都支持<strong> 1 ~8 个字母组成的字符串</strong>作为文件名。许多操作系统支持<strong>长达 255 个字符</strong>的文件名。</p>\n<p>​\tUNIX 文件系统区分大小写，MS-DOS 系统不区分。</p>\n<h4 id=\"512-文件结构\"><a class=\"markdownIt-Anchor\" href=\"#512-文件结构\">#</a> 5.1.2 文件结构</h4>\n<ol>\n<li>\n<p>无结构字节序列</p>\n<p>也称为流式文件，如程序。</p>\n</li>\n<li>\n<p>固定长度记录序列</p>\n<p>构成文件的基本单位是具有固定长度的记录。</p>\n</li>\n<li>\n<p>树形结构</p>\n<p>文件由一棵记录树构成，记录长度不固定，在记录的固定位置包含一个关键字域，记录树按该域排序。</p>\n</li>\n</ol>\n<h4 id=\"513-文件类型\"><a class=\"markdownIt-Anchor\" href=\"#513-文件类型\">#</a> 5.1.3 文件类型</h4>\n<p>​\t一般分为 ASCII 文件和 2 进制文件。ASCI 文件。由多行正文组成，各行的长度不必相同。可以显示和打印，也可以用通常的文本编辑器进行编辑。</p>\n<p>​\t二进制文件。具有一定的内部结构，如可执行的.exe 文件。用通常的文本编辑器不能直接显示或打印。</p>\n<h4 id=\"514-文件存取\"><a class=\"markdownIt-Anchor\" href=\"#514-文件存取\">#</a> 5.1.4 文件存取</h4>\n<p>​\t文件存取方式有两种：顺序存取和随机存取。</p>\n<p>​\t顺序存取：进程从文件开始处读取文件中的所有字节或记录，不能掉过某些内容（磁带）</p>\n<p>​\t随机存取：又称直接存取，可以任意顺序读取文件中的字节或记录（磁盘）</p>\n<h4 id=\"515-文件属性\"><a class=\"markdownIt-Anchor\" href=\"#515-文件属性\">#</a> 5.1.5 文件属性</h4>\n<p>​\t文件的创建日期、文件大小和修改时间等，这些附加信息称为文件属性。一些常用的文件属性有：口令、创建者、所有者，只读标志、隐藏标志、大小、类型等。</p>\n<h4 id=\"516-文件操作\"><a class=\"markdownIt-Anchor\" href=\"#516-文件操作\">#</a> 5.1.6 文件操作</h4>\n<p>CREATE：创建文件，并设置文件的一些属性。</p>\n<p>DELETE：删除文件并释放磁盘空间。</p>\n<p>OPEN：使用文件之前，必须先打开文件。</p>\n<p>CLOSE：存取结束后，关闭文件以释放内存空间。</p>\n<p>READ：从文件中读取数据。</p>\n<p>WRITE：往文件中写数据。</p>\n<p>APPEND：在文件末尾添加数据。</p>\n<p>SEEK：对于随机存取文件，要指定从何处开始取数据。</p>\n<p>GETAT TRIBUTES：用于获取文件的属性。</p>\n<p>SETAT TRIBUTES：用于修改文件的属性。</p>\n<p>RENAME：修改已有文件的文件名。</p>\n<h3 id=\"52-目录\"><a class=\"markdownIt-Anchor\" href=\"#52-目录\">#</a> 5.2 目录</h3>\n<p>​\t文件系统通常提供目录或文件夹用于记录文件很多系统中目录本身也是文件，目录是文件系统中实现按名访问文件的重要数据结构。</p>\n<h4 id=\"521-层次目录系统\"><a class=\"markdownIt-Anchor\" href=\"#521-层次目录系统\">#</a> 5.2.1 层次目录系统</h4>\n<ol>\n<li>\n<p>目录文件的结构</p>\n</li>\n<li>\n<p>目录结构</p>\n<ol>\n<li>\n<p>单层目录</p>\n<p>​\t也被称为根目录，在整个系统中设置一张线性目录表，表中包括了所有文件的描述信息。</p>\n</li>\n<li>\n<p>两级目录</p>\n<p>​\t第一级为<strong>主目录</strong>。第二级为<strong>用户目录</strong>。两级目录解决了文件重名和共享问题。</p>\n</li>\n<li>\n<p>树形目录</p>\n<p>​\t也称多级目录，最高层为根目录，最底层为文件。用户可以创建任意数量的<strong>子目录</strong>。优点：便于文件的分类，层次结构清晰，便于管理和保护，解决了重名问题，查找速度快。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"522-路径名\"><a class=\"markdownIt-Anchor\" href=\"#522-路径名\">#</a> 5.2.2 路径名</h4>\n<p>​\t常用的方法有两种：绝对路径名和相对路径名。</p>\n<p>​\t绝对路径名由从根目录到文件的路径组成。绝对路径名总是从根目录开始，并且是唯一的。在 Windows 系统中，路径各部分之间用 &quot;&quot; 分隔，如：C:\\program\\practice\\test</p>\n<p>​\t相对路径名。当一个文件系统的目录包含很多级时，可以允许用户指定一个目录作为当前的工作目录。所有的不从根目录开始的路径名都是相对于工作目录的。</p>\n<h3 id=\"53-文件系统的实现\"><a class=\"markdownIt-Anchor\" href=\"#53-文件系统的实现\">#</a> 5.3 文件系统的实现</h3>\n<h4 id=\"531-实现文件\"><a class=\"markdownIt-Anchor\" href=\"#531-实现文件\">#</a> 5.3.1 实现文件</h4>\n<p>​\t将分配给文件的<strong>连续扇区构成的磁盘块称为簇</strong>。</p>\n<ol>\n<li>\n<p>连续分配</p>\n<p>​\t把每个文件作为一连串连续数据块存储在磁盘上。每个文件都从新的簇开始存放。</p>\n<p>​\t优点：实现简单，读操作性能好。</p>\n<p>​\t缺点：随着时间的推移，碎片太多，难以利用</p>\n</li>\n<li>\n<p>使用磁盘链接表的分配</p>\n<p>​\t该方法为每个文件构造簇的链接表，每个簇前几个字节用于存放下一个簇的簇号。</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081701.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081701.png\" class=\"\"></p>\n<p>​</p>\n<p>​\t优点：充分利用每个簇，不会浪费存储空间，管理简单</p>\n<p>​\t缺点：随机存取相当缓慢，要获取文件的第 n 块都要从头开始读取前面的 n- 1 块。</p>\n</li>\n<li>\n<p>使用内存的链接表分配</p>\n<p>​\t该方法是<strong>将</strong>文件所在的磁盘的<strong>簇号存放在内存的表中</strong>。</p>\n<p>​\t缺点：必须把整个表都存放在内存中，不适合大容量磁盘。</p>\n</li>\n<li>\n<p>i - 结点</p>\n<p>​\t该方法为每个文件赋予一个被称为 i 结点的数据结构，其中列出了文件属性和文件块的磁盘地址。给定一个文件的结点，就有可能找到文件的所有块。</p>\n<p>​\t当访问文件时，系统先根据文件名搜索文件所在的目录文件，从该文件对应的目录项中找到文件的结点号，根据 i 结点号从磁盘中将结点信息读入内存，文件在磁盘中的地址信息都存放在 i 结点中。</p>\n</li>\n</ol>\n<h4 id=\"532-实现目录\"><a class=\"markdownIt-Anchor\" href=\"#532-实现目录\">#</a> 5.3.2 实现目录</h4>\n<p>​\t打开文件时，操作系统利用用户给出的路径名找到相应的目录项，目录项中提供了查找文件簇所需要的信息。（略）</p>\n<h4 id=\"533-磁盘空间管理\"><a class=\"markdownIt-Anchor\" href=\"#533-磁盘空间管理\">#</a> 5.3.3 磁盘空间管理</h4>\n<p>​\t磁盘空间管理是文件系统的重要功能，包括记录空闲磁盘信息、设计文件的存储方式，以及规定文件系统的簇大小等内容。</p>\n<ol>\n<li>\n<p>簇大小</p>\n<p>​\t文件系统为文件分配磁盘空间是以簇为单位。簇的大小是<strong> 2 的整数次幂</strong>个连续的扇区。</p>\n</li>\n<li>\n<p>记录空闲块</p>\n<ol>\n<li>\n<p>空闲簇链接表</p>\n<p>​\t用一些空闲簇存放空闲簇的簇号。一个簇存放尽可能多的空闲簇的簇号，并专留出最后几个字节存放指向下一个存放空闲簇的指针。</p>\n</li>\n<li>\n<p>位图</p>\n<p>​\t用 n 位位图对应磁盘的 n 个簇，在位图中，空闲簇用 1 表示，已分配簇用 0 表示。每个簇只用一个二级制位标识，所需空间少。</p>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"第六章设备管理\"><a class=\"markdownIt-Anchor\" href=\"#第六章设备管理\">#</a> 第六章：设备管理</h2>\n<h3 id=\"考试重点-3\"><a class=\"markdownIt-Anchor\" href=\"#考试重点-3\">#</a> 考试重点</h3>\n<p>I/O 系统的结构、I/O 设备分类、设备控制器 (选择、填空、简答)<br>\n 轮询、中断、DMA 控制方式 (选择、填空、简答)<br>\n 缓冲管理 (选择、填空、简答)<br>\n 设备分配、独立性、SPOOLing 技术 (选择、 填空、简答)<br>\n I/O 软件管理 (选择、填空、简答)<br>\n 磁盘结构 (选择、填空、简答)<br>\n 磁盘调度 (选择、填空、简答、综合)</p>\n<p>本章近 3 年分值: 12~20 分</p>\n<h3 id=\"61-io系统的组成\"><a class=\"markdownIt-Anchor\" href=\"#61-io系统的组成\">#</a> 6.1 I/O 系统的组成</h3>\n<h4 id=\"611-io系统的组成的概述\"><a class=\"markdownIt-Anchor\" href=\"#611-io系统的组成的概述\">#</a> 6.1.1 I/O 系统的组成的概述</h4>\n<p>I/O 设备包括：I/O 设备、设备控制器、通道。</p>\n<h4 id=\"612-io系统的结构\"><a class=\"markdownIt-Anchor\" href=\"#612-io系统的结构\">#</a> 6.1.2 I/O 系统的结构</h4>\n<ol>\n<li>\n<p>微机 I/O 系统</p>\n<p>CPU 不能直接跟 I/O 设备交换，需要设备控制器</p>\n</li>\n<li>\n<p>主机 I/O 系统</p>\n<p>I/O 系统采用四级结构：主机、通道、控制器、设备。一个通道可控制多个控制器，一个控制器可控制多个设备</p>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081801.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081801.png\" class=\"\"></p>\n</li>\n</ol>\n<h4 id=\"613-io设备的分类\"><a class=\"markdownIt-Anchor\" href=\"#613-io设备的分类\">#</a> 6.1.3 I/O 设备的分类</h4>\n<ol>\n<li>\n<p>按传输速率</p>\n<ol>\n<li>低速设备：键盘、鼠标</li>\n<li>中速设备：打印机</li>\n<li>高速设备：磁带机、磁盘机、光盘机</li>\n</ol>\n</li>\n<li>\n<p>按信息交换的单位</p>\n<ol>\n<li>\n<p>块设备</p>\n<p>数据存储以数据块为单位，块大小固定，一次只传输一块，通过块号访问数据</p>\n</li>\n<li>\n<p>字符设备</p>\n<p>传输字节流；打印机、鼠标都是</p>\n</li>\n</ol>\n</li>\n<li>\n<p>按设备的共享属性</p>\n<ol>\n<li>\n<p>独占设备</p>\n<p>必须作为临界资源以互斥方式访问，在当前进程未使用完，其他进程不可使用</p>\n</li>\n<li>\n<p>共享设备</p>\n<p>允许多个进程同时访问，但同一时刻只能单个进程对磁盘读写</p>\n</li>\n<li>\n<p>虚拟设备</p>\n<p>将物理设备虚拟成若干个逻辑设备</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"614-设备控制器\"><a class=\"markdownIt-Anchor\" href=\"#614-设备控制器\">#</a> 6.1.4 设备控制器</h4>\n<p>CPU 与 I/O 设备的<strong>接口</strong>。</p>\n<ol>\n<li>功能\n<ul>\n<li>接收和识别</li>\n<li>数据交换\n<ol>\n<li>将驱动器的比特流汇聚在控制器的缓冲区，形成字节块</li>\n<li>在 CPU 和控制器双向传输</li>\n<li>将控制器的命令传给设备控制器</li>\n</ol>\n</li>\n<li>设备状态的了解和报告</li>\n<li>地址识别</li>\n<li>数据缓存</li>\n<li>差错控制</li>\n</ul>\n</li>\n<li>组成\n<ol>\n<li>与处理机的接口：数据线、控制线、地址线</li>\n<li>与设备的接口：存在三类信号，分别是数据、状态、控制信号</li>\n<li>I/O 逻辑：指令译码器、地址译码器</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081802.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081802.png\" class=\"\"></p>\n<h4 id=\"614-io通道\"><a class=\"markdownIt-Anchor\" href=\"#614-io通道\">#</a> 6.1.4 I/O 通道</h4>\n<p>​\t用于大型主机系统控制 I/O 设别，替代主机的设备控制器，提高 CPU 利用率和系统吞吐量</p>\n<h3 id=\"62-io控制方式\"><a class=\"markdownIt-Anchor\" href=\"#62-io控制方式\">#</a> 6.2 I/O 控制方式</h3>\n<h4 id=\"621-轮询\"><a class=\"markdownIt-Anchor\" href=\"#621-轮询\">#</a> 6.2.1 轮询</h4>\n<p>​\t在对设别发出 I/O 指令前，反复确认设备控制器状态寄存器的忙 / 闲标志。若空闲则发指令</p>\n<p>​\t缺点：极大浪费 CPU，影响系统的吞吐量</p>\n<h4 id=\"622-中断\"><a class=\"markdownIt-Anchor\" href=\"#622-中断\">#</a> 6.2.2 中断</h4>\n<p>​\t当 I/O 设备忙，进程阻塞；工作完毕之后发出中断请求信号，CPU 响应</p>\n<p>​\t优点：使 CPU 与 I/O 设备在某些时间段上并行时间，提高 CPU 利用率和系统吞吐量</p>\n<h4 id=\"623-dma控制方式\"><a class=\"markdownIt-Anchor\" href=\"#623-dma控制方式\">#</a> 6.2.3 DMA 控制方式</h4>\n<p>​\t为提高 I/O 的速度和 CPU 与 I/O 的并行速度。</p>\n<p>​\t逻辑组成包括三部分：主机与 DMA 接口、DMA 与设备的接口、I/O 控制逻辑。</p>\n<p>​\t为了主机与设备管理器成块数据传送，设计了四类寄存器：</p>\n<ol>\n<li>命令 / 状态寄存器 CR：接受 CPU 的 I/O 命令和有关控制信息、设别状态</li>\n<li>内存地址寄存器 MAR：存放内存地址</li>\n<li>数据计数器 DC：指示 DMA，本次向 CPU 发中断信号要读或写数据的次数</li>\n<li>数据寄存器 DR：暂存 DMA 传输中输入输出的数据</li>\n</ol>\n<p><img data-src=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081803.png\" alt=\"\"><img data-src=\"/zxy/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/21081803.png\" class=\"\"></p>\n<h3 id=\"63-缓冲管理\"><a class=\"markdownIt-Anchor\" href=\"#63-缓冲管理\">#</a> 6.3 缓冲管理</h3>\n<h3 id=\"64-设备分配\"><a class=\"markdownIt-Anchor\" href=\"#64-设备分配\">#</a> 6.4 设备分配</h3>\n<h3 id=\"65-io软件原理\"><a class=\"markdownIt-Anchor\" href=\"#65-io软件原理\">#</a> 6.5 I/O 软件原理</h3>\n<h3 id=\"66-磁盘管理\"><a class=\"markdownIt-Anchor\" href=\"#66-磁盘管理\">#</a> 6.6 磁盘管理</h3>\n",
            "tags": [
                "操作系统概论"
            ]
        },
        {
            "id": "https://xinyao_idiot.gitee.io/zxy/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/",
            "url": "https://xinyao_idiot.gitee.io/zxy/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/",
            "title": "数据库系统原理",
            "date_published": "2021-08-09T06:14:00.000Z",
            "content_html": "<h1 id=\"数据库系统原理\"><a class=\"markdownIt-Anchor\" href=\"#数据库系统原理\">#</a> 数据库系统原理</h1>\n<h2 id=\"第一章-数据库系统概念\"><a class=\"markdownIt-Anchor\" href=\"#第一章-数据库系统概念\">#</a> 第一章、数据库系统概念</h2>\n<h3 id=\"第一节数据库基本概念\"><a class=\"markdownIt-Anchor\" href=\"#第一节数据库基本概念\">#</a> 第一节：数据库基本概念</h3>\n<h4 id=\"一数据\"><a class=\"markdownIt-Anchor\" href=\"#一数据\">#</a> 一。数据：</h4>\n<p>​\t\t数据（Data）是描述事物的符号记录，是只用无里符号记录下来的、可以鉴别的信息。</p>\n<h4 id=\"二数据库\"><a class=\"markdownIt-Anchor\" href=\"#二数据库\">#</a> 二。数据库</h4>\n<p>​\t\t数据库（Database，DB）通俗地被称为存储数据的仓库，知识这个仓库是存储在计算机存储设备上的，并且其所存储的数据是按一定的格式进行存储的。</p>\n<p><strong>特点：具有较小的冗余度、较高的数据独立性，系统易于扩展，并可以被多个用户共享。</strong></p>\n<p>** 三个基本特点：** 具有永久存储、有组织和可共享三个基本特点</p>\n<h4 id=\"三数据库管理系统\"><a class=\"markdownIt-Anchor\" href=\"#三数据库管理系统\">#</a> 三。数据库管理系统</h4>\n<p>数据库管理系统（Database Managenment System，DBMS）是专门用于建立和管理数据库的一套软件，介于应用程序和操作系统之间。负责<strong>科学有效的组织和存储数据</strong>，并帮助数据库的使用者从大量的数据中快速地获取所需数据，以及提供必要的<strong>安全性</strong>和<strong>完整性</strong>等统一控制机制，实现对数据有效的管理与维护。</p>\n<h4 id=\"四数据库的主要功能\"><a class=\"markdownIt-Anchor\" href=\"#四数据库的主要功能\">#</a> 四。数据库的主要功能</h4>\n<ol>\n<li>数据定义功能</li>\n<li>数据操纵功能</li>\n<li>数据库的运行管理功能</li>\n<li>数据库的建立和维护功能</li>\n<li>数据组织、存储和管理功能</li>\n<li>其他功能（主要包括与其他软件<strong>网络通信</strong>、不同数据库系统之间的<strong>数据传输和相互访问</strong>）</li>\n</ol>\n<h4 id=\"五数据库系统\"><a class=\"markdownIt-Anchor\" href=\"#五数据库系统\">#</a> 五。数据库系统</h4>\n<p>数据库系统（DBS）是指在计算机中引入数据库技术之后的系统</p>\n<p>数据库管理员（DBA）是专门负责对数据库进行维护的专业人员</p>\n<hr>\n<h3 id=\"第二节数据管理技的发展\"><a class=\"markdownIt-Anchor\" href=\"#第二节数据管理技的发展\">#</a> 第二节：数据管理技的发展</h3>\n<h4 id=\"数据管理\"><a class=\"markdownIt-Anchor\" href=\"#数据管理\">#</a> 数据管理：</h4>\n<ol>\n<li><strong>针对组织业务的管理</strong>，负责指定并执行郑个组织中关于数据的定义、组织、保护与有效使用的策略、过程和计划</li>\n<li><strong>依靠技术</strong>，负责实现数据作为一个资源的集中控制管理</li>\n</ol>\n<p>** 数据组织：** 用便于处理的某种方式收集数据，并将记录在纸介文件上的数据转换成计算机可处理的形式；然后将手机的数据进行适当的构造</p>\n<ul>\n<li>逻辑组织：用户或应用程序所使用的数据结构形式</li>\n<li>物理组织：数据在无里存储设备上的结构形式</li>\n<li>检索：为了向用户提供信息，存储的数据要能够方便地选择提取</li>\n</ul>\n<p>随着计算机技术的发展及应用，数据挂你了技术共经历了<strong>人工管理</strong>、<strong>文件系统</strong>和<strong>数据库系统</strong>三个阶段</p>\n<h4 id=\"一人工管理阶段\"><a class=\"markdownIt-Anchor\" href=\"#一人工管理阶段\">#</a> 一。人工管理阶段：</h4>\n<p><strong>20 世纪 50 年代中期以前</strong>，所设计的数据处理基本依靠<strong>手工方式</strong>进行，具有以下特点：</p>\n<ol>\n<li>数据不保存（<strong>存储容量有限，价格昂贵</strong>）</li>\n<li>应用程序管理数据（<strong>即没有专门的数据管理软件</strong>）</li>\n<li>数据与面向应用（<strong>即一组数据面对一个应用程序</strong>）</li>\n</ol>\n<h4 id=\"二文件系统阶段\"><a class=\"markdownIt-Anchor\" href=\"#二文件系统阶段\">#</a> 二。文件系统阶段：</h4>\n<p><strong>20 世纪 20 年代后期到 60 年代中期</strong>，计算机硬件和软件发展到了一定阶段，配备了专门的数据管理软件，即<strong>文件系统</strong>。文件系统将数据的<strong>逻辑结构</strong>和<strong>物理结构</strong>分离，当物理结构发生改变的时候，不会导致应用程序的修改（<strong>数据的物理独立结构</strong>）。</p>\n<p>特点如下：</p>\n<ul>\n<li>数据的管理者：文件系统，数据可长期保存（<strong>有硬盘和专门的文件系统</strong>）</li>\n<li>数据面向的对象：某一应用程序</li>\n<li>数据的共享程度：<strong>共享性差、冗余度大</strong></li>\n<li>数据的结构化：记录有结构，整体无结构 (<strong>不能</strong>实现数据的普通共享，<strong>只能</strong>实现文件级的共享）</li>\n<li>数据的独立性：独立性差，提供了物理数据独立性（<strong>使数据共享成为可能</strong>）</li>\n<li>数据控制能力：应用程序自己控制</li>\n</ul>\n<h4 id=\"三数据库系统阶段\"><a class=\"markdownIt-Anchor\" href=\"#三数据库系统阶段\">#</a> 三。数据库系统阶段：</h4>\n<p><strong>20 世纪 60 年代后期以来</strong>，<strong>解决了数据的冗余</strong>；数据变更时，能节省对多个数据副本的变更操作，<strong>大大缩小计算机运算时间开销</strong>，还要求数据具有更高的独立性，不但<strong>具有物理独立性</strong>，而且<strong>具有逻辑独立性</strong>，从而<strong>节省应用程序开发的维护和代价</strong>数据库系统孕育而生。</p>\n<p>特点如下：</p>\n<ol>\n<li>数据集成\n<ul>\n<li><strong>数据的集成是数据库管理系统的主要目的</strong>，可<strong>使数据得到最大程度的共享，且冗余最小</strong></li>\n</ul>\n</li>\n<li>数据共享性高\n<ul>\n<li><strong>一个数据可以为多个不同的用户共同使用</strong></li>\n</ul>\n</li>\n<li>数据冗余小</li>\n<li>数据一致性\n<ul>\n<li>通过消除或控制数据冗余，可以在一定范围内避免数据的不一致性。<strong>引起不一致的根源是数据冗余</strong></li>\n</ul>\n</li>\n<li>数据独立性高\n<ul>\n<li><strong>数据定义</strong>与<strong>使用数据的应用程序分离</strong>被称为<strong>数据独立</strong>（数据或应用程序的修改不会彼此引起另一方的修改，两层数据独立）</li>\n</ul>\n</li>\n<li>实施统一管理与控制\n<ul>\n<li>主要包括数据<strong>安全性</strong>、<strong>完整性</strong>、<strong>并发控制</strong>、<strong>故障恢复</strong>等，即<strong>数据库保护</strong></li>\n<li>数据的安全性：<strong>保护数据</strong>，放置不合法的使用造成数据泄密和破坏</li>\n<li>数据的完整性：对数据的<strong>正确性</strong>、<strong>有效性</strong>和<strong>相容性</strong>要求</li>\n<li>并发控制：规避多线程并发造成的安全问题</li>\n<li>故障恢复：在出现问题时，数据库系统（DBMS）必须具有将数据库从错误状态恢复到某一已知的正确状态的功能</li>\n</ul>\n</li>\n<li>减少应用程序开发与维护的工作量\n<ul>\n<li>由于数据库<strong>数据具有共享性、独立性</strong>，在开发与维护新的应用<strong>所花费的代价和时间大大减少</strong></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"第三节数据库系统的结构\"><a class=\"markdownIt-Anchor\" href=\"#第三节数据库系统的结构\">#</a> 第三节：数据库系统的结构</h3>\n<h4 id=\"一三级模式结构的两层映像与数据独立性\"><a class=\"markdownIt-Anchor\" href=\"#一三级模式结构的两层映像与数据独立性\">#</a> 一。三级模式结构的两层映像与数据独立性</h4>\n<ol>\n<li><strong>外模式 / 模式映像</strong>（逻辑独立性）</li>\n<li><strong>模式 / 内模式映像</strong>（物理独立性）</li>\n</ol>\n<p>数据库系统</p>\n<ul>\n<li>内部系统结构（采用三级模式结构）\n<ul>\n<li>模式\n<ul>\n<li>模式也被称为<strong>概念模式</strong>或<strong>逻辑模式</strong>（实际上时数据库数据在逻辑级上的视图）</li>\n</ul>\n</li>\n<li>外模式\n<ul>\n<li>外模式也被称为<strong>子模式</strong>或<strong>用户模式</strong>（数据库用户能够看到和使用的局部数据）</li>\n</ul>\n</li>\n<li>内模式\n<ul>\n<li>内模式也被称为存储模式（对数据库中数据物理结构和存储方式 id 描述）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>外部系统结构</li>\n</ul>\n<p>【单选题】数据库系统的数据独立性是指（不会因为系统数据库存储结构与数据逻辑结构的变化而影响应用程序）</p>\n<h4 id=\"二数据库系统的运行与应用结构\"><a class=\"markdownIt-Anchor\" href=\"#二数据库系统的运行与应用结构\">#</a> 二。数据库系统的运行与应用结构</h4>\n<ol>\n<li>客户 / 服务器（<strong>Client/Server，C/S</strong>）模式\n<ul>\n<li>QQ、桌面客户端游戏</li>\n</ul>\n</li>\n<li>浏览器 / 服务器（<strong>Browser/Server，B/S</strong>）模式\n<ul>\n<li>网站、在线 web 游戏</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"第四节数据模型\"><a class=\"markdownIt-Anchor\" href=\"#第四节数据模型\">#</a> 第四节：数据模型</h3>\n<h4 id=\"一数据特征与数据模型组成要素\"><a class=\"markdownIt-Anchor\" href=\"#一数据特征与数据模型组成要素\">#</a> 一。数据特征与数据模型组成要素</h4>\n<ol>\n<li>\n<p>数据结构</p>\n<p>数据结构描述的是系统的<strong>静态特性</strong>，即数据对象的数据类型、内容、属性以及书对象之间的联系。</p>\n</li>\n<li>\n<p>数据操作</p>\n<p>数据操作描述的是系统的<strong>动态特性</strong>，是对各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则</p>\n</li>\n<li>\n<p>数据的约束条件</p>\n<p>数据约束描述数据结构中数据见的语法和语义关联，包括相互制约与依存关系以及数据动态变化规则，以保证数据的<strong>正确性、有效性与相容性</strong>。</p>\n</li>\n</ol>\n<h4 id=\"二数据模型的分类\"><a class=\"markdownIt-Anchor\" href=\"#二数据模型的分类\">#</a> 二。数据模型的分类</h4>\n<ol>\n<li>\n<p><strong>概念层数据模型</strong></p>\n<p>信息世界中的基本概念</p>\n<ul>\n<li>\n<p>实体（Entity）</p>\n<p>客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。</p>\n</li>\n<li>\n<p>属性（Attribute）</p>\n<p>实体所具有的某一特征称为属性。一个实体可以由若干个属性来刻画。</p>\n</li>\n<li>\n<p>码（Key）</p>\n<p><strong>唯一</strong>表示实体的<strong>属性集</strong>称为码。</p>\n</li>\n<li>\n<p>域（Domain）</p>\n<p>属性的<strong>取值范围</strong>称为该属性的域。</p>\n</li>\n<li>\n<p>实体型（Entity Type）</p>\n<p>用实体名及<strong>其属性</strong>名集合来抽象和刻画。同类实体称为<strong>实体型</strong>。</p>\n</li>\n<li>\n<p>实体集（Entity Set）</p>\n<p>同型实体的集合称为实体集。</p>\n</li>\n<li>\n<p>联系（Relationship）</p>\n<p>显示世界中事物内部以及事物之间的联系在信息世界中反应为实体内部的联系和实体之间的联系。</p>\n<p>实体型间联系：</p>\n<ul>\n<li>一对多\t1：N</li>\n<li>一对一    1：1</li>\n<li>多对多    N：M</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>概念模型（对应外模式）</strong></p>\n<ul>\n<li>\n<p>概念模型：用来描述现实世界的事物，与具体的计算机系统无关</p>\n<p><img data-src=\"%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/E-R%E5%9B%BE.png\" alt=\"\"><img data-src=\"/zxy/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/E-R%E5%9B%BE.png\" class=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>逻辑层数据模型（对应模式）</strong></p>\n<ol>\n<li>层次模型；</li>\n<li>网状模型；</li>\n<li><strong>关系模型；</strong></li>\n<li>面向对象模型；</li>\n</ol>\n</li>\n<li>\n<p><strong>物理层数据模型（对应内模式）</strong></p>\n<p>物理层数据模型，也称为数据的<strong>物理模型</strong>（Physical Model），其描述数据在<strong>存储介质</strong>上的组织结构，是逻辑模型的物理实现，即每一种逻辑模型在实现时都有与其对应的物理模型。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"第二章-关系数据库\"><a class=\"markdownIt-Anchor\" href=\"#第二章-关系数据库\">#</a> 第二章、关系数据库</h2>\n<h3 id=\"第一节关系数据库概述\"><a class=\"markdownIt-Anchor\" href=\"#第一节关系数据库概述\">#</a> 第一节：关系数据库概述</h3>\n<h4 id=\"一基本简介\"><a class=\"markdownIt-Anchor\" href=\"#一基本简介\">#</a> 一。基本简介</h4>\n<p>系统而严格提出关系模型的是<strong>美国 IBM 公司的 E.F.Codd</strong></p>\n<ul>\n<li><strong>1970 年</strong>提出<strong>关系数据模型</strong>；</li>\n<li>1970 年<strong> E.F.Codd</strong> 发表了《Communication of the ACM》</li>\n<li>之后提出了，<strong>关系代数和关系演算的概念</strong>；</li>\n<li><strong>1972 年</strong>提出了关系的<strong>第一、第二、第三范式</strong>；</li>\n<li><strong>1974 年</strong>提出了关系的<strong> BC 范式</strong>。</li>\n</ul>\n<p>关系数据库应用<strong>数学方法</strong>来<strong>处理数据库的数据</strong></p>\n<p>80 年代后，关系数据库系统成为最重要、最流行的数据库系统。</p>\n<ul>\n<li>典型的实验系统：\n<ul>\n<li>System R</li>\n<li>University INGRES</li>\n</ul>\n</li>\n<li>典型商用系统\n<ul>\n<li>ORACLE</li>\n<li>SYBASE</li>\n<li>INFORMIX</li>\n<li>IBM DB2</li>\n<li>SQL service</li>\n</ul>\n</li>\n</ul>\n<p>关系模型的数据结构（类似于 Excel）</p>\n<h4 id=\"二基本术语\"><a class=\"markdownIt-Anchor\" href=\"#二基本术语\">#</a> 二。基本术语</h4>\n<ol>\n<li>\n<p><strong>表（Table）</strong></p>\n</li>\n<li>\n<p><strong>关系（Relation）</strong></p>\n</li>\n<li>\n<p><strong>列（Column）</strong></p>\n<p>也被称为<strong>字段</strong>或者<strong>属性</strong></p>\n</li>\n<li>\n<p><strong>属性（Attribute）</strong></p>\n<p>在数据表中，<strong>一列即为一个属性</strong>，给每一个属性起一个名称即为属性名。与之同义的术语是”<strong> 列</strong> “。表中的<strong>属性的个数称为关系的元或度</strong>。<strong>列的值称为属性值</strong>；<strong>属性值的取值范围称为值域</strong>；</p>\n</li>\n<li>\n<p><strong>行（Row）</strong></p>\n<p>表中行（Row），也称作元组（Tuple）或记录</p>\n</li>\n<li>\n<p><strong>元组（Tuple）</strong></p>\n<p>表中的一行即为一个元组（一条数据即为一个元组）</p>\n</li>\n<li>\n<p><strong>分量（Component）</strong></p>\n<p>元组中的一个属性值，称为分量</p>\n</li>\n<li>\n<p><strong>码或键（Key）</strong></p>\n<p>如果在一个关系中，存在这样的属性（或属性组），使得在该关系的任何一个关系状态中的两个元组，在该属性（或属性组）上值的组合都不相同，即这些属性（或属性组）的值都能用来唯一标识该关系的元组，称此属性（或属性组）为该关系的码或键</p>\n</li>\n<li>\n<p><strong>超码或超键（Super Key）</strong></p>\n<p>如果在关系的一个码中移去某个属性，它仍然是这个关系的码，则称这样的码或键为该关系的超码或超键</p>\n</li>\n<li>\n<p><strong>候选码或候选键（Candidate Key）</strong></p>\n<p>如果在关系的一个码或键中，不能从中移去任何一个属性，否则它就不是这个关系的码或键，则称这样的码或键为该关系的候选码或候选键</p>\n</li>\n<li>\n<p><strong>主码或主键（Primary Key）</strong></p>\n<p>在一个关系的若干个候选码或候选键中指定一个用来唯一标识关系的元组，则称这个被指定的候选码或候选键为该关系的主码或主键</p>\n</li>\n<li>\n<p><strong>全码或全键（All-Key）</strong></p>\n<p>一个关系模式的所有属性集合是这个关系的主码或主键，则称这样的主码或主键为全码或全键</p>\n</li>\n<li>\n<table>\n<thead>\n<tr>\n<th>列</th>\n<th>列的值被称为属性值</th>\n<th>属性的个数称为元或度</th>\n<th>属性值的取值范围叫做值域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>行</strong></td>\n<td><strong>行被称为元组或记录</strong></td>\n<td><strong>元组的一个属性值称为分量</strong></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><img data-src=\"%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%A0%81.png\" alt=\"\"><img data-src=\"/zxy/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%A0%81.png\" class=\"\"></p>\n</li>\n<li>\n<p><strong>主属性（Primary Attribute）和非主属性（Nonprimary Attribute）</strong></p>\n<p>在候选码中的属性称为主属性或码属性；</p>\n<p>不在候选码中的属性称为非主属性或非码属性。</p>\n</li>\n<li>\n<p><strong>外码或外键（Foreign Key）</strong></p>\n<p>该表的某个属性是其他表的主键，则是这个关系的外码或外键</p>\n</li>\n<li>\n<p><strong>参照关系（Referencing Relation）和被参照关系（Referenced Relation）</strong></p>\n<p>以外键为主键的表称为被参照关系；外键所在的表为参照关系。被参照关系和参照关系是通过外键相联系的，这种联系通常是一对多</p>\n</li>\n<li>\n<p><strong>域（Domain）</strong></p>\n<p>表示属性的取值范围</p>\n</li>\n<li>\n<p><strong>数据类型（Data Type）</strong></p>\n<p>每个字段名都有相对应的数据类型</p>\n</li>\n<li>\n<p><strong>关系模式（Relation Schema）</strong></p>\n<p>数据库存在 “型” 和 “值” 之分，关系数据库中，关系模式是型，关系是值；关系模式是静态的，关系是动态的。关系模式是对关系的描述.</p>\n</li>\n<li>\n<p><strong>关系数据库（Relation Datebase）</strong></p>\n<p>关系数据库是以关系模式为数据的逻辑模型，并采用关系作为数据组织方式的一类数据库，其数据库建立在关系代数上</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"第二节关系数据库模型\"><a class=\"markdownIt-Anchor\" href=\"#第二节关系数据库模型\">#</a> 第二节：关系数据库模型</h3>\n<h4 id=\"一基本的关系集合\"><a class=\"markdownIt-Anchor\" href=\"#一基本的关系集合\">#</a> 一。基本的关系集合</h4>\n<ol>\n<li>关系数据语言的分类\n<ul>\n<li>关系操作的能力用两种方式表示：<strong>代数方式</strong>和<strong>逻辑方式</strong>\n<ul>\n<li>代数方式主要有关系代数，通过对关系的操作来达到查询</li>\n<li>逻辑方式主要有关系演算，通过使用位于来表达查询要求的方式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"二关系的完整性约束\"><a class=\"markdownIt-Anchor\" href=\"#二关系的完整性约束\">#</a> 二。关系的完整性约束</h4>\n<ol>\n<li>关系的完整约束\n<ul>\n<li>主键不能为空</li>\n</ul>\n</li>\n<li>参照完整性约束\n<ul>\n<li>外键需要一一对应</li>\n</ul>\n</li>\n<li>用户定义完整性约束\n<ul>\n<li>对数据进行的约束；例：数据类型，数据长度</li>\n</ul>\n</li>\n<li>关系模型完整性约束的检验\n<ol>\n<li>执行插入操作</li>\n<li>执行删除操作</li>\n<li>执行更新操作</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h3 id=\"第三节关系数据库的规范化理论重点\"><a class=\"markdownIt-Anchor\" href=\"#第三节关系数据库的规范化理论重点\">#</a> 第三节：关系数据库的规范化理论（重点）</h3>\n<h4 id=\"一关系模型中可能存在的冗余和异常问题\"><a class=\"markdownIt-Anchor\" href=\"#一关系模型中可能存在的冗余和异常问题\">#</a> 一。关系模型中可能存在的冗余和异常问题</h4>\n<ol>\n<li>数据冗余</li>\n<li>更新异常</li>\n<li>插入异常</li>\n<li>删除异常</li>\n</ol>\n<h4 id=\"二函数依赖的关键字\"><a class=\"markdownIt-Anchor\" href=\"#二函数依赖的关键字\">#</a> 二。函数依赖的关键字</h4>\n<ol>\n<li>\n<p>完全函数依赖</p>\n<p>$ X \\to Y$ 但是 x 真子集不能依赖 Y, 则 Y 完全依赖于 X</p>\n</li>\n<li>\n<p>部分函数依赖</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X → Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, 但是 X 真子集可以依赖 Y，则 Y 部分依赖于 X</p>\n</li>\n<li>\n<p>传递函数依赖</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X → Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>，且<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><mi mathvariant=\"normal\">¬</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">Y \\neg\\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mord\">¬</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">Y → Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span>，则<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">X → Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span></p>\n</li>\n<li>\n<p>关键字</p>\n<p>当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X → Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> 时，则 X 为 Y 的候选关键字</p>\n</li>\n</ol>\n<h4 id=\"三范式与关系规范化过程\"><a class=\"markdownIt-Anchor\" href=\"#三范式与关系规范化过程\">#</a> 三。范式与关系规范化过程</h4>\n<ol>\n<li>\n<p>第一范式：行和列不可再分</p>\n</li>\n<li>\n<p>第二范式：不可冗余</p>\n</li>\n<li>\n<p>第三范式、BC 范式：保证主键唯一</p>\n</li>\n<li>\n<p>关系规范化理论的应用</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"第三章数据库设计\"><a class=\"markdownIt-Anchor\" href=\"#第三章数据库设计\">#</a> 第三章：数据库设计</h2>\n<h3 id=\"第一节数据库设计概述\"><a class=\"markdownIt-Anchor\" href=\"#第一节数据库设计概述\">#</a> 第一节：数据库设计概述</h3>\n<h4 id=\"一生命周期\"><a class=\"markdownIt-Anchor\" href=\"#一生命周期\">#</a> 一。生命周期</h4>\n<ol>\n<li>\n<p>数据库分析与设计阶段</p>\n<ul>\n<li>需求分析</li>\n<li>概念设计</li>\n<li>逻辑设计</li>\n<li>物理设计</li>\n</ul>\n</li>\n<li>\n<p>数据库实现与操作阶段</p>\n<ul>\n<li>数据库的实现</li>\n<li>操作与监督</li>\n<li>修改与调整</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"二数据库设计的目标\"><a class=\"markdownIt-Anchor\" href=\"#二数据库设计的目标\">#</a> 二。数据库设计的目标</h4>\n<ul>\n<li>满足应用功能需求</li>\n<li>良好的数据库性能</li>\n</ul>\n<h4 id=\"三数据库设计的内容\"><a class=\"markdownIt-Anchor\" href=\"#三数据库设计的内容\">#</a> 三。数据库设计的内容</h4>\n<ol>\n<li>数据库结构设计</li>\n<li>数据库行为设计</li>\n</ol>\n<h4 id=\"四数据库设计的方法\"><a class=\"markdownIt-Anchor\" href=\"#四数据库设计的方法\">#</a> 四。数据库设计的方法</h4>\n<ol>\n<li>直观设计法（不可取）</li>\n<li>规范设计法\n<ol>\n<li>新奥尔良设计方法</li>\n<li>基于 E-R 模型的数据库设计方法</li>\n<li>基于第三范式的设计方法</li>\n</ol>\n</li>\n<li>计算机辅助设计法</li>\n</ol>\n<h4 id=\"五数据库设计的过程\"><a class=\"markdownIt-Anchor\" href=\"#五数据库设计的过程\">#</a> 五。数据库设计的过程</h4>\n<p><img data-src=\"%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png\" alt=\"\"><img data-src=\"/zxy/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png\" class=\"\"></p>\n<hr>\n<h3 id=\"第二节数据库设计的基本步骤\"><a class=\"markdownIt-Anchor\" href=\"#第二节数据库设计的基本步骤\">#</a> 第二节：数据库设计的基本步骤</h3>\n<h4 id=\"一需求分析\"><a class=\"markdownIt-Anchor\" href=\"#一需求分析\">#</a> 一。需求分析</h4>\n<p>​\t\t数据库设计中最重要的一个阶段，即确定数据库应支持哪些功能</p>\n<ol>\n<li>\n<p>应用过程分析</p>\n<p>指了解并分析数据与数据处理间的关系。在数据库范围确定后，设计人员应逐次廖尔吉每个功能需要用到哪些数据、数据使用的顺序、对数据做何处理的策略以及处理的结果</p>\n</li>\n<li>\n<p>收集与分析数据</p>\n<ol>\n<li>\n<p>静态结构</p>\n<p>指不是加应用操作于其上时数据的原始状况，可通过数据分类表和数据元素表进行说明</p>\n<p>例：公司表中部门名称这一字段名基本不变</p>\n</li>\n<li>\n<p>动态结构</p>\n<p>指应用操作施加于数据之上后数据的状况，可通过任务分类表和数据操作特征表进行说明。</p>\n</li>\n<li>\n<p>数据约束</p>\n</li>\n</ol>\n</li>\n<li>\n<p>编写需求分析</p>\n<ol>\n<li>数据库的应用功能目标\n<ul>\n<li>功能要求</li>\n<li>性能要求</li>\n</ul>\n</li>\n<li>标明不同用户视图范围</li>\n<li>应用处理过程需求说明</li>\n<li>数据字典</li>\n<li>数据量</li>\n<li>数据约束</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"二概念结构设计\"><a class=\"markdownIt-Anchor\" href=\"#二概念结构设计\">#</a> 二。概念结构设计</h4>\n<p>​\t\t在需求分析的基础按照特定的方法设计满足应用需求的用户信息结构，该信息结构通常称为概念模型。其中 E-R 图为概念模型的描述工具。</p>\n<h4 id=\"三逻辑结构设计\"><a class=\"markdownIt-Anchor\" href=\"#三逻辑结构设计\">#</a> 三。逻辑结构设计</h4>\n<p><img data-src=\"%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.png\" alt=\"\"><img data-src=\"/zxy/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.png\" class=\"\"></p>\n<h4 id=\"四物理设计\"><a class=\"markdownIt-Anchor\" href=\"#四物理设计\">#</a> 四。物理设计</h4>\n<p>​\t\t指对于一个给定的数据逻辑结构，研究并构造物理结构的过程。主要任务时确定数据库在存储设别上的存储结构及存取方法。</p>\n<h4 id=\"五数据库实施\"><a class=\"markdownIt-Anchor\" href=\"#五数据库实施\">#</a> 五。数据库实施</h4>\n<ol>\n<li>加载数据</li>\n<li>应用程序设计</li>\n<li>数据库试运行</li>\n</ol>\n<h4 id=\"六数据库运行和维护\"><a class=\"markdownIt-Anchor\" href=\"#六数据库运行和维护\">#</a> 六。数据库运行和维护</h4>\n<p>当数据库投入到实际生产中标志这设计和应用开发基本完成，但不代表设计和应用开发工作的终止。系统维护最困难的工作时数据库重组和重构。</p>\n<hr>\n<h3 id=\"第三节关系数据库设计方法\"><a class=\"markdownIt-Anchor\" href=\"#第三节关系数据库设计方法\">#</a> 第三节：关系数据库设计方法</h3>\n<h4 id=\"一关系数据库设计过程于各级模式\"><a class=\"markdownIt-Anchor\" href=\"#一关系数据库设计过程于各级模式\">#</a> 一。关系数据库设计过程于各级模式</h4>\n<h4 id=\"二概念结构设计方法\"><a class=\"markdownIt-Anchor\" href=\"#二概念结构设计方法\">#</a> 二。概念结构设计方法</h4>\n<ol>\n<li><strong>E-R 图的表示方法</strong>\n<ol>\n<li>实体类型，用矩形表示，框内写明实体的名称</li>\n<li>属性，用椭圆表示，将与之相应的实体连接起来</li>\n<li>联系，用菱形表示，框内写明联系的名称，同时在旁边表上联系的类型（1：1、1：N 或者 M：N）</li>\n</ol>\n</li>\n<li><strong>局部信息结构设计</strong>\n<ol>\n<li><strong>确定局部范围</strong>：主要依据需求分析报告中标明的用户视图范围来确定</li>\n<li><strong>选择实体</strong>：在确认局部范围内选择一些合适的信息单位作为局部信息结构的基本实体</li>\n<li><strong>选择实体关键字</strong></li>\n<li><strong>确定实体间联系</strong>：数据间的联系必须在概念设计时确定</li>\n<li><strong>确定实体的属性</strong>：分为标识属性和说明属性两类。\n<ul>\n<li>标识属性用作实体的关键字</li>\n<li>说明属性用作描述实体的一般特征</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><strong>全局信息结构设计</strong>\n<ol>\n<li>属性冲突</li>\n<li>命名冲突</li>\n<li>结构冲突</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"第四章sql与关系数据库基本操作\"><a class=\"markdownIt-Anchor\" href=\"#第四章sql与关系数据库基本操作\">#</a> 第四章：SQL 与关系数据库基本操作</h2>\n<h3 id=\"第一节sql概述\"><a class=\"markdownIt-Anchor\" href=\"#第一节sql概述\">#</a> 第一节：SQL 概述</h3>\n<ol>\n<li>\n<h4 id=\"sql的发展\"><a class=\"markdownIt-Anchor\" href=\"#sql的发展\">#</a> SQL 的发展</h4>\n<p><strong>1974 年</strong>由<strong> Boyce</strong> 和<strong> Chamberlin</strong> 提出的</p>\n<p>20 世纪 80 年代以来，SQL 一直是数据库管理系统的标准语言。</p>\n<p>至今 SQL 成为了一个通用的、功能极强的关系数据库语言</p>\n<p>SQL 是一个<strong>综合的</strong>、<strong>功能强大的</strong>且<strong>简洁易懂</strong>的语言；</p>\n<p>SQL 的目的就是要能够很好的提供一种从数据库中读取数据的简单而有效的方法</p>\n</li>\n<li>\n<h4 id=\"sql的特点\"><a class=\"markdownIt-Anchor\" href=\"#sql的特点\">#</a> SQL 的特点</h4>\n<ol>\n<li>SQL 不是某个特定数据库供应商专有的语言</li>\n<li>SQL 简单易学</li>\n<li>SQL 看上去简单，但实际上是一种强有力的语言，灵活使用可以进行非常复杂和高级的数据库操作，并且不区分大小写</li>\n</ol>\n</li>\n<li>\n<h4 id=\"sql的组成\"><a class=\"markdownIt-Anchor\" href=\"#sql的组成\">#</a> SQL 的组成</h4>\n<ol>\n<li>数据定义语言（DDL）</li>\n<li>数据操纵语言（DML）</li>\n<li>数据控制语言（DCL）</li>\n<li>嵌入式和动态 SQL 规则</li>\n<li>SQL 条用和会话规则</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"第二节mysql预备知识\"><a class=\"markdownIt-Anchor\" href=\"#第二节mysql预备知识\">#</a> 第二节：Mysql 预备知识</h3>\n<h4 id=\"一mysql使用基础\"><a class=\"markdownIt-Anchor\" href=\"#一mysql使用基础\">#</a> 一.MySQL 使用基础</h4>\n<ol>\n<li>LAMP（Linux+Apache+Mysql+PHP/Perl+Python）</li>\n<li>WAMP（Windows+Apache+Mysql+PHP/Perl/Python）</li>\n</ol>\n<h4 id=\"二mysql中的sql\"><a class=\"markdownIt-Anchor\" href=\"#二mysql中的sql\">#</a> 二.MySQL 中的 SQL</h4>\n<ol>\n<li>常量\n<ol>\n<li>字符串常量</li>\n<li>数值常量\n<ul>\n<li>整数常量</li>\n<li>浮点数常量</li>\n</ul>\n</li>\n<li>十六进制常量（转换时使用，cast (…as unsigned)）</li>\n<li>日期时间常量\n<ul>\n<li>包括年、月、日，数据类型为 DATE</li>\n<li>包括小时数、分钟数、秒数及微秒数，数据类型为 TIME</li>\n</ul>\n</li>\n<li>位字段值（了解）</li>\n<li>布尔值</li>\n<li>NUll 值</li>\n</ol>\n</li>\n<li>变量\n<ol>\n<li>用户变量：用户在表达式中使用自己定义的变量，用户变量前加 @用来区分列名</li>\n</ol>\n</li>\n<li>运算符\n<ol>\n<li>算术运算符：+、-、*、/</li>\n<li>位运算符：&amp;（与）、|（位）、^（位异或）、~（位取反）、&gt;&gt;（位右移，除以 2）、&lt;&lt;（位左移，乘以 2）<br>\n3. 比较运算符： 逻辑非、逻辑与、逻辑或、逻辑异或</li>\n</ol>\n</li>\n<li>表达式</li>\n<li>内置函数\n<ul>\n<li>数学函数：ABS（）—— 绝对值、SORT（）—— 去开</li>\n<li>聚合函数：COUNT（）—— 计数</li>\n<li>字符串函数：ASCII（）—— 转换成 ASCII 码、CHAR（）—— 转换城字符串</li>\n<li>日期和时间函数：NOW（）—— 截取当前是时间值、Year（）—— 截取当前年份</li>\n<li>加密函数：encode（）、encrypt（）</li>\n<li>类型转换：cast（）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"第三节数据定义\"><a class=\"markdownIt-Anchor\" href=\"#第三节数据定义\">#</a> 第三节：数据定义</h3>\n<h4 id=\"一数据库模式定义\"><a class=\"markdownIt-Anchor\" href=\"#一数据库模式定义\">#</a> 一。数据库模式定义</h4>\n<ol>\n<li>新建数据库：create database 数据库名</li>\n<li>选择数据库：use 数据库名</li>\n<li>修改数据库：alter database 数据库名</li>\n<li>删除数据库：drop database [if exists] 数据库名 （括号的可加可不加）</li>\n<li>查看数据库：show database</li>\n</ol>\n<h4 id=\"二表定义\"><a class=\"markdownIt-Anchor\" href=\"#二表定义\">#</a> 二。表定义</h4>\n<ol>\n<li>创建表：create [temporary] table 表名（增加了括号的关键字，只是临时表）</li>\n<li>更新表：alter table 数据库名。表名\n<ol>\n<li>添加字段：add column 字段名 数据类型 是否为空 default  after 字段名（after 在哪个字段后面增加）</li>\n<li>修改字段：change column | alter | modify 现在的字段名 更改的字段名 数据类型 是否为空 default’ ’\n<ul>\n<li>alter 只能修改和删除默认值</li>\n<li>change 可以修改表中字段名，类型，默认值</li>\n<li>modify 只可以修改现有字段的类型和默认值等</li>\n</ul>\n</li>\n<li>删除字段名：alter table 表名 drop column 字段名</li>\n</ol>\n</li>\n<li>重命名数据表：\n<ul>\n<li>alter table 原表名 rename 新表名；</li>\n<li>alter table 原表名 to 新表名</li>\n</ul>\n</li>\n<li>删除表：drop table [if exists] 表名</li>\n<li>查看表：show columns from 表名；(desc)</li>\n</ol>\n<h4 id=\"三索引定义\"><a class=\"markdownIt-Anchor\" href=\"#三索引定义\">#</a> 三。索引定义</h4>\n<p>索引</p>\n<ul>\n<li>用途索引\n<ul>\n<li>普通索引（index）</li>\n<li>唯一性索引（unique）</li>\n<li>主键（primary key）</li>\n<li>全文索引（fulltext）[引擎 Myisam]</li>\n<li>聚簇索引 [引擎 InnoDB]</li>\n</ul>\n</li>\n<li>列级索引\n<ul>\n<li>单列索引</li>\n<li>组合索引</li>\n</ul>\n</li>\n<li>添加方法：create [unique] index 索引名 on 表名 （创建索引的列名 [(length)] [ASC|DESC]）</li>\n<li>查看索引：show index from 数据库名。表名</li>\n<li>删除索引：drop index 索引名 on 表名</li>\n</ul>\n<h3 id=\"第四节数据更新\"><a class=\"markdownIt-Anchor\" href=\"#第四节数据更新\">#</a> 第四节：数据更新</h3>\n<h4 id=\"一插入数据\"><a class=\"markdownIt-Anchor\" href=\"#一插入数据\">#</a> 一。插入数据</h4>\n<ul>\n<li>insert into 表名（字段名）values (数据),(数据)</li>\n<li>insert 表名 set 字段名 = {}</li>\n</ul>\n<h4 id=\"二删除数据\"><a class=\"markdownIt-Anchor\" href=\"#二删除数据\">#</a> 二。删除数据</h4>\n<ul>\n<li>delete from 表名 where</li>\n<li>truncate 表名 ——（全部清空）</li>\n</ul>\n<h4 id=\"三修改数据\"><a class=\"markdownIt-Anchor\" href=\"#三修改数据\">#</a> 三。修改数据</h4>\n<ul>\n<li>update 表名 set 字段名 = 数据</li>\n</ul>\n<h3 id=\"第五节数据查询\"><a class=\"markdownIt-Anchor\" href=\"#第五节数据查询\">#</a> 第五节：数据查询</h3>\n<h4 id=\"一selecet语句\"><a class=\"markdownIt-Anchor\" href=\"#一selecet语句\">#</a> 一.selecet 语句</h4>\n<h4 id=\"二列的选择与指定\"><a class=\"markdownIt-Anchor\" href=\"#二列的选择与指定\">#</a> 二。列的选择与指定</h4>\n<h4 id=\"三from子句与多表连接查询\"><a class=\"markdownIt-Anchor\" href=\"#三from子句与多表连接查询\">#</a> 三.from 子句与多表连接查询</h4>\n<h3 id=\"第六节视图\"><a class=\"markdownIt-Anchor\" href=\"#第六节视图\">#</a> 第六节：视图</h3>\n<h4 id=\"一创建视图\"><a class=\"markdownIt-Anchor\" href=\"#一创建视图\">#</a> 一。创建视图</h4>\n<h4 id=\"二删除视图\"><a class=\"markdownIt-Anchor\" href=\"#二删除视图\">#</a> 二。删除视图</h4>\n<h4 id=\"三修改视图\"><a class=\"markdownIt-Anchor\" href=\"#三修改视图\">#</a> 三。修改视图</h4>\n<h4 id=\"四查看视图定义\"><a class=\"markdownIt-Anchor\" href=\"#四查看视图定义\">#</a> 四。查看视图定义</h4>\n<h4 id=\"五更新视图数据\"><a class=\"markdownIt-Anchor\" href=\"#五更新视图数据\">#</a> 五。更新视图数据</h4>\n<h4 id=\"六查询视图数据\"><a class=\"markdownIt-Anchor\" href=\"#六查询视图数据\">#</a> 六。查询视图数据</h4>\n<hr>\n<h2 id=\"第五章数据库编程\"><a class=\"markdownIt-Anchor\" href=\"#第五章数据库编程\">#</a> 第五章：数据库编程</h2>\n<h3 id=\"第一节存储过程\"><a class=\"markdownIt-Anchor\" href=\"#第一节存储过程\">#</a> 第一节：存储过程</h3>\n<h4 id=\"一存储过程的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#一存储过程的基本概念\">#</a> 一。存储过程的基本概念</h4>\n<p>就是一组为了完成某项特定功能的 SQL 语句集，实质上就是一段存储在数据库中的代码</p>\n<p>优点如下:</p>\n<ol>\n<li>提高运行速度；</li>\n<li>增强了 SQL 的功能的灵活性；</li>\n<li>可以降低网络的通信量；</li>\n<li>减轻了程序编写的工作量；</li>\n<li>间接实现了安全控制功能；</li>\n</ol>\n<h4 id=\"二创建存储过程\"><a class=\"markdownIt-Anchor\" href=\"#二创建存储过程\">#</a> 二。创建存储过程</h4>\n<ul>\n<li>delimiter $$ —— 修改结束符为 $$，因为在使用的封装的时候会经常使用；号，程序会识别出错，为了避免，所以在使用 procedure 的时候，需要先把结束符更改一下</li>\n<li>create procedure [IN | OUT | INPUT] 参数名 数据类型</li>\n</ul>\n<h4 id=\"三存储过程体\"><a class=\"markdownIt-Anchor\" href=\"#三存储过程体\">#</a> 三。存储过程体</h4>\n<ol>\n<li>\n<p><strong>局部变量</strong></p>\n<ul>\n<li>声明局部变量：declare 变量名 数据类型；若不给的话，默认数据类型为 null</li>\n</ul>\n</li>\n<li>\n<p>局部变量赋值</p>\n<ul>\n<li>SET 变量名 = 数值</li>\n<li>select 字段名 into 要赋值的变量名 表名（返回的结果集只能有一行）</li>\n</ul>\n</li>\n<li>\n<p>流程控制语句</p>\n<ul>\n<li>If    else  end if</li>\n<li>case    when 条件 then 语句    end case</li>\n<li>while  do  end while |  repeat  until   end repeat  | loop     end loop</li>\n</ul>\n</li>\n<li>\n<p>游标（可以存多个变量，因为 select into 只能保存一行数据，所以可以建立一个游标，再从游标中获取单行数据放入局部变量中）</p>\n<ul>\n<li></li>\n<li>打开游标：open 游标名</li>\n<li>读取游标：fetch 游标名 into 变量</li>\n<li>关闭游标：close 游标名</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"四调用存储过程\"><a class=\"markdownIt-Anchor\" href=\"#四调用存储过程\">#</a> 四。调用存储过程</h4>\n<p>其实就是调用方法</p>\n<ul>\n<li>调用方法\n<ul>\n<li>CALL 存储过程名（）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"五删除存储过程\"><a class=\"markdownIt-Anchor\" href=\"#五删除存储过程\">#</a> 五。删除存储过程</h4>\n<ul>\n<li>drop procedure [if exists] 存储过程名；</li>\n</ul>\n<h4 id=\"六样式案例\"><a class=\"markdownIt-Anchor\" href=\"#六样式案例\">#</a> 六。样式案例</h4>\n<pre><code class=\"language-mariadb\">use 数据库名\t\t\t先调用\ndelimiter $$\t\t  修改结束符,关闭终端后，会更改回;\ncreate procedure 存储过程名 (IN p_no varchar(10),IN p_name varchar(255))\n\nbegin\ndeclare a int default 0;\ndeclare b int;\ndeclare c int;\nset b = 10;\nselect Id into c from pro where pno='001';\n\n\tinsert into pro(pno,pname) values (p_no,p_name);\nend $$\n\ncall 存储过程名 (实参)\t\t不用觉得很难，其实就是封装\n</code></pre>\n<h4 id=\"七教材案例\"><a class=\"markdownIt-Anchor\" href=\"#七教材案例\">#</a> 七。教材案例</h4>\n<pre><code class=\"language-mariadb\">delimiter $$\ncreate procedure pro_num (OUT ROWS INT)\nbegin\ndeclare cid INT;\ndeclare found boolean default true;\ndeclare cur_cid cursor for\n\tselect pno form pro;\ndeclare continue handler for not found \n\tset found = 0;\nset ROWS =0;\nopen cur_cid;\nfetch cur_cid into cid;\nwhile found do\nset ROWS=ROWS+1;\nfetch cur_cid into cid;\nend while;\ncolse cur_cid\nend $$\n</code></pre>\n<h3 id=\"第二节存储函数\"><a class=\"markdownIt-Anchor\" href=\"#第二节存储函数\">#</a> 第二节：存储函数</h3>\n<h4 id=\"一创建存储函数\"><a class=\"markdownIt-Anchor\" href=\"#一创建存储函数\">#</a> 一。创建存储函数</h4>\n<p>create function 函数名 (形参 形参的数据类型)</p>\n<h4 id=\"二调用存储函数\"><a class=\"markdownIt-Anchor\" href=\"#二调用存储函数\">#</a> 二。调用存储函数</h4>\n<p>select 函数名 (实参)</p>\n<h4 id=\"三删除存储函数\"><a class=\"markdownIt-Anchor\" href=\"#三删除存储函数\">#</a> 三。删除存储函数</h4>\n<p>drop function [if exists] 函数名；</p>\n<pre><code class=\"language-mariadb\">use 数据库名;\ndelimiter $$\ncreate function 函数名(形参+形参的数据类型)\n\treturns 返回值类型\n\tdeterministic\t\t\t\t表示函数的 返回值完全由输入参数决定\nbegin\n\nend $$\ndelimiter ;\n</code></pre>\n<hr>\n<h2 id=\"第六章数据库安全与保护\"><a class=\"markdownIt-Anchor\" href=\"#第六章数据库安全与保护\">#</a> 第六章：数据库安全与保护</h2>\n<h3 id=\"第一节数据库完整性\"><a class=\"markdownIt-Anchor\" href=\"#第一节数据库完整性\">#</a> 第一节：数据库完整性</h3>\n<h4 id=\"一完整性约束条件的作用对象\"><a class=\"markdownIt-Anchor\" href=\"#一完整性约束条件的作用对象\">#</a> 一。完整性约束条件的作用对象</h4>\n<ol>\n<li>\n<p>列级约束</p>\n<p>列级约束主要指对列的类型、取值范围、精度等的约束</p>\n<ul>\n<li>对数据类型的约束</li>\n<li>对数据格式的约束</li>\n<li>对取值范围或取值集合的约束</li>\n<li>对空值的约束</li>\n</ul>\n</li>\n<li>\n<p>元组约束</p>\n<p>元组约束指元组中各个字段之间的相互约束，例如某个活动的开始日期小于结束日期</p>\n</li>\n<li>\n<p>表级约束</p>\n<p>表级约束指若干元组之间、关系之际的联系的约束，常用在外键上</p>\n</li>\n</ol>\n<p>二。定义与实现完整性约束</p>\n<ol>\n<li>\n<p>实体完整性：保证记录不重复，至少有一列值不重复，用 primary key 添加约束</p>\n<p>候选键约束用关键字 unique 进行约束</p>\n<ul>\n<li>一个表只能由一个主键，但是候选键可以有若干个</li>\n</ul>\n</li>\n<li>\n<p>参照完整性：主要指两个表之间的关系，比如课程表开设依赖于教师表，没有教师就不能由教师的课，保证数据的正确性</p>\n<ul>\n<li>\n<pre><code class=\"language-mariadb\">foreign key(本表字段)\n\treferences 外键表(外键的字段名)\n\t\ton delete (restrict|cascade|set null|no action)\n\t\ton update (restrict|cascade|set null|no action)\n\t\t\nrestrict\t\t当被参照表进行删除或更新时，系统拒绝该操作\ncascade\t\t\t两边可以实时更新\nset null|\t\t被参照表（主表）更新时，另一边更改为null\nno action\t\t当被参照表进行删除或更新时，系统拒绝该操作,与restrict相同\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>自定义完整性：</p>\n<ul>\n<li>非空约束：在创建表或更新表结构的时候在字段后面增加 <code>not null</code>  表示该字段不能为空</li>\n<li>check 约束：在创建表或更新表结构的时候使用，可作用在整张表或者单个字段上，用法跟 <code>not null</code>  一致，不过是增加了 sql 的限定条件。例：年龄不允许小于等于 0。\n<ul>\n<li>作用在字段上，则是基于列的 check 约束</li>\n<li>作用在表上，则是基于表的 check 约束</li>\n<li>语法：check (sql 表达式)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>命名完整性约束</p>\n<p>就是给约束起一个名字，方便后面对这个约束进行删除或修改等</p>\n<ul>\n<li>\n<p>给约束起一个名字</p>\n<pre><code class=\"language-mariadb\">mysql&gt; create table t_user(\n    -&gt; id int(10),\n    -&gt; name varchar(32) not null,\n    -&gt; constraint t_user_id_pk primary key(id)\n    -&gt; );\nQuery OK, 0 rows affected (0.01 sec)\n</code></pre>\n</li>\n<li>\n<p>完整性约束不能直接被修改。若要修改某个约束，其实是先把约束删除，在添加约束</p>\n<ul>\n<li>添加约束\n<ul>\n<li><code>alter table 表名 add [constraint 约束名字]primary key(主键字段)</code></li>\n<li><code>alter table 表名 add [constraint 约束名字]foreign key(外键字段名) refernces 被参照表(主键字段)</code></li>\n<li><code>alter table 表名 add [constraint 约束名字]unique key(主键字段)</code></li>\n</ul>\n</li>\n<li>删除约束\n<ul>\n<li><code>alter table 表名 drop foreign key 外键约束名</code></li>\n<li><code>alter table 表名 drop primary key</code></li>\n<li><code>alter table 表名 drop 约束名|候选键字段名</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"第二节触发器\"><a class=\"markdownIt-Anchor\" href=\"#第二节触发器\">#</a> 第二节：触发器</h3>\n<p>触发器是保护表数据的数据对象，当指定的表发生插入、更新、删除的时候触发，进行相应的动作。<strong>注：查询不会触发</strong></p>\n<ul>\n<li>\n<p>创建触发器</p>\n<ul>\n<li>\n<pre><code class=\"language-mariadb\">create trigger 触发器名 触发器触发的时刻 触发事件 \n\ton 与触发器绑定的表名 for each row 触发器主体（可以是单条sql语句，也可以是多条执行语句，但需要使用begin...end）\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>删除触发器</p>\n<ul>\n<li><code>drop trigger [if exists][触发器所在的数据库名.]触发器名</code> ，若没有指定则为当前默认数据库，修改前需要先删除后创建</li>\n</ul>\n</li>\n<li>\n<p>使用数据库</p>\n<ul>\n<li>可以使用 NEW 或者 OLD 这两张虚拟表\n<ul>\n<li>NEW 表示为最新的虚拟表</li>\n<li>OLD 表示为 sql 语句执行前的表，且全部数据为只读，不能被更新</li>\n</ul>\n</li>\n<li>在触发器涉及对触发表自身的更新操作时、，只能使用 before update 触发器，after update 不被允许</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第三节安全性与访问控制\"><a class=\"markdownIt-Anchor\" href=\"#第三节安全性与访问控制\">#</a> 第三节：安全性与访问控制</h3>\n<p>数据库的安全性是指<strong>保护数据库以防止不合法的使用而造成数据泄露、更改或破坏，所以安全性对于任何一个 DBMS 来说都是至关重要的</strong></p>\n<p>在 mysql 中，<strong>数据库系统对数据定 安全管理是使用身份验证、数据库用户权限确认等访问控制措施，来保护数据库中的信息资源，以防止这些数据遭受破坏</strong></p>\n<h4 id=\"一用户账号管理\"><a class=\"markdownIt-Anchor\" href=\"#一用户账号管理\">#</a> 一。用户账号管理</h4>\n<ol>\n<li>\n<p>创建用户账号</p>\n<pre><code class=\"language-mariadb\"> create user 'user_name'@'host_name' IDENTIFIED BY [PASSWORD]password\n</code></pre>\n<ul>\n<li>创建的时候，需要当前登录的用户拥有 mysql 数据库的 insert 权限或全局的 create insert 权限</li>\n<li>创建用户时，若用户名一直，主机名不同，则为两个账号；</li>\n<li>新创建的用户权限是能 show，不用 use 数据库，因而无法访问数据库表；</li>\n<li>create user 时可以不使用密码，但 mysql 允许该操作，但不推荐</li>\n<li>创建用户时，用户名和主机名都重复了会报错</li>\n</ul>\n</li>\n<li>\n<p>删除用户</p>\n<pre><code class=\"language-mariadb\">drop user '用户名'@'主机名'\n</code></pre>\n<ul>\n<li>删除用户的时候可以删除一个或多个，并且消除它们的权限</li>\n<li>要删除用户的话，必须当前用户拥有 mysql 的删除权限或者全局的删除权限</li>\n<li>删除的时候没有给主机名，默认为 %</li>\n<li>用户的删除不会影响他们创建的表、索引或其他数据库对象，因为数据库没有记录是谁创建了这些对象</li>\n</ul>\n</li>\n<li>\n<p>修改用户</p>\n<pre><code class=\"language-mariadb\">rename user '当前用户名'@'主机号' to '新的用户名'@'主机号'\n</code></pre>\n<ul>\n<li>需要拥有相对应的权限</li>\n<li>若系统中旧帐户不存在或者新账户已存在，则会报错</li>\n</ul>\n</li>\n<li>\n<p>修改用户密码</p>\n<pre><code class=\"language-mariadb\">set password for '用户名'@'主机名' = password('更改的新密码')|已经用password函数加密过的散列值\n</code></pre>\n<ul>\n<li>直接写明文是不可以的，因为存储在 mysql.user 表中，都是以 password 函数加密后的形式展示，但是真正输入密码的时候还是使用 password 加密前的密码。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"二账号权限管理\"><a class=\"markdownIt-Anchor\" href=\"#二账号权限管理\">#</a> 二。账号权限管理</h4>\n<ol>\n<li>\n<p>权限的授予：</p>\n<p>新的 SQL 用户不允许访问属于其他 SQL 用户的表，也不能创建自己的表，它必须被授权。</p>\n<ul>\n<li><strong>列权限</strong>：和表中的一个具体列相关</li>\n<li><strong>表权限</strong>：和一个具体表中的所有数据相关</li>\n<li><strong>数据库权限</strong>：和一个具体的数据库中的所有表相关</li>\n<li><strong>用户权限</strong>：和 mysql 所有的数据库相关</li>\n</ul>\n</li>\n<li>\n<p>查看用户的权限： <code>show grants for '用户名'@'主机名'</code></p>\n</li>\n<li>\n<p>案例演示</p>\n<ul>\n<li>\n<p>授予用户 <code>zhangsan</code>  在数据库 <code>mysql_test</code>  的表 <code>customers</code>  上拥有对列的 <code>cust_id</code>  和列 <code>cust_name</code>  的 SELECT 权限</p>\n<pre><code class=\"language-mariadb\">grant select(cust_id,cust_name)\n\tON mysql_test.customers\n\tTO 'zhangsan'@'localhost';\n</code></pre>\n</li>\n<li>\n<p>当前系统不存储在用户 <code>liming</code>  和用户 <code>huang</code> ，要求创建这两个用户，并设置对应的系统登录口令，同时授权他们在数据库 <code>mysql_test</code>  的表 <code>customers</code>  上拥有的 SLECT 和 UPDATE 的权限</p>\n<pre><code class=\"language-mariadb\">grant SELECT,UPDATE\n\tON mysql_test.customers\n\tTO 'liming'@'localhost' IDENTIFIED BY '123',\n\t\t'huang'@'localhost' IDENTIFIED BY '456';\n</code></pre>\n</li>\n<li>\n<p>授予系统中已存在用户 <code>wangwu</code>  可以在数据库 <code>mysql_test</code>  中执行所有数据库操作的权限</p>\n<pre><code class=\"language-mariadb\">grant all\n\tON mysql_test.*\n\tTO 'wangwu'@'localhost';\n</code></pre>\n</li>\n<li>\n<p>授予当前系统中已存在用户 <code>wangwu</code>  拥有创建用户的权限</p>\n<pre><code class=\"language-mariadb\">grant CREATE USER\n\tON *.*\n\tTO 'wangwu'@'localhost';\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"三权限的转移\"><a class=\"markdownIt-Anchor\" href=\"#三权限的转移\">#</a> 三。权限的转移</h4>\n<p>权限转移的语句其实就是在 grant 中增加 with 子句，其中 <code>with grant option</code>  表示将授予当前用户的权限授予给其他用户，无论其他用户有没有这个权限，且自己的权限不会消失</p>\n<ul>\n<li>\n<p>授予使用限制：</p>\n<ul>\n<li>max_questions：用户每小时允许执行的查询操作次数。</li>\n<li>max_updates：用户每小时允许执行连接操作次数。</li>\n<li>max_connections：用户每小时允许执行的连接操作次数。</li>\n<li>max_user_connections：用户允许同时建立的连接次数。</li>\n</ul>\n</li>\n<li>\n<p>修改方式</p>\n<pre><code class=\"language-mariadb\">update user set 限制的权限名 = 0 where user = '用户名';\nflush privileges;\t\t——记得需要刷新之后才能生效（不用grant语句去修改授权表的时候，都需要手动刷新）\n</code></pre>\n</li>\n<li>\n<p>演示案例</p>\n<ul>\n<li>授予当前系统中一个不存在的用户 zhou 在数据库 mysql_test 的表 customers 上拥有 SELECT 和 UPDATE 的权限，并允许可以将自身的这个权限授予给其他用户</li>\n</ul>\n<pre><code class=\"language-mariadb\">grant SELECT,UPDATE\n\tON mysql_test.customers\n\tTO 'zhou'@'localhost' IDENTIFIED BY '123'\n\twith grant option;\n</code></pre>\n</li>\n</ul>\n<h4 id=\"四权限的撤销\"><a class=\"markdownIt-Anchor\" href=\"#四权限的撤销\">#</a> 四。权限的撤销</h4>\n<p>就是回收用户的权限，操作语句跟授予（grant）很相似，但是<strong>需要操作者账户拥有对全局的创建和更新权限</strong>。语句上就是把 <code>grant</code>  更改为 <code>revoke</code> ，把 <code>TO</code>  改成 <code>FROM</code> 。可以收回特定用户的部分权限，也可以收回特定用户的全部权限。</p>\n<ul>\n<li>\n<p>操作案例</p>\n<ul>\n<li>\n<p>回收系统中已存在的用户 zhou 在数据库 mysql_test 的表 customers 上的 SELECT 权限</p>\n<pre><code class=\"language-mariadb\">revoke SELECT\n\tON mysql_test.customers\n\tFROM 'zhou'@'localhost';\n</code></pre>\n</li>\n<li>\n<p>回收系统中已存在的用户 zhou 在数据库 mysql_test 的表 customers 上的所有权限</p>\n<pre><code class=\"language-mariadb\">revoke all\n\tON mysql_test.customers\n\tFROM 'zhou'@'localhost';\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第四节事务与并发控制\"><a class=\"markdownIt-Anchor\" href=\"#第四节事务与并发控制\">#</a> 第四节：事务与并发控制</h3>\n<h3 id=\"一事务的概念\"><a class=\"markdownIt-Anchor\" href=\"#一事务的概念\">#</a> 一。事务的概念</h3>\n<p>​\t事务是用户定义的一个数据操作序列，这些操作可欧威一个完整的工作单元，<strong>要么全部执行，要么全部不执行，是一个不可分割的工作单位</strong>。</p>\n<p>** 事务与程序的不同：** 程序是静止的，事务是动态的，是程序的执行而不是程序本身；同一程序的多个独立执行可以同时进行，而每一步执行则是一个不同的事务</p>\n<h3 id=\"二事务的acid特征\"><a class=\"markdownIt-Anchor\" href=\"#二事务的acid特征\">#</a> 二。事务的 ACID 特征</h3>\n<ul>\n<li>原子性（Atomieity）\n<ul>\n<li>事务的原子性保证事务包含的一组更新操作是原子不可分的，即事务是不可分割的最小工作单位，所包含的这些操作是一个整体。</li>\n</ul>\n</li>\n<li>一致性（Consistency）\n<ul>\n<li>一致性要求事务必须满足于数据库的完整性约束，且事务执行完毕后将数据库由一个一致性状态转变到另一个一致性状态。数据库的一致性撞他是一种以一致性规则为基础的逻辑属性，一致性和原子性密切相关</li>\n</ul>\n</li>\n<li>隔离性（Isolation）\n<ul>\n<li>隔离性要求事务是彼此独立的、隔离的，即一个事务的执行不能被其他事务所干扰，一个事务对数据库变更的结果必须在它 COMMIT 后，另一个事务才能存取。</li>\n<li>多个事务并发执行时，其结果等价于它们的一种顺序执行的结果，就如同串行调度执行事务一般。这一特性也称为<strong>可串行性</strong></li>\n</ul>\n</li>\n<li>持续性（Durability）\n<ul>\n<li>持久性也称为永久性，是指一个事务一单提交，它对数据库中数据的改变就应该是永久性的，且接下来的其他操作或故障不应该改对其执行结果有任何影响</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三并发操作问题\"><a class=\"markdownIt-Anchor\" href=\"#三并发操作问题\">#</a> 三。并发操作问题</h3>\n<p><strong>事务的并发控制的基本单位</strong>，保证事务的 ACID 特征是事务处理的重要任务。</p>\n<ol>\n<li>典型的并发操作问题（破坏了事务的隔离性）\n<ul>\n<li>丢失更新\n<ul>\n<li>两个事务同时修改数据，导致一方的修改被丢失，这就是由于对数据的并发操作而带来的数据不一致性</li>\n</ul>\n</li>\n<li>不可重复读\n<ul>\n<li>指事务一读取数据后，事务二更新数据后，事务一无法读取到前一次的读取结果</li>\n</ul>\n</li>\n<li>读 “脏” 数据\n<ul>\n<li>银行取款问题</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>解决并发操作的数据不一致性问题的方法有\n<ul>\n<li>封锁</li>\n<li>时间戳</li>\n<li>乐观控制法</li>\n<li>多版本并发控制</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"四封锁\"><a class=\"markdownIt-Anchor\" href=\"#四封锁\">#</a> 四。封锁</h3>\n<p>封锁是最常用的并发控制技术。基本思想是：需要时，事物通过向系统请求对它所希望的数据对象（如数据库中的记录）加锁，以确保它不被非预期改变</p>\n<ol>\n<li>\n<p><strong>锁</strong></p>\n<p>一个锁实质上是允许或阻止一个事物对一个数据对象的存取特权，基本的封锁类型有两种</p>\n<ul>\n<li>排他锁（Exclusive Lock，X 锁），一般写操作要求用 X 锁</li>\n<li>共享锁（SharedLock，S 锁），一般读操作要求用 S 锁</li>\n</ul>\n</li>\n<li>\n<p><strong>用封锁进行并发控制</strong></p>\n<ol>\n<li>若事务 T 对数据 D 加锁，则所有的事务对数据 D 的锁请求都需要等到事务 T 放锁</li>\n<li>若事务 T 对数据 D 加了 S 锁，则别的事务还可以对数据 D 请求 S 锁</li>\n<li>事务执行数据库操作时都要先请求响应的锁，即对读请求 S 锁，对更新（插入、删除、修改）请求 X 锁。这个过程一般时有 DBMS 在执行操作时自动隐含地进行</li>\n<li>事务一直占有获得的锁直到事务 commit 或 rollback 时释放</li>\n</ol>\n<p>因此封锁机制可以解决上述并发操作所带来的三个不一致性问题</p>\n</li>\n<li>\n<p><strong>封锁的粒度</strong></p>\n<p>通常以粒度来描述封锁的<strong>数据单元的大小</strong>。</p>\n<p>DBMS 可以决定不同粒度的锁。由最底层的数据元素到最高层的整个数据库，粒度越细，并发性越大，但软件复杂性和系统开销也就越大</p>\n</li>\n<li>\n<p><strong>封锁的级别</strong></p>\n<ol>\n<li>\n<p>0 级封锁</p>\n<p>封锁的事务不重写其他非 0 级封锁事务的未提交的更新数据。这种状态实际上实用价值不大</p>\n</li>\n<li>\n<p>1 级封锁</p>\n<p>被封锁的事务不允许重写未提交的更新数据。这防止了丢失更新的发生。</p>\n</li>\n<li>\n<p>2 级封锁</p>\n<p>被封锁的事务既不重写也不读未提交的更新数据。这除了 1 级封锁的效果外还防止了读脏数据</p>\n</li>\n<li>\n<p>3 级封锁</p>\n<p>被封锁的事务不读未提交的更新数据，不写任何（包括读操作的）未提交的数据</p>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>死锁和活锁</strong></p>\n<ul>\n<li>\n<p>活锁</p>\n<ul>\n<li>级别低的事务无法执行</li>\n<li>避免方法：采用先来先服务的策略</li>\n</ul>\n</li>\n<li>\n<p>死锁（两个以上事务循环等待被同组中的另一事务锁住的数据单元的清醒，称为 “死锁 “）</p>\n<ul>\n<li>一次性锁请求</li>\n<li>锁请求排序</li>\n<li>序列化处理</li>\n<li>资源剥夺</li>\n</ul>\n<p>对待死锁的另一种办法时不去防止，而让其发生并随时进行检测，一旦检测到系统已发生了死锁再进行解除处理</p>\n</li>\n</ul>\n</li>\n<li>\n<p>可串行性</p>\n<p>一组事务的一个调度就是它们的基本操作的一种排序。若在一个调度中，对于任意两个事务 T1 和 T2，要么 T1 的所有操作都在 T2 前面，要么反之，则该调度是串行的</p>\n</li>\n<li>\n<p><strong>两段封锁法</strong></p>\n<p>封锁是一种并发控制技术，而可串行性是并发控制（调度）的正确性标准。</p>\n<p>两段封锁法（Two-Phase Locking，2PL）是一种最简单而有效的保障封锁其调度是可串行性的方法</p>\n<p>两端封锁法是<strong>事务遵循两段锁协议</strong>的调度方法。所谓协议，就是所有事物都必须遵循的关于基本操作执行顺序的一种限制</p>\n<ol>\n<li>\n<p>发展（Growing）或加锁阶段</p>\n<p>在此段期间，对任一数据对象进行任何操作之前，事物都要获得该对象的一个相应的锁</p>\n</li>\n<li>\n<p>收缩（Shrinking）或释放锁阶段</p>\n<p>一旦事务释放了一个锁，则标明它已进入了此阶段，此后它就不能再请求任何另外的锁</p>\n</li>\n<li>\n<p>定理：遵循两端锁协议的事务的任何并发调度都是可串行化的</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"第五节备份与恢复\"><a class=\"markdownIt-Anchor\" href=\"#第五节备份与恢复\">#</a> 第五节：备份与恢复</h3>\n<p>为了保证数据库的<strong>可靠性</strong>和<strong>完整性</strong>，DBMS 通常会采用各种有效的措施来进行维护。</p>\n<p>造成数据库中的数据丢失或被破坏可能是由于以下原因</p>\n<ul>\n<li>计算机硬件故障</li>\n<li>计算机软件故障</li>\n<li>病毒</li>\n<li>认为误操作</li>\n<li>自然灾害</li>\n<li>盗窃</li>\n</ul>\n<p>数据库备份时通过导出数据或者赋值表文件的方式来制作数据库的复本；数据库恢复则是当数据库出现故障或遭到破坏时，将备份的数据库加载到系统，从而使数据库从错误状态恢复到备份时的正确状态</p>\n<p>数据库恢复时以备份未基础，它是与备份相对应的系统维护和管理操作。系统进行恢复操作时，先执行一些系统安全性的检查，包括检查要恢复的数据库是否存在、数据库是否变化及数据库文件是否兼容等，然后根据锁曹志勇的数据库备份类型采取相应的恢复措施</p>\n<ul>\n<li>使用 SQL 语句备份与恢复数据库表数据的方法有一点不足：只能导出或导入数据的内容，而不包括表的结构，如果表的结构文件损坏，则必须先设法恢复原来表的结构</li>\n</ul>\n<h3 id=\"一备份数据\"><a class=\"markdownIt-Anchor\" href=\"#一备份数据\">#</a> 一．备份数据</h3>\n<pre><code class=\"language-mariadb\">SELECT sql语句 INTO OUTFILE '导出的路径+文件名'\nFIELDS  TERMINATED BY ','\t每个字段之间用,号隔开\nOPTIONALLY ENCLOSED BY &quot;&quot;\t每个字段用&quot;&quot;包裹起来\nESCAPED BY '*' \t\t\t\t将转义符\\改成*\nLINES TERMINATED BY '？'\t\t每一行数据用?隔开\n</code></pre>\n<h3 id=\"二导入数据\"><a class=\"markdownIt-Anchor\" href=\"#二导入数据\">#</a> 二。导入数据</h3>\n<pre><code class=\"language-mariadb\">LOAD DATA INFILE '路径+文件名'\nINTO TABLE '导入到的数据库表名'\n[ FIELDS TERMINATED BY \nOPTIONALLY ENCLOSED BY\nESCAPED BY \nLINES TERMINATED BY ] \t这里的设置需要跟备份时的设置保持一致，否则会导入出错\n</code></pre>\n<hr>\n<h2 id=\"第七章数据库应用设计与开发实例\"><a class=\"markdownIt-Anchor\" href=\"#第七章数据库应用设计与开发实例\">#</a> 第七章：数据库应用设计与开发实例</h2>\n<h3 id=\"第一节需求描述与分析\"><a class=\"markdownIt-Anchor\" href=\"#第一节需求描述与分析\">#</a> 第一节：需求描述与分析</h3>\n<h4 id=\"一功能性需求\"><a class=\"markdownIt-Anchor\" href=\"#一功能性需求\">#</a> 一。功能性需求</h4>\n<h4 id=\"二非功能性需求\"><a class=\"markdownIt-Anchor\" href=\"#二非功能性需求\">#</a> 二。非功能性需求</h4>\n<table>\n<thead>\n<tr>\n<th>质量需求名称</th>\n<th>质量需求的详细要求</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>可靠性</td>\n<td><strong>在不运行期间</strong>，每个月最多出现一次由外界因素造成的系统故障；<br /><strong>在运行期间</strong>，除非遇到特殊情况，否则要<strong>保证正常使用</strong></td>\n</tr>\n<tr>\n<td>正确性</td>\n<td>需要<strong>保证</strong>数据库中的<strong>数据正确</strong>和系统的各个<strong>功能模块的业务逻辑正确</strong></td>\n</tr>\n<tr>\n<td>兼容性</td>\n<td>可以在与 IE 内核兼容的任一主流浏览器上运行 (B/S 结构)</td>\n</tr>\n<tr>\n<td>健壮性</td>\n<td>要经常进行健壮性测试，不断加强对非格式化操作的应变能力</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"第二节系统设计\"><a class=\"markdownIt-Anchor\" href=\"#第二节系统设计\">#</a> 第二节：系统设计</h3>\n<h3 id=\"第三节系统实现\"><a class=\"markdownIt-Anchor\" href=\"#第三节系统实现\">#</a> 第三节：系统实现</h3>\n<h3 id=\"第四节系统测试与维护\"><a class=\"markdownIt-Anchor\" href=\"#第四节系统测试与维护\">#</a> 第四节：系统测试与维护</h3>\n<hr>\n<h2 id=\"第八章数据库管理技术的发展\"><a class=\"markdownIt-Anchor\" href=\"#第八章数据库管理技术的发展\">#</a> 第八章：数据库管理技术的发展</h2>\n<h3 id=\"第一节数据库技术发展概述\"><a class=\"markdownIt-Anchor\" href=\"#第一节数据库技术发展概述\">#</a> 第一节：数据库技术发展概述</h3>\n<h4 id=\"一第一代数据库系统\"><a class=\"markdownIt-Anchor\" href=\"#一第一代数据库系统\">#</a> 一。第一代数据库系统</h4>\n<ul>\n<li>代表\n<ul>\n<li>IMS，层次模型，IBM 公司做的，1969 年</li>\n<li>CODASYL，网状模式，DBTG 公司制作，1970 年 u</li>\n</ul>\n</li>\n<li>特点\n<ul>\n<li>支持三级模式（层次模型、网状模型、关系模型都支持三级模式）</li>\n<li>用存取路径表示联系</li>\n<li>独立的 DDL</li>\n<li>导航的 DML</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"二第二代数据库系统\"><a class=\"markdownIt-Anchor\" href=\"#二第二代数据库系统\">#</a> 二。第二代数据库系统</h4>\n<ul>\n<li>关系数据库系统\n<ul>\n<li>E.F.Codd 提出<strong>关系代数、范式</strong>，1970 年</li>\n</ul>\n</li>\n<li>系统原型\n<ul>\n<li>IBM System R</li>\n<li>Berkeley INGRES</li>\n<li>1980 年后，新开发的系统都是关系型的</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"三新一代数据库系统\"><a class=\"markdownIt-Anchor\" href=\"#三新一代数据库系统\">#</a> 三。新一代数据库系统</h4>\n<p>OODB 第三代的代表？</p>\n<p>没有被市场普遍接受</p>\n<p>ORDB，新一代将是多种模型并存</p>\n<p>” 第三代 “的基本特征：</p>\n<ol>\n<li>应支持<strong>数据管理</strong>、<strong>对象管理</strong>和<strong>知识管理</strong></li>\n<li>保持或继承 RDB 的技术</li>\n<li>开放性</li>\n</ol>\n<p>应用：数据仓库、工程数据库、统计数据库、空间数据库、科学数据库等多种数据库</p>\n<h3 id=\"第二节数据仓库与数据挖掘\"><a class=\"markdownIt-Anchor\" href=\"#第二节数据仓库与数据挖掘\">#</a> 第二节：数据仓库与数据挖掘</h3>\n<h4 id=\"一从数据库到数据仓库\"><a class=\"markdownIt-Anchor\" href=\"#一从数据库到数据仓库\">#</a> 一。从数据库到数据仓库</h4>\n<p>数据仓库主要特征：</p>\n<ol>\n<li><strong>面向主题</strong></li>\n<li><strong>集成性</strong></li>\n<li><strong>数据的非易失性</strong></li>\n<li><strong>数据的时变性</strong></li>\n</ol>\n<p>数据仓库具有三个常用的重要概念，即粒度、分割和维</p>\n<ol>\n<li>\n<p>粒度</p>\n<p>粒度问题是设计数据仓库的一个最重要的方面。粒度是指数据仓库的数据单位中保存数据的细化或综合程度的级别</p>\n</li>\n<li>\n<p>分割</p>\n<p>分割时将数据分散到各自的物理单元中，以便能分别处理，以提高数据处理的效率</p>\n</li>\n<li>\n<p>维</p>\n<p>维时人们观察数据的特定角度，是考虑问题时的一类属性</p>\n</li>\n</ol>\n<h4 id=\"二数据挖掘技术\"><a class=\"markdownIt-Anchor\" href=\"#二数据挖掘技术\">#</a> 二。数据挖掘技术</h4>\n<p>数据挖掘具备下列几种功能：</p>\n<ol>\n<li>概念描述</li>\n<li>关联分析</li>\n<li>分类与预测</li>\n<li>聚类</li>\n<li>孤立点检测</li>\n<li>趋势和演变分析</li>\n</ol>\n<h3 id=\"第三节大数据管理技能\"><a class=\"markdownIt-Anchor\" href=\"#第三节大数据管理技能\">#</a> 第三节：大数据管理技能</h3>\n<h4 id=\"一大数据的定义\"><a class=\"markdownIt-Anchor\" href=\"#一大数据的定义\">#</a> 一。大数据的定义</h4>\n<p>数据尚无统一的定义，通常被认为是数据量很大、数据形式多样化的数据</p>\n<p>特征：</p>\n<ol>\n<li>数据量巨大，即大量化（Volume）</li>\n<li>数据种类繁多，即多样化（Variety）</li>\n<li>处理速度快，即快速化（Velocity）</li>\n<li>价值 (Value) 密度低</li>\n</ol>\n<h4 id=\"二大数据管理技术典型代表\"><a class=\"markdownIt-Anchor\" href=\"#二大数据管理技术典型代表\">#</a> 二。大数据管理技术典型代表</h4>\n<ol>\n<li>\n<p>大数据存储</p>\n</li>\n<li>\n<p>NoSQL 数据管理系统</p>\n<ol>\n<li>键值（Key-value）存储：常见的键值存储数据库包括 Tokyo Cabinet/Tyrant、Redis 和 Oracle BDB 等</li>\n<li>文档存储：常见的文档性数据库由 CouchDB、MongoDB 等</li>\n<li>列存储：常见的列存储数据库由 Hbase</li>\n<li>图存储：图存储数据库是基于图理论构建的，使用节点、属性和边的概念</li>\n</ol>\n</li>\n<li>\n<p>MapReduce 技术</p>\n<p>MapReduce 是一种并行变成模型。它把计算过程分解为两个阶段，即 Map 阶段和 Reduce 阶段</p>\n</li>\n</ol>\n",
            "tags": [
                "数据库系统原理"
            ]
        }
    ]
}